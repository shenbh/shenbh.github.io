<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="private,安卓优化," />










<meta name="description" content="启动速度优化在性能优化的整个知识体系中，最重要的就是稳定性优化，在上一篇文章 《深入探索Android稳定性优化》 中我们已经深入探索了Android稳定性优化的疆域。那么，除了稳定性以外，对于性能纬度来说，哪个方面的性能是最重要的呢？毫无疑问，就是应用的启动速度。下面，就让我们扬起航帆，一起来逐步深入探索Android启动速度优化的奥秘。 思维导图大纲 一、启动优化的意义如果我们去一家餐厅吃饭，">
<meta property="og:type" content="article">
<meta property="og:title" content="优化-启动速度优化">
<meta property="og:url" content="http://shenbh.github.io/posts/248e496b/index.html">
<meta property="og:site_name" content="AB">
<meta property="og:description" content="启动速度优化在性能优化的整个知识体系中，最重要的就是稳定性优化，在上一篇文章 《深入探索Android稳定性优化》 中我们已经深入探索了Android稳定性优化的疆域。那么，除了稳定性以外，对于性能纬度来说，哪个方面的性能是最重要的呢？毫无疑问，就是应用的启动速度。下面，就让我们扬起航帆，一起来逐步深入探索Android启动速度优化的奥秘。 思维导图大纲 一、启动优化的意义如果我们去一家餐厅吃饭，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ba37d61c8ae439fb27cd4723a576816~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f1b02f4b9c471f9d0bfc7315b5f741~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2020-09-05T02:31:58.000Z">
<meta property="article:modified_time" content="2022-11-02T07:22:54.651Z">
<meta property="article:author" content="阿炳">
<meta property="article:tag" content="private">
<meta property="article:tag" content="安卓优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ba37d61c8ae439fb27cd4723a576816~tplv-k3u1fbpfcp-zoom-1.image">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://shenbh.github.io/posts/248e496b/"/>





  <title>优化-启动速度优化 | AB</title><meta name="robots" content="noindex">
  








<meta name="generator" content="Hexo 6.1.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AB</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Just do IT Now.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shenbh.github.io/posts/248e496b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">优化-启动速度优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-05T10:31:58+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="启动速度优化"><a href="#启动速度优化" class="headerlink" title="启动速度优化"></a>启动速度优化</h1><p>在性能优化的整个知识体系中，最重要的就是稳定性优化，在上一篇文章 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903972587716621">《深入探索Android稳定性优化》</a> 中我们已经深入探索了Android稳定性优化的疆域。那么，<strong>除了稳定性以外，对于性能纬度来说，哪个方面的性能是最重要的呢</strong>？毫无疑问，就是<strong>应用的启动速度</strong>。下面，<strong>就让我们扬起航帆，一起来逐步深入探索Android启动速度优化的奥秘</strong>。</p>
<h1 id="思维导图大纲"><a href="#思维导图大纲" class="headerlink" title="思维导图大纲"></a>思维导图大纲</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ba37d61c8ae439fb27cd4723a576816~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h1 id="一、启动优化的意义"><a href="#一、启动优化的意义" class="headerlink" title="一、启动优化的意义"></a>一、启动优化的意义</h1><p>如果我们去一家餐厅吃饭，在点餐的时候等了半天都没有服务人员过来，可能就没有耐心等待直接走了。</p>
<p>对于App来说，也是同样如此，<strong>如果用户点击App后，App半天都打不开，用户就可能失去耐心卸载应用</strong>。</p>
<p><strong>启动速度是用户对我们App的第一体验</strong>，打开应用后才能去使用其中提供的强大功能，就算我们应用的内部界面设计的再精美，功能再强大，<strong>如果启动速度过慢，用户第一印象就会很差</strong>。</p>
<p>因此，拯救App的启动速度，迫在眉睫。</p>
<h1 id="二、应用启动流程"><a href="#二、应用启动流程" class="headerlink" title="二、应用启动流程"></a>二、应用启动流程</h1><h2 id="1-、应用启动的类型"><a href="#1-、应用启动的类型" class="headerlink" title="1 、应用启动的类型"></a>1 、应用启动的类型</h2><p>应用启动的类型总共分为如下三种：</p>
<ul>
<li><strong>冷启动</strong></li>
<li><strong>热启动</strong></li>
<li><strong>温启动</strong></li>
</ul>
<p>下面，我们来详细分析下各个启动类型的特点及流程。</p>
<h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><p>从点击应用图标到UI界面完全显示且用户可操作的全部过程。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>耗时最多，<strong>衡量标准</strong>。</p>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>Click Event    -&gt;     IPC     -&gt;     Process.start     -&gt;      ActivityThread -&gt;    bindApplication      -&gt;      LifeCycle    -&gt;     ViewRootImpl</p>
<p>首先，用户进行了一个点击操作，这个点击事件它会触发一个IPC的操作，之后便会执行到Process的start方法中，这个方法是用于进程创建的，接着，便会执行到ActivityThread的main方法，这个方法可以看做是我们单个App进程的入口，相当于Java进程的main方法，在其中会<strong>执行消息循环的创建与主线程Handler的创建</strong>，创建完成之后，就会执行到 bindApplication 方法，在这里<strong>使用了反射去创建 Application</strong>以及调用了 Application相关的生命周期，Application结束之后，便会执行Activity的生命周期，在Activity生命周期结束之后，<strong>最后，就会执行到 ViewRootImpl，这时才会进行真正的一个页面的绘制</strong>。</p>
<h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><p>直接从后台切换到前台。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>启动速度最快。</p>
<h3 id="温启动"><a href="#温启动" class="headerlink" title="温启动"></a>温启动</h3><p>只会重走Activity的生命周期，而不会重走进程的创建，Application的创建与生命周期等。</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>较快，介于冷启动和热启动之间的一个速度。</p>
<h4 id="启动流程-1"><a href="#启动流程-1" class="headerlink" title="启动流程"></a>启动流程</h4><p>LifeCycle    -&gt;     ViewRootImpl</p>
<h4 id="ViewRootImpl是什么？"><a href="#ViewRootImpl是什么？" class="headerlink" title="ViewRootImpl是什么？"></a>ViewRootImpl是什么？</h4><p>它是GUI管理系统与GUI呈现系统之间的桥梁。<strong>每一个ViewRootImpl关联一个Window， ViewRootImpl 最终会通过它的setView方法绑定Window所对应的View，并通过其performTraversals方法对View进行布局、测量和绘制</strong>。</p>
<h2 id="2、冷启动分析及其优化方向"><a href="#2、冷启动分析及其优化方向" class="headerlink" title="2、冷启动分析及其优化方向"></a>2、冷启动分析及其优化方向</h2><h3 id="冷启动涉及的相关任务"><a href="#冷启动涉及的相关任务" class="headerlink" title="冷启动涉及的相关任务"></a>冷启动涉及的相关任务</h3><h4 id="冷启动之前"><a href="#冷启动之前" class="headerlink" title="冷启动之前"></a>冷启动之前</h4><ul>
<li>首先，会启动App</li>
<li>然后，加载空白Window</li>
<li>最后，创建进程</li>
</ul>
<p>需要注意的是，这些都是系统的行为，一般情况下我们是无法直接干预的。</p>
<h4 id="随后任务"><a href="#随后任务" class="headerlink" title="随后任务"></a>随后任务</h4><ul>
<li>首先，创建Application</li>
<li>启动主线程</li>
<li>创建MainActivity</li>
<li>加载布局</li>
<li>布置屏幕</li>
<li>首帧绘制</li>
</ul>
<p>通常到了<strong>界面首帧绘制完成</strong>后，我们就可以认为<strong>启动已经结束</strong>了。</p>
<h3 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h3><p>我们的优化方向就是 <strong>Application和Activity的生命周期</strong> 这个阶段，因为这个阶段的时机对于我们来说是<strong>可控的</strong>。</p>
<h1 id="三、启动耗时检测"><a href="#三、启动耗时检测" class="headerlink" title="三、启动耗时检测"></a>三、启动耗时检测</h1><h2 id="1、查看Logcat"><a href="#1、查看Logcat" class="headerlink" title="1、查看Logcat"></a>1、查看Logcat</h2><p>在Android Studio Logcat中<strong>过滤关键字“Displayed”</strong>，可以看到对应的冷启动耗时日志。</p>
<h2 id="2、adb-shell"><a href="#2、adb-shell" class="headerlink" title="2、adb shell"></a>2、adb shell</h2><p>使用adb shell获取应用的启动时间</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中的AppstartActivity全路径可以省略前面的packageName</span></span><br><span class="line"><span class="selector-tag">adb</span> <span class="selector-tag">shell</span> <span class="selector-tag">am</span> <span class="selector-tag">start</span> <span class="selector-tag">-W</span> <span class="selector-attr">[packageName]</span>/<span class="selector-attr">[AppstartActivity全路径]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>例子：am start -S -W com.xm597.app&#x2F;com.xm597.root.launcher.activity.LauncherActivity</p>
</blockquote>
<p>执行后会得到三个时间：ThisTime、TotalTime和WaitTime，详情如下：</p>
<h3 id="ThisTime"><a href="#ThisTime" class="headerlink" title="ThisTime"></a>ThisTime</h3><p>表示最后一个Activity启动耗时。</p>
<h3 id="TotalTime"><a href="#TotalTime" class="headerlink" title="TotalTime"></a>TotalTime</h3><p>表示所有Activity启动耗时。</p>
<h3 id="WaitTime"><a href="#WaitTime" class="headerlink" title="WaitTime"></a>WaitTime</h3><p>表示AMS启动Activity的总耗时。</p>
<p>一般来说，只需查看得到的TotalTime，即应用的启动时间，其包括 <strong>创建进程 + Application初始化 + Activity初始化到界面显示</strong> 的过程。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>1、<strong>线下使用方便，不能带到线上</strong>。</li>
<li>2、<strong>非严谨、精确时间</strong>。</li>
</ul>
<h2 id="3、代码打点（函数插桩）"><a href="#3、代码打点（函数插桩）" class="headerlink" title="3、代码打点（函数插桩）"></a>3、代码打点（函数插桩）</h2><p>可以写一个统计耗时的工具类来记录整个过程的耗时情况。其中需要注意的有：</p>
<ul>
<li>在上传数据到服务器时<strong>建议根据用户ID的尾号来抽样上报</strong>。</li>
<li>在项目中<strong>核心基类的关键回调函数和核心方法</strong>中加入打点。</li>
</ul>
<p>其代码如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 耗时监视器对象，记录整个过程的耗时情况，可以用在很多需要统计的地方，比如Activity的启动耗时和Fragment的启动耗时。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeMonitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> TAG = TimeMonitor.<span class="keyword">class</span>.<span class="built_in">getSimpleName</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mMonitord = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存一个耗时统计模块的各种耗时，tag对应某一个阶段的时间</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;<span class="type">String</span>, Long&gt; mTimeTag = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mStartTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeMonitor</span><span class="params">(<span class="type">int</span> mMonitorId)</span> </span>&#123;</span><br><span class="line">        Log.<span class="built_in">d</span>(TAG, <span class="string">&quot;init TimeMonitor id: &quot;</span> + mMonitorId);</span><br><span class="line">        <span class="keyword">this</span>.mMonitorId = mMonitorId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">getMonitorId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMonitorId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">startMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次重新启动都把前面的数据清除，避免统计错误的数据</span></span><br><span class="line">        <span class="keyword">if</span> (mTimeTag.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mTimeTag.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        mStartTime = System.<span class="built_in">currentTimeMillis</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 每打一次点，记录某个tag的耗时</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">recordingTimeTag</span><span class="params">(<span class="type">String</span> tag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若保存过相同的tag，先清除</span></span><br><span class="line">        <span class="keyword">if</span> (mTimeTag.<span class="built_in">get</span>(tag) != null) &#123;</span><br><span class="line">            mTimeTag.<span class="built_in">remove</span>(tag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> time = System.<span class="built_in">currentTimeMillis</span>() - mStartTime;</span><br><span class="line">        Log.<span class="built_in">d</span>(TAG, tag + <span class="string">&quot;: &quot;</span> + time);</span><br><span class="line">        mTimeTag.<span class="built_in">put</span>(tag, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">end</span><span class="params">(<span class="type">String</span> tag, <span class="type">boolean</span> writeLog)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">recordingTimeTag</span>(tag);</span><br><span class="line">        <span class="built_in">end</span>(writeLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">end</span><span class="params">(<span class="type">boolean</span> writeLog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (writeLog) &#123;</span><br><span class="line">            <span class="comment">//写入到本地文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashMap&lt;<span class="type">String</span>, Long&gt; <span class="title">getTimeTags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTimeTag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了<strong>使代码更好管理</strong>，我们需要定义一个<strong>打点配置类</strong>，如下所示：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 打点配置类，用于统计各阶段的耗时，便于代码的维护和管理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TimeMonitorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用启动耗时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> TIME_MONITOR_ID_APPLICATION_START = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外，耗时统计可能会在多个模块和类中需要打点，所以需要一个<strong>单例类来管理各个耗时统计的数据</strong>：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 采用单例管理各个耗时统计的数据。</span><br><span class="line">*/<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span> class TimeMonitorManager &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> TimeMonitorManager mTimeMonitorManager = null;<span class="keyword"></span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, TimeMonitor&gt; mTimeMonitorMap = null;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span> synchronized<span class="keyword"> static</span> TimeMonitorManager getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(mTimeMonitorManager == null) &#123;</span><br><span class="line">            mTimeMonitorManager =<span class="built_in"> new </span>TimeMonitorManager();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>mTimeMonitorManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span> TimeMonitorManager() &#123;</span><br><span class="line">        this.mTimeMonitorMap =<span class="built_in"> new </span>HashMap&lt;Integer, TimeMonitor&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化打点模块</span><br><span class="line">    */</span><br><span class="line">   <span class="keyword"> public</span> void resetTimeMonitor(int id) &#123;</span><br><span class="line">       <span class="built_in"> if </span>(mTimeMonitorMap.get(id) != null) &#123;</span><br><span class="line">            mTimeMonitorMap.remove(id);</span><br><span class="line">        &#125;</span><br><span class="line">        getTimeMonitor(id).startMonitor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 获取打点器</span><br><span class="line">    */</span><br><span class="line">   <span class="keyword"> public</span> TimeMonitor getTimeMonitor(int id) &#123;</span><br><span class="line">        TimeMonitor<span class="built_in"> monitor </span>= mTimeMonitorMap.get(id);</span><br><span class="line">       <span class="built_in"> if </span>(monitor == null) &#123;</span><br><span class="line">           <span class="built_in"> monitor </span>=<span class="built_in"> new </span>TimeMonitor(id);</span><br><span class="line">            mTimeMonitorMap.put(id, monitor);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>monitor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要在以下几个方面需要打点：</p>
<ul>
<li><strong>应用程序的生命周期节点</strong>。</li>
<li><strong>启动时需要初始化的重要方法</strong>，例如数据库初始化，读取本地的一些数据。</li>
<li><strong>其他耗时的一些算法</strong>。</li>
</ul>
<p>例如，启动时在Application和第一个Activity加入打点统计：</p>
<h3 id="Application-打点"><a href="#Application-打点" class="headerlink" title="Application 打点"></a>Application 打点</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void attach<span class="constructor">BaseContext(Context <span class="params">base</span>)</span> &#123;</span><br><span class="line">    super.attach<span class="constructor">BaseContext(<span class="params">base</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">TimeMonitorManager</span>.</span></span>get<span class="constructor">Instance()</span>.reset<span class="constructor">TimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void on<span class="constructor">Create()</span> &#123;</span><br><span class="line">    super.on<span class="constructor">Create()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">SoLoader</span>.</span></span>init(this, <span class="comment">/* native exopackage */</span> <span class="literal">false</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">TimeMonitorManager</span>.</span></span>get<span class="constructor">Instance()</span>.get<span class="constructor">TimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START)</span>.recording<span class="constructor">TimeTag(<span class="string">&quot;Application-onCreate&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第一个Activity打点"><a href="#第一个Activity打点" class="headerlink" title="第一个Activity打点"></a>第一个Activity打点</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">TimeMonitorManager</span>.</span></span>get<span class="constructor">Instance()</span>.get<span class="constructor">TimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START)</span>.recording<span class="constructor">TimeTag(<span class="string">&quot;SplashActivity-onCreate&quot;</span>)</span>;</span><br><span class="line">    super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    init<span class="constructor">Data()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">TimeMonitorManager</span>.</span></span>get<span class="constructor">Instance()</span>.get<span class="constructor">TimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START)</span>.recording<span class="constructor">TimeTag(<span class="string">&quot;SplashActivity-onCreate-Over&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void on<span class="constructor">Start()</span> &#123;</span><br><span class="line">    super.on<span class="constructor">Start()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">TimeMonitorManager</span>.</span></span>get<span class="constructor">Instance()</span>.get<span class="constructor">TimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START)</span>.<span class="keyword">end</span>(<span class="string">&quot;SplashActivity-onStart&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p><strong>精确，可带到线上，但是代码有侵入性，修改成本高</strong>。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>1、在上传数据到服务器时<strong>建议根据用户ID的尾号来抽样上报</strong>。</p>
</li>
<li><p>2、<strong>onWindowFocusChanged只是首帧时间，App启动完成的结束点应该是真实数据展示出来的时候（通常来说都是首帧数据），如列表第一条数据展示，记得使用getViewTreeObserver().addOnPreDrawListener()（在API 16以上可以使用addOnDrawListener），它会把任务延迟到列表显示后再执行</strong>，例如，在 Awesome-WanAndroid 项目的主页就有一个RecyclerView实现的列表，启动结束的时间就是列表的首帧时间，也即列表第一条数据展示的时候。这里，我们直接在RecyclerView的适配器ArticleListAdapter的convert（onBindViewHolder）方法中加上如下代码即可：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (helper.get<span class="constructor">LayoutPosition()</span><span class="operator"> == </span><span class="number">1</span><span class="operator"> &amp;&amp; </span>!mHasRecorded) &#123;</span><br><span class="line">    mHasRecorded = <span class="literal">true</span>;</span><br><span class="line">    helper.get<span class="constructor">View(R.<span class="params">id</span>.<span class="params">item_search_pager_group</span>)</span>.get<span class="constructor">ViewTreeObserver()</span>.add<span class="constructor">OnPreDrawListener(<span class="params">new</span> ViewTreeObserver.OnPreDrawListener()</span> &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean on<span class="constructor">PreDraw()</span> &#123;</span><br><span class="line">            helper.get<span class="constructor">View(R.<span class="params">id</span>.<span class="params">item_search_pager_group</span>)</span>.get<span class="constructor">ViewTreeObserver()</span>.remove<span class="constructor">OnPreDrawListener(<span class="params">this</span>)</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">LogHelper</span>.</span></span>i(<span class="string">&quot;FeedShow&quot;</span>);</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>具体的实例代码可在 <a href="https://link.juejin.cn/?target=https://github.com/JsonChao/Awesome-WanAndroid/blob/master/app/src/main/java/json/chao/com/wanandroid/ui/mainpager/adapter/ArticleListAdapter.java">这里查看</a>。</p>
<h4 id="为什么不使用onWindowFocusChanged这个方法作为启动结束点？"><a href="#为什么不使用onWindowFocusChanged这个方法作为启动结束点？" class="headerlink" title="为什么不使用onWindowFocusChanged这个方法作为启动结束点？"></a>为什么不使用onWindowFocusChanged这个方法作为启动结束点？</h4><p>因为用户看到真实的界面是需要有网络请求返回真实数据的，但是onWindowFocusChanged只是界面绘制的首帧时机，但是列表中的数据是需要从网络中下载得到的，所以应该以列表的首帧数据作为启动结束点。</p>
<h2 id="4、AOP-Aspect-Oriented-Programming-打点"><a href="#4、AOP-Aspect-Oriented-Programming-打点" class="headerlink" title="4、AOP(Aspect Oriented Programming) 打点"></a>4、AOP(Aspect Oriented Programming) 打点</h2><p>面向切面编程，<strong>通过预编译和运行期动态代理实现程序功能统一维护</strong>的一种技术。</p>
<h3 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h3><p>利用AOP可<strong>以对业务逻辑的各个部分进行隔离</strong>，从而使得业务逻辑各部分之间的<strong>耦合性降低</strong>，<strong>提高程序的可重用性</strong>，同时大大<strong>提高了开发效率</strong>。</p>
<h3 id="2、AOP核心概念"><a href="#2、AOP核心概念" class="headerlink" title="2、AOP核心概念"></a>2、AOP核心概念</h3><h4 id="1、横切关注点"><a href="#1、横切关注点" class="headerlink" title="1、横切关注点"></a>1、横切关注点</h4><p>对哪些方法进行拦截，拦截后怎么处理。</p>
<h4 id="2、切面（Aspect）"><a href="#2、切面（Aspect）" class="headerlink" title="2、切面（Aspect）"></a>2、切面（Aspect）</h4><p>类是对物体特征的抽象，<strong>切面就是对横切关注点的抽象</strong>。</p>
<h4 id="3、连接点（JoinPoint）"><a href="#3、连接点（JoinPoint）" class="headerlink" title="3、连接点（JoinPoint）"></a>3、连接点（JoinPoint）</h4><p>被拦截到的点（方法、字段、构造器）。</p>
<h4 id="4、切入点（PointCut）"><a href="#4、切入点（PointCut）" class="headerlink" title="4、切入点（PointCut）"></a>4、切入点（PointCut）</h4><p>对JoinPoint进行拦截的定义。</p>
<h4 id="5、通知（Advice）"><a href="#5、通知（Advice）" class="headerlink" title="5、通知（Advice）"></a>5、通知（Advice）</h4><p><strong>拦截到JoinPoint后要执行的代码</strong>，分为<strong>前置、后置、环绕</strong>三种类型。</p>
<h3 id="3、准备：接入AspectJx进行切面编码"><a href="#3、准备：接入AspectJx进行切面编码" class="headerlink" title="3、准备：接入AspectJx进行切面编码"></a>3、准备：接入AspectJx进行切面编码</h3><p>首先，为了在Android使用AOP埋点需要引入AspectJ，在项目根目录的build.gradle下加入：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">classpath</span> &#x27;com.hujiang.aspectjx:gradle-android-plugin- aspectjx:<span class="number">2</span>.<span class="number">0</span>.<span class="number">0</span>&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，在app目录下的build.gradle下加入：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apply</span> plugin: <span class="string">&#x27;android-aspectjx&#x27;</span></span><br><span class="line">implement <span class="string">&#x27;org.aspectj:aspectjrt:1.8.+&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、AOP埋点实战"><a href="#4、AOP埋点实战" class="headerlink" title="4、AOP埋点实战"></a>4、AOP埋点实战</h3><p>JoinPoint一般定位在如下位置</p>
<ul>
<li>1、<strong>函数调用</strong></li>
<li>2、<strong>获取、设置变量</strong></li>
<li>3、<strong>类初始化</strong></li>
</ul>
<p><strong>使用PointCut对我们指定的连接点进行拦截，通过Advice，就可以拦截到JoinPoint后要执行的代码</strong>。Advice通常有以下几种类型：</p>
<ul>
<li>1、<strong>Before</strong>：PointCut之前执行</li>
<li>2、<strong>After</strong>：PointCut之后执行</li>
<li>3、<strong>Around</strong>：PointCut之前、之后分别执行</li>
</ul>
<p>首先，我们举一个小栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* android.app.Activity.on**(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCalled</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>在 execution 中的是一个匹配规则</strong>，第一个 * 代表<strong>匹配任意的方法返回值</strong>，后面的语法代码<strong>匹配所有Activity中on开头的方法</strong>。</p>
<p>其中execution是处理Join Point的类型，在AspectJx中共有两种类型，如下所示：</p>
<ul>
<li>1、<strong>call</strong>：插入在函数体里面</li>
<li>2、<strong>execution</strong>：插入在函数体外面</li>
</ul>
<h4 id="如何统计Application中的所有方法耗时？"><a href="#如何统计Application中的所有方法耗时？" class="headerlink" title="如何统计Application中的所有方法耗时？"></a>如何统计Application中的所有方法耗时？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationAop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;call (* com.json.chao.application.BaseApplication.**(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.toShortString();</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, name + <span class="string">&quot; cost&quot;</span> +     (System.currentTimeMillis() - time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们需要注意 <strong>不同的Action类型其对应的方法入参是不同的</strong>，具体的差异如下所示：</p>
<ul>
<li>当Action为<strong>Before、After</strong>时，方法入参为<strong>JoinPoint</strong>。</li>
<li>当Action为<strong>Around</strong>时，方法入参为<strong>ProceedingPoint</strong>。</li>
</ul>
<h5 id="Around和Before、After的最大区别"><a href="#Around和Before、After的最大区别" class="headerlink" title="Around和Before、After的最大区别:"></a>Around和Before、After的最大区别:</h5><p><strong>ProceedingPoint</strong>不同于JoinPoint，其<strong>提供了proceed方法执行目标方法</strong>。</p>
<h3 id="5、总结AOP特性"><a href="#5、总结AOP特性" class="headerlink" title="5、总结AOP特性"></a>5、总结AOP特性</h3><ul>
<li>1、<strong>无侵入性</strong></li>
<li>2、<strong>修改方便，建议使用</strong></li>
</ul>
<h2 id="5、启动速度分析工具-—-TraceView"><a href="#5、启动速度分析工具-—-TraceView" class="headerlink" title="5、启动速度分析工具 — TraceView"></a>5、启动速度分析工具 — TraceView</h2><h3 id="1、使用方式"><a href="#1、使用方式" class="headerlink" title="1、使用方式"></a>1、使用方式</h3><ul>
<li>1、代码中添加：<strong>Debug.startMethodTracing()、检测方法、Debug.stopMethodTracing()<strong>。（需要</strong>使用adb pull将生成的</strong>.trace文件导出到电脑，然后使用Android Studio的Profiler进行加载）</li>
<li>2、打开 <strong>Profiler  -&gt;  CPU   -&gt;    点击 Record   -&gt;  点击 Stop  -&gt;  查看Profiler下方Top Down&#x2F;Bottom Up 区域</strong>，以找出<strong>耗时的热点方法</strong>。</li>
</ul>
<h3 id="2、Profile-CPU"><a href="#2、Profile-CPU" class="headerlink" title="2、Profile CPU"></a>2、Profile CPU</h3><p>使用 Profile 的 CPU 模块可以帮我们快速找到耗时的热点方法，下面，我们来详细来分析一下这个模块。</p>
<h3 id="1、Trace-types"><a href="#1、Trace-types" class="headerlink" title="1、Trace types"></a>1、Trace types</h3><p>Trace types 有四种，如下所示。</p>
<h4 id="1、Trace-Java-Methods"><a href="#1、Trace-Java-Methods" class="headerlink" title="1、Trace Java Methods"></a>1、Trace Java Methods</h4><p>会记录每个方法的时间、CPU信息。对运行时性能影响较大。</p>
<h4 id="2、Sample-Java-Methods"><a href="#2、Sample-Java-Methods" class="headerlink" title="2、Sample Java Methods"></a>2、Sample Java Methods</h4><p>相比于Trace Java Methods会记录每个方法的时间、CPU信息，它<strong>会在应用的Java代码执行期间频繁捕获应用的调用堆栈</strong>，对运行时性能的影响比较小，<strong>能够记录更大的数据区域</strong>。</p>
<h4 id="3、Sample-C-x2F-C-Functions"><a href="#3、Sample-C-x2F-C-Functions" class="headerlink" title="3、Sample C&#x2F;C++ Functions"></a>3、Sample C&#x2F;C++ Functions</h4><p>需部署到<strong>Android 8.0及以上</strong>设备，<strong>内部使用simpleperf跟踪应用的native代码</strong>，也可以命令行使用simpleperf。</p>
<h4 id="4、Trace-System-Calls"><a href="#4、Trace-System-Calls" class="headerlink" title="4、Trace System Calls"></a>4、Trace System Calls</h4><ul>
<li>检查<strong>应用与系统资源的交互情况</strong>。</li>
<li>查看所有<strong>核心的CPU瓶颈</strong>。</li>
<li><strong>内部采用systrace</strong>，也可以使用systrace命令。</li>
</ul>
<h3 id="2、Event-timeline"><a href="#2、Event-timeline" class="headerlink" title="2、Event timeline"></a>2、Event timeline</h3><p>用于显示<strong>应用程序在其生命周期中转换不同状态的活动</strong>，如用户交互、屏幕旋转事件等。</p>
<h3 id="3、CPU-timeline"><a href="#3、CPU-timeline" class="headerlink" title="3、CPU timeline"></a>3、CPU timeline</h3><p>用于显示应用程序 <strong>实时CPU使用率、其它进程实时CPU使用率、应用程序使用的线程总数</strong>。</p>
<h3 id="4、Thread-activity-timeline"><a href="#4、Thread-activity-timeline" class="headerlink" title="4、Thread activity timeline"></a>4、Thread activity timeline</h3><p><strong>列出应用程序进程中的每个线程</strong>，并<strong>使用了不同的颜色在其时间轴上指示其活动</strong>。</p>
<ul>
<li><strong>绿色</strong>：线程处于<strong>活动状态</strong>或<strong>准备好使用CPU</strong>。</li>
<li><strong>黄色</strong>：线程正<strong>等待IO</strong>操作。（重要）</li>
<li><strong>灰色</strong>：线程正在<strong>睡眠</strong>，<strong>不消耗CPU时间</strong>。</li>
</ul>
<h3 id="5、检查跟踪数据窗口"><a href="#5、检查跟踪数据窗口" class="headerlink" title="5、检查跟踪数据窗口"></a>5、检查跟踪数据窗口</h3><p>Profile提供的检查跟踪数据窗口有四种，如下所示：</p>
<h4 id="1、Call-Chart"><a href="#1、Call-Chart" class="headerlink" title="1、Call Chart"></a>1、Call Chart</h4><p>提供函数跟踪数据的图形表示形式。</p>
<ul>
<li><strong>水平轴</strong>：表示<strong>调用的时间段和时间</strong>。</li>
<li><strong>垂直轴</strong>：显示<strong>被调用方</strong>。</li>
<li><strong>橙色</strong>：<strong>系统API</strong>。</li>
<li><strong>绿色</strong>：<strong>应用自有方法</strong>。</li>
<li><strong>蓝色</strong>：<strong>第三方API</strong>（包括<strong>Java API</strong>）。</li>
</ul>
<h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>右键点击 Jump to source 跳转至指定函数。</p>
<h4 id="2、Flame-Chart"><a href="#2、Flame-Chart" class="headerlink" title="2、Flame Chart"></a>2、Flame Chart</h4><p><strong>将具有相同调用方顺序的完全相同的方法收集起来</strong>。</p>
<ul>
<li><strong>水平轴</strong>：<strong>执行每个方法的相对时间量</strong>。</li>
<li><strong>垂直轴</strong>：显示<strong>被调用方</strong>。</li>
</ul>
<h5 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h5><p>看<strong>顶层</strong>的<strong>哪个函数占据的宽度最大（表现为平顶）</strong>，可能<strong>存在性能问题</strong>。</p>
<h4 id="3、Top-Down"><a href="#3、Top-Down" class="headerlink" title="3、Top Down"></a>3、Top Down</h4><ul>
<li><strong>递归调用列表</strong>，提供<strong>self、children、total时间和比率来表示被调用的函数信息</strong>。</li>
<li><strong>Flame Chart是Top Down列表数据的图形化</strong>。</li>
</ul>
<h4 id="4、Bottom-Up"><a href="#4、Bottom-Up" class="headerlink" title="4、Bottom Up"></a>4、Bottom Up</h4><ul>
<li><strong>展开函数会显示其调用方</strong>。</li>
<li><strong>按照消耗CPU时间由多到少的顺序对函数排序</strong>。</li>
</ul>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>我们在查看上面4个跟踪数据的区域时，应该注意右侧的两个时间，如下所示：</p>
<ul>
<li><strong>Wall Clock Time</strong>：<strong>程序执行时间</strong>。</li>
<li><strong>Thread Time</strong>：<strong>CPU执行的时间</strong>。</li>
</ul>
<h3 id="3、TraceView小结"><a href="#3、TraceView小结" class="headerlink" title="3、TraceView小结"></a>3、TraceView小结</h3><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>1、<strong>图形的形式展示执行时间、调用栈</strong>等。</li>
<li>2、<strong>信息全面，包含所有线程</strong>。</li>
<li>3、<strong>运行时开销严重，整体都会变慢</strong>，得出的<strong>结果并不真实</strong>。</li>
<li>4、<strong>找到最耗费时间的路径：Flame Chart、Top Down</strong>。</li>
<li>5、<strong>找到最耗费时间的节点：Bottom Up</strong>。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>主要做热点分析，用来得到以下两种数据：</p>
<ul>
<li><strong>单次执行最耗时的方法</strong>。</li>
<li><strong>执行次数最多的方法</strong>。</li>
</ul>
<h2 id="6、启动速度分析工具-—-Systrace"><a href="#6、启动速度分析工具-—-Systrace" class="headerlink" title="6、启动速度分析工具 — Systrace"></a>6、启动速度分析工具 — Systrace</h2><h3 id="1、使用方式：代码插桩"><a href="#1、使用方式：代码插桩" class="headerlink" title="1、使用方式：代码插桩"></a>1、使用方式：代码插桩</h3><p>首先，我们可以定义一个Trace静态工厂类，将Trace.begainSection()，Trace.endSection()封装成i、o方法，然后再在想要分析的方法前后进行插桩即可。</p>
<p>然后，在命令行下执行systrace.py脚本，命令如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python <span class="regexp">/Users/</span>quchao<span class="regexp">/Library/</span>Android<span class="regexp">/sdk/</span>platform-tools<span class="regexp">/systrace/</span>systrace.py -t <span class="number">20</span> sched gfx view wm am app webview -a <span class="string">&quot;com.wanandroid.json.chao&quot;</span> -o ~<span class="regexp">/Documents/</span>open-<span class="keyword">project</span><span class="regexp">/systrace_data/</span>wanandroid_start_1.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体参数含义如下：</p>
<ul>
<li>-t：指定统计时间为20s。</li>
<li>shced：cpu调度信息。</li>
<li>gfx：图形信息。</li>
<li>view：视图。</li>
<li>wm：窗口管理。</li>
<li>am：活动管理。</li>
<li>app：应用信息。</li>
<li>webview：webview信息。</li>
<li>-a：指定目标应用程序的包名。</li>
<li>-o：生成的systrace.html文件。</li>
</ul>
<h4 id="如何查看数据？"><a href="#如何查看数据？" class="headerlink" title="如何查看数据？"></a>如何查看数据？</h4><p>在<strong>UIThread</strong>一栏可以看到<strong>核心的系统方法时间区域</strong>和我们自己使用<strong>代码插桩捕获的方法时间区域</strong>。</p>
<h3 id="2、Systrace原理"><a href="#2、Systrace原理" class="headerlink" title="2、Systrace原理"></a>2、Systrace原理</h3><ul>
<li>首先，<strong>在系统的一些关键链路（如SystemServcie、虚拟机、Binder驱动）插入一些信息（Label）</strong>。</li>
<li>然后，<strong>通过Label的开始和结束来确定某个核心过程的执行时间，并把这些Label信息收集起来得到系统关键路径的运行时间信息，最后得到整个系统的运行性能信息</strong>;</li>
</ul>
<p>其中，Android Framework 里面一些重要的模块都插入了label信息，用户App中也可以添加自定义的Lable。</p>
<h3 id="3、Systrace小结"><a href="#3、Systrace小结" class="headerlink" title="3、Systrace小结"></a>3、Systrace小结</h3><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li>结合<strong>Android内核的数据</strong>，生成<strong>Html</strong>报告。</li>
<li><strong>系统版本越高，Android Framework中添加的系统可用Label就越多，能够支持和分析的系统模块也就越多</strong>。</li>
<li><strong>必须手动缩小范围</strong>，会帮助你<strong>加速收敛问题的分析过程</strong>，进而<strong>快速地定位和解决问题</strong>。</li>
</ul>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>主要用于<strong>分析绘制性能方面的问题</strong>。</li>
<li>分析<strong>系统关键方法和应用方法耗时</strong>。</li>
</ul>
<h2 id="7、启动监控"><a href="#7、启动监控" class="headerlink" title="7、启动监控"></a>7、启动监控</h2><h3 id="1、实验室监控：视频录制"><a href="#1、实验室监控：视频录制" class="headerlink" title="1、实验室监控：视频录制"></a>1、实验室监控：视频录制</h3><ul>
<li>80%绘制</li>
<li>图像识别</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>覆盖高中低端机型不同的场景。</p>
<h3 id="2、线上监控"><a href="#2、线上监控" class="headerlink" title="2、线上监控"></a>2、线上监控</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>需要准确地统计启动耗时。</p>
<h4 id="1、启动结束的统计时机"><a href="#1、启动结束的统计时机" class="headerlink" title="1、启动结束的统计时机"></a>1、启动结束的统计时机</h4><p>是否是使用界面显示且用户真正可以操作的时间作为启动结束时间。</p>
<h4 id="2、启动时间扣除逻辑"><a href="#2、启动时间扣除逻辑" class="headerlink" title="2、启动时间扣除逻辑"></a>2、启动时间扣除逻辑</h4><p>闪屏、广告和新手引导这些时间都应该从启动时间里扣除。</p>
<h4 id="3、启动排除逻辑"><a href="#3、启动排除逻辑" class="headerlink" title="3、启动排除逻辑"></a>3、启动排除逻辑</h4><p>Broadcast、Server拉起，启动过程进入后台都需要排除统计。</p>
<h4 id="4、使用什么指标来衡量启动速度的快慢？"><a href="#4、使用什么指标来衡量启动速度的快慢？" class="headerlink" title="4、使用什么指标来衡量启动速度的快慢？"></a>4、使用什么指标来衡量启动速度的快慢？</h4><h5 id="平均启动时间的问题"><a href="#平均启动时间的问题" class="headerlink" title="平均启动时间的问题"></a>平均启动时间的问题</h5><p>一些体验很差的用户很可能被平均了。</p>
<h5 id="建议的指标"><a href="#建议的指标" class="headerlink" title="建议的指标"></a>建议的指标</h5><ul>
<li>1、快开慢开比</li>
</ul>
<p>如2s快开比，5s慢开比，可以看到<strong>有多少比例的用户体验好，多少比例的用户比较糟糕</strong>。</p>
<ul>
<li>2、90%用户的启动时间</li>
</ul>
<p>如果90%用户的启动时间都小于5s，那么90%区间的启动耗时就是5s。</p>
<h4 id="5、启动的类型有哪几种？"><a href="#5、启动的类型有哪几种？" class="headerlink" title="5、启动的类型有哪几种？"></a>5、启动的类型有哪几种？</h4><ul>
<li>首次安装启动</li>
<li>覆盖安装启动</li>
<li>冷启动（指标）</li>
<li>热启动（反映程序的活跃或保活能力）</li>
</ul>
<p>借鉴Facebook的 <a href="https://link.juejin.cn/?target=https://github.com/facebookincubator/profilo">profilo</a> 工具原理，对启动整个流程进行耗时监控，在后台对不同的版本做自动化对比，监控新版本是否有新增耗时的函数。</p>
<h1 id="四、启动优化常规方案"><a href="#四、启动优化常规方案" class="headerlink" title="四、启动优化常规方案"></a>四、启动优化常规方案</h1><h3 id="启动过程中的常见问题"><a href="#启动过程中的常见问题" class="headerlink" title="启动过程中的常见问题"></a>启动过程中的常见问题</h3><ul>
<li>1、<strong>点击图标很久都不响应</strong>：预览窗口被禁用或设置为透明。</li>
<li>2、<strong>首页显示太慢</strong>：初始化任务太多。</li>
<li>3、<strong>首页显示后无法进行操作</strong>：太多延迟初始化任务占用主线程CPU时间片。</li>
</ul>
<h3 id="优化区域"><a href="#优化区域" class="headerlink" title="优化区域"></a>优化区域</h3><p>Application、Activity创建以及回调等过程。</p>
<h2 id="1、主题切换"><a href="#1、主题切换" class="headerlink" title="1、主题切换"></a>1、主题切换</h2><p>使用Activity的windowBackground主题属性预先设置一个启动图片（layer-list实现），在启动后，在Activity的onCreate()方法中的super.onCreate()前再setTheme(R.style.AppTheme)。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>使用<strong>简单</strong>。</li>
<li><strong>避免了启动白屏和点击启动图标不响应的情况</strong>。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>治标不治本</strong>，表面上产生一种快的感觉。</li>
<li><strong>对于中低端机，总的闪屏时间会更长，建议只在Android6.0&#x2F;7.0以上才启用“预览闪屏”方案，让手机性能好的用户可以有更好的体验</strong>。</li>
</ul>
<h2 id="2、第三方库懒加载"><a href="#2、第三方库懒加载" class="headerlink" title="2、第三方库懒加载"></a>2、第三方库懒加载</h2><p>按需初始化，特别是<strong>针对于一些应用启动时不需要初始化的库</strong>，可以等到用时才进行加载。</p>
<h2 id="3、异步初始化预备知识-线程优化"><a href="#3、异步初始化预备知识-线程优化" class="headerlink" title="3、异步初始化预备知识-线程优化"></a>3、异步初始化预备知识-线程优化</h2><h3 id="1、Android线程调度原理剖析"><a href="#1、Android线程调度原理剖析" class="headerlink" title="1、Android线程调度原理剖析"></a>1、Android线程调度原理剖析</h3><h4 id="线程调度原理"><a href="#线程调度原理" class="headerlink" title="线程调度原理"></a>线程调度原理</h4><ul>
<li>1、任意时刻，<strong>只有一个线程占用CPU，处于运行状态</strong>。</li>
<li>2、多线程并发，轮流获取CPU使用权。</li>
<li>3、JVM负责线程调度，按照特定机制分配CPU使用权。</li>
</ul>
<h4 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h4><h5 id="1、分时调度模型"><a href="#1、分时调度模型" class="headerlink" title="1、分时调度模型"></a>1、分时调度模型</h5><p>轮流获取、均分CPU。</p>
<h5 id="2、抢占式调度模型"><a href="#2、抢占式调度模型" class="headerlink" title="2、抢占式调度模型"></a>2、抢占式调度模型</h5><p>优先级高的获取。</p>
<h4 id="如何干预线程调度？"><a href="#如何干预线程调度？" class="headerlink" title="如何干预线程调度？"></a>如何干预线程调度？</h4><p>设置线程优先级。</p>
<h4 id="Android线程调度"><a href="#Android线程调度" class="headerlink" title="Android线程调度"></a>Android线程调度</h4><h5 id="1、nice值"><a href="#1、nice值" class="headerlink" title="1、nice值"></a>1、nice值</h5><ul>
<li>Process中定义。</li>
<li>值越小，优先级越高。</li>
<li>默认是THREAD_PRIORITY_DEFAUT，0。</li>
</ul>
<h5 id="2、cgroup"><a href="#2、cgroup" class="headerlink" title="2、cgroup"></a>2、cgroup</h5><p>它是一种更严格的群组调度策略，主要分为如下两种类型：</p>
<ul>
<li>后台group（默认）。</li>
<li>前台group，保证前台线程可以获取到更多的CPU</li>
</ul>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li><strong>线程过多会导致CPU频繁切换，降低线程运行效率</strong>。</li>
<li><strong>正确认识任务重要性以决定使用哪种线程优先级</strong>。</li>
<li>优先级具有继承性。</li>
</ul>
<h3 id="2、Android异步方式"><a href="#2、Android异步方式" class="headerlink" title="2、Android异步方式"></a>2、Android异步方式</h3><h4 id="1、Thread"><a href="#1、Thread" class="headerlink" title="1、Thread"></a>1、Thread</h4><ul>
<li>最简单、常见的异步方式。</li>
<li>不易复用，频繁创建及销毁开销大。</li>
<li>复杂场景不易使用。</li>
</ul>
<h4 id="2、HandlerThread"><a href="#2、HandlerThread" class="headerlink" title="2、HandlerThread"></a>2、HandlerThread</h4><ul>
<li>自带消息循环的线程。</li>
<li>串行执行。</li>
<li>长时间运行，不断从队列中获取任务。</li>
</ul>
<h4 id="3、IntentService"><a href="#3、IntentService" class="headerlink" title="3、IntentService"></a>3、IntentService</h4><ul>
<li>继承自Service在内部创建HandlerThread。</li>
<li>异步，不占用主线程。</li>
<li>优先级较高，不易被系统Kill。</li>
</ul>
<h4 id="4、AsyncTask"><a href="#4、AsyncTask" class="headerlink" title="4、AsyncTask"></a>4、AsyncTask</h4><ul>
<li>Android提供的工具类。</li>
<li>无需自己处理线程切换。</li>
<li>需注意版本不一致问题（API 14以上解决）</li>
</ul>
<h4 id="5、线程池"><a href="#5、线程池" class="headerlink" title="5、线程池"></a>5、线程池</h4><ul>
<li>Java提供的线程池。</li>
<li>易复用，减少频繁创建、销毁的时间。</li>
<li>功能强大，如定时、任务队列、并发数控制等。</li>
</ul>
<h4 id="6、RxJava"><a href="#6、RxJava" class="headerlink" title="6、RxJava"></a>6、RxJava</h4><p>由强大的调度器Scheduler集合提供。</p>
<p>不同类型的Scheduler：</p>
<ul>
<li>IO</li>
<li>Computation</li>
</ul>
<h4 id="异步方式总结"><a href="#异步方式总结" class="headerlink" title="异步方式总结"></a>异步方式总结</h4><ul>
<li>推荐度：从后往前排列。</li>
<li>正确场景选择正确的方式。</li>
</ul>
<h3 id="3、Android线程优化实战"><a href="#3、Android线程优化实战" class="headerlink" title="3、Android线程优化实战"></a>3、Android线程优化实战</h3><h4 id="线程使用准则"><a href="#线程使用准则" class="headerlink" title="线程使用准则"></a>线程使用准则</h4><ul>
<li>1、<strong>严禁使用new Thread方式</strong>。</li>
<li>2、提供<strong>基础线程池</strong>供各个业务线使用，避免各个业务线各自维护一套线程池，导致线程数过多。</li>
<li>3、<strong>根据任务类型选择合适的异步方式</strong>：优先级低，长时间执行，HandlerThread；定时执行耗时任务，线程池。</li>
<li>4、创建线程必须<strong>命名</strong>，以方便<strong>定位线程归属</strong>，在运行期 <strong>Thread.currentThread().setName</strong> 修改名字。</li>
<li>5、关键异步任务监控，注意<strong>异步不等于不耗时</strong>，建议使用<strong>AOP</strong>的方式来做<strong>监控</strong>。</li>
<li>6、<strong>重视优先级设置（根据任务具体情况），Process.setThreadPriority() 可以设置多次</strong>。</li>
</ul>
<h3 id="4、如何锁定线程创建者"><a href="#4、如何锁定线程创建者" class="headerlink" title="4、如何锁定线程创建者"></a>4、如何锁定线程创建者</h3><h4 id="锁定线程创建背景"><a href="#锁定线程创建背景" class="headerlink" title="锁定线程创建背景"></a>锁定线程创建背景</h4><ul>
<li>项目变大之后收敛线程。</li>
<li>项目源码、三方库、aar中都有线程的创建。</li>
</ul>
<h4 id="锁定线程创建方案"><a href="#锁定线程创建方案" class="headerlink" title="锁定线程创建方案"></a>锁定线程创建方案</h4><p>特别适合Hook手段，<strong>找Hook点：构造函数或者特定方法，如Thread的构造函数。</strong></p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>这里我们直接使用维数的 <a href="https://link.juejin.cn/?target=https://github.com/tiann/epic">epic</a> 对Thread进行Hook。在attachBaseContext中调用DexposedBridge.hookAllConstructors方法即可，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">DexposedBridge</span>.</span></span>hook<span class="constructor">AllConstructors(Thread.<span class="params">class</span>, <span class="params">new</span> XC_MethodHook()</span> &#123; </span><br><span class="line">    @Override protected void afterHookedMethod（MethodHookParam param）throws Throwable &#123;                         </span><br><span class="line">        super.after<span class="constructor">HookedMethod(<span class="params">param</span>)</span>; </span><br><span class="line">        Thread thread = (Thread) param.thisObject; </span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">LogUtils</span>.</span></span>i(<span class="string">&quot;stack &quot;</span> + <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>get<span class="constructor">StackTraceString(<span class="params">new</span> Throwable()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从log找到线程创建信息，根据堆栈信息跟相关业务方沟通解决方案。</p>
<h3 id="5、线程收敛优雅实践初步"><a href="#5、线程收敛优雅实践初步" class="headerlink" title="5、线程收敛优雅实践初步"></a>5、线程收敛优雅实践初步</h3><h4 id="线程收敛常规方案"><a href="#线程收敛常规方案" class="headerlink" title="线程收敛常规方案"></a>线程收敛常规方案</h4><ul>
<li>根据线程创建堆栈考量合理性，使用同一线程库。</li>
<li>各业务线下掉自己的线程库。</li>
</ul>
<h4 id="问题：基础库怎么使用线程？"><a href="#问题：基础库怎么使用线程？" class="headerlink" title="问题：基础库怎么使用线程？"></a>问题：基础库怎么使用线程？</h4><p>直接依赖线程库，但问题在于<strong>线程库更新可能会导致基础库更新</strong>。</p>
<h4 id="基础库优雅使用线程"><a href="#基础库优雅使用线程" class="headerlink" title="基础库优雅使用线程"></a>基础库优雅使用线程</h4><ul>
<li><strong>基础库内部暴露API：setExecutor</strong>。</li>
<li><strong>初始化的时候注入统一的线程库</strong>。</li>
</ul>
<h4 id="统一线程库时区分任务类型"><a href="#统一线程库时区分任务类型" class="headerlink" title="统一线程库时区分任务类型"></a>统一线程库时区分任务类型</h4><ul>
<li><strong>IO密集型任务</strong>：IO密集型任务不消耗CPU，核心池可以很大。常见的IO密集型任务如文件读取、写入，网络请求等等。</li>
<li><strong>CPU密集型任务</strong>：核心池大小和CPU核心数相关。常见的CPU密集型任务如比较复杂的计算操作，此时需要使用大量的CPU计算单元。</li>
</ul>
<h4 id="实现用于执行多类型任务的基础线程池组件"><a href="#实现用于执行多类型任务的基础线程池组件" class="headerlink" title="实现用于执行多类型任务的基础线程池组件"></a>实现用于执行多类型任务的基础线程池组件</h4><p>目前基础线程池组件位于启动器sdk之中，使用非常简单，示例代码如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前执行的任务是CPU密集型任务，则从基础线程池组件</span></span><br><span class="line"><span class="comment">// DispatcherExecutor中获取到用于执行 CPU 密集型任务的线程池</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">DispatcherExecutor</span>.</span></span>get<span class="constructor">CPUExecutor()</span>.execute(<span class="constructor">YourRunable()</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前执行的任务是IO密集型任务，则从基础线程池组件</span></span><br><span class="line"><span class="comment">// DispatcherExecutor中获取到用于执行 IO 密集型任务的线程池</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">DispatcherExecutor</span>.</span></span>get<span class="constructor">IOExecutor()</span>.execute(<span class="constructor">YourRunable()</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的实现源码也比较简单，并且我对每一处代码都进行了详细的解释，就不一一具体分析了。代码如下所示：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CPU 密集型任务的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor sCPUThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IO 密集型任务的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService sIOThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前设备可以使用的 CPU 核数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池核心线程数，其数量在2 ~ 5这个区域内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> CORE_POOL_SIZE = Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池线程数的最大值：这里指定为了核心线程数的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MAXIMUM_POOL_SIZE = CORE_POOL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 线程池中空闲线程等待工作的超时时间，当线程池中</span></span><br><span class="line"><span class="comment">    * 线程数量大于corePoolSize（核心线程数量）或</span></span><br><span class="line"><span class="comment">    * 设置了allowCoreThreadTimeOut（是否允许空闲核心线程超时）时，</span></span><br><span class="line"><span class="comment">    * 线程会根据keepAliveTime的值进行活性检查，一旦超时便销毁线程。</span></span><br><span class="line"><span class="comment">    * 否则，线程会永远等待新的工作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> KEEP_ALIVE_SECONDS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个基于链表节点的阻塞队列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; S_POOL_WORK_QUEUE = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建线程的线程工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultThreadFactory S_THREAD_FACTORY = <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池执行耗时任务时发生异常所需要做的拒绝执行处理</span></span><br><span class="line"><span class="comment">     * 注意：一般不会执行到这里</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler S_HANDLER = <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">            Executors.newCachedThreadPool().execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取CPU线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return CPU线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolExecutor getCPUExecutor() &#123;</span><br><span class="line">        <span class="keyword">return</span> sCPUThreadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取IO线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return IO线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService getIOExecutor() &#123;</span><br><span class="line">        <span class="keyword">return</span> sIOThreadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现一个默认的线程工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_ inherited__">ThreadFactory</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger POOL_NUMBER = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup <span class="keyword">group</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">group</span> = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                    Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;TaskDispatcherPool-&quot;</span> +</span><br><span class="line">                    POOL_NUMBER.getAndIncrement() +</span><br><span class="line">                    <span class="string">&quot;-Thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> Thread newThread(Runnable r) &#123;</span><br><span class="line">            <span class="comment">// 每一个新创建的线程都会分配到线程组group当中</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">group</span>, r,</span><br><span class="line">                    namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                    <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon()) &#123;</span><br><span class="line">                <span class="comment">// 非守护线程</span></span><br><span class="line">                t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置线程优先级</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY) &#123;</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        sCPUThreadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">                S_POOL_WORK_QUEUE, S_THREAD_FACTORY, S_HANDLER);</span><br><span class="line">        <span class="comment">// 设置是否允许空闲核心线程超时时，线程会根据keepAliveTime的值进行活性检查，一旦超时便销毁线程。否则，线程会永远等待新的工作。</span></span><br><span class="line">        sCPUThreadPoolExecutor.allowCoreThreadTimeOut(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// IO密集型任务线程池直接采用CachedThreadPool来实现，</span></span><br><span class="line">        <span class="comment">// 它最多可以分配Integer.MAX_VALUE个非核心线程用来执行任务</span></span><br><span class="line">        sIOThreadPoolExecutor = Executors.newCachedThreadPool(S_THREAD_FACTORY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6、线程优化核心问题"><a href="#6、线程优化核心问题" class="headerlink" title="6、线程优化核心问题"></a>6、线程优化核心问题</h3><h4 id="1、线程使用为什么会遇到问题？"><a href="#1、线程使用为什么会遇到问题？" class="headerlink" title="1、线程使用为什么会遇到问题？"></a>1、线程使用为什么会遇到问题？</h4><p>项目发展阶段忽视基础设施建设，没有采用统一的线程池，导致线程数量过多。</p>
<h5 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h5><p>异步任务执行太耗时，导致主线程卡顿。</p>
<h5 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h5><ul>
<li><strong>1、Java线程调度是抢占式的，线程优先级比较重要，需要区分</strong>。</li>
<li><strong>2、没有区分IO和CPU密集型任务，导致主线程抢不到CPU</strong>。</li>
</ul>
<h4 id="2、怎么在项目中对线程进行优化？"><a href="#2、怎么在项目中对线程进行优化？" class="headerlink" title="2、怎么在项目中对线程进行优化？"></a>2、怎么在项目中对线程进行优化？</h4><h5 id="核心：线程收敛"><a href="#核心：线程收敛" class="headerlink" title="核心：线程收敛"></a>核心：线程收敛</h5><ul>
<li><strong>通过Hook方式找到对应线程的堆栈信息，和业务方讨论是否应该单独起一个线程，尽可能使用统一线程池</strong>。</li>
<li><strong>每个基础库都暴露一个设置线程池的方法，以避免线程库更新导致基础库需要更新的问题</strong>。</li>
<li><strong>统一线程池应注意IO、CPU密集型任务区分</strong>。</li>
<li>其它细节：<strong>重要异步任务统计耗时、注重异步任务优先级和线程名的设置</strong>。</li>
</ul>
<h2 id="4、异步初始化"><a href="#4、异步初始化" class="headerlink" title="4、异步初始化"></a>4、异步初始化</h2><h3 id="1、核心思想"><a href="#1、核心思想" class="headerlink" title="1、核心思想"></a>1、核心思想</h3><p>子线程分担主线程任务，并行减少时间。</p>
<h3 id="2、异步优化注意点"><a href="#2、异步优化注意点" class="headerlink" title="2、异步优化注意点"></a>2、异步优化注意点</h3><ul>
<li>1、<strong>不符合异步要求</strong>。</li>
<li>2、<strong>需要在某个阶段完成（采用CountDownLatch确保异步任务完成后才到下一个阶段）</strong>。</li>
<li>3、<strong>如出现主线程要使用时还没初始化则在此次使用前初始化</strong>。</li>
<li>4、<strong>区分CPU密集型和IO密集型任务</strong>。</li>
</ul>
<h3 id="3、异步初始化方案演进"><a href="#3、异步初始化方案演进" class="headerlink" title="3、异步初始化方案演进"></a>3、异步初始化方案演进</h3><ul>
<li>1、new Thread</li>
<li>2、IntentService</li>
<li>3、线程池（合理配置并选择CPU密集型和IO密集型线程池）</li>
<li>4、异步启动器</li>
</ul>
<h3 id="4、异步优化最优解：异步启动器"><a href="#4、异步优化最优解：异步启动器" class="headerlink" title="4、异步优化最优解：异步启动器"></a>4、异步优化最优解：异步启动器</h3><p><a href="https://link.juejin.cn/?target=https://github.com/zeshaoaaa/LaunchStarter">异步启动器源码及使用demo地址</a></p>
<h4 id="常规异步优化痛点"><a href="#常规异步优化痛点" class="headerlink" title="常规异步优化痛点"></a>常规异步优化痛点</h4><ul>
<li>1、代码不优雅：例如使用线程池实现多个并行异步任务时会有多个executorService.submit代码块。</li>
<li>2、场景不好处理：各个初始化任务之间存在依赖关系，例如推送sdk的初始化任务需要依赖于获取设备id的初始化任务。此外，有些任务是需要在某些特定的时候就初始化完成，例如需要在Application的onCreate方法执行完之前就初始化完成。</li>
<li>3、维护成本高。</li>
</ul>
<h4 id="启动器核心思想"><a href="#启动器核心思想" class="headerlink" title="启动器核心思想"></a>启动器核心思想</h4><p><strong>充分</strong>利用CPU多核，<strong>自动</strong>梳理任务顺序。</p>
<h4 id="启动器流程"><a href="#启动器流程" class="headerlink" title="启动器流程"></a>启动器流程</h4><p>启动器的流程图如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f1b02f4b9c471f9d0bfc7315b5f741~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<p>启动器的主题流程为上图中的中间区域，即<strong>主线程与并发两个区域块</strong>。需要注意的是，在上图中的 <strong>head task与tail task</strong> 并不包含在启动器的主题流程中，它仅仅是用于<strong>处理启动前&#x2F;启动后的一些通用任务</strong>，例如我们可以在head task中做一些获取通用信息的操作，在tail task可以做一些log输出、数据上报等操作。</p>
<p>那么，这里我们总结一下启动的核心流程，如下所示：</p>
<ul>
<li>1、<strong>任务Task化，启动逻辑抽象成Task</strong>（Task即对应一个个的初始化任务）。</li>
<li>2、<strong>根据所有任务依赖关系排序生成一个有向无环图</strong>：例如上述说到的推送SDK初始化任务需要依赖于获取设备id的初始化任务，各个任务之间都可能存在依赖关系，所以将它们的依赖关系排序生成一个有向无环图能将<strong>并行效率最大化</strong>。</li>
<li>3、<strong>多线程按照排序后的优先级依次执行</strong>：例如必须先初始化获取设备id的初始化任务，才能去进行推送SDK的初始化任务。</li>
</ul>
<h4 id="异步启动器优化实战与源码剖析"><a href="#异步启动器优化实战与源码剖析" class="headerlink" title="异步启动器优化实战与源码剖析"></a>异步启动器优化实战与源码剖析</h4><p>下面，我们就来使用异步启动器来在Application的onCreate方法中进行异步优化，代码如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、启动器初始化</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">TaskDispatcher</span>.</span></span>init(this);</span><br><span class="line"><span class="comment">// 2、创建启动器实例，这里每次获取的都是新对象</span></span><br><span class="line">TaskDispatcher dispatcher = <span class="module-access"><span class="module"><span class="identifier">TaskDispatcher</span>.</span></span>create<span class="constructor">Instance()</span>;</span><br><span class="line"><span class="comment">// 3、给启动器配置一系列的（异步/非异步）初始化任务并启动启动器</span></span><br><span class="line">dispatcher</span><br><span class="line">        .add<span class="constructor">Task(<span class="params">new</span> InitAMapTask()</span>)</span><br><span class="line">        .add<span class="constructor">Task(<span class="params">new</span> InitStethoTask()</span>)</span><br><span class="line">        .add<span class="constructor">Task(<span class="params">new</span> InitWeexTask()</span>)</span><br><span class="line">        .add<span class="constructor">Task(<span class="params">new</span> InitBuglyTask()</span>)</span><br><span class="line">        .add<span class="constructor">Task(<span class="params">new</span> InitFrescoTask()</span>)</span><br><span class="line">        .add<span class="constructor">Task(<span class="params">new</span> InitJPushTask()</span>)</span><br><span class="line">        .add<span class="constructor">Task(<span class="params">new</span> InitUmengTask()</span>)</span><br><span class="line">        .add<span class="constructor">Task(<span class="params">new</span> GetDeviceIdTask()</span>)</span><br><span class="line">        .start<span class="literal">()</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 4、需要等待微信SDK初始化完成，程序才能往下执行</span></span><br><span class="line">dispatcher.await<span class="literal">()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的 <strong>TaskDispatcher</strong> 就是我们的<strong>启动器调用类</strong>。首先，在注释1处，我们需要先调用TaskDispatcher的init方法进行启动器的初始化，其源码如下所示：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void init(<span class="built_in">Context</span> <span class="built_in">context</span>) &#123;</span><br><span class="line">    if (<span class="built_in">context</span> != null) &#123;</span><br><span class="line">        <span class="keyword">sContext </span>= <span class="built_in">context</span>;</span><br><span class="line">        <span class="keyword">sHasInit </span>= true;</span><br><span class="line">        sIsMainProcess = Utils.isMainProcess(<span class="keyword">sContext);</span></span><br><span class="line"><span class="keyword"></span>    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，仅仅是初始化了几个基础字段。接着，在注释2处，我们创建了启动器实例，其源码如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：这里我们每次获取的都是新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TaskDispatcher <span class="title">createInstance</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sHasInit) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;must call TaskDispatcher.init    first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在createInstance方法的中我们每次都会创建一个新的TaskDispatcher实例。然后，在注释3处，我们给启动器配置了一系列的初始化任务并启动启动器，需要注意的是，<strong>这里的Task既可以是用于执行异步任务（子线程）的也可以是用于执行非异步任务（主线程）</strong>。下面，我们来分析下这两种Task的用法，比如InitStethoTask这个异步任务的初始化，代码如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步的Task</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InitStethoTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="type">Stetho</span>.initializeWithDefaults(mContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的InitStethoTask直接继承自Task，Task中的runOnMainThread方法返回为false，说明 <strong>task</strong> 是用于<strong>处理异步任务的task</strong>，其中的run方法就是Runnable的run方法。下面，我们再看看另一个用于初始化非异步任务的例子，例如用于微信SDK初始化的InitWeexTask，代码如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 主线程执行的task</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InitWeexTask</span> <span class="keyword">extends</span> <span class="title">MainTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public boolean needWait() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="type">InitConfig</span> config = <span class="keyword">new</span> <span class="type">InitConfig</span>.<span class="type">Builder</span>().build();</span><br><span class="line">        <span class="type">WXSDKEngine</span>.initialize((<span class="type">Application</span>) mContext, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，它直接继承了MainTask，MainTask的源码如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public boolean runOnMainThread() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>MainTask</strong> 直接继承了Task，并仅仅是重写了runOnMainThread方法返回了true，说明它就是用来<strong>初始化主线程中的非异步任务的</strong>。</p>
<p>此外，我们注意到InitWeexTask中还重写了一个needWait方法并返回了true，<strong>其目的是为了在某个时刻之前必须等待InitWeexTask初始化完成程序才能继续往下执行</strong>，这里的某个时刻指的就是我们在Application的onCreate方法中的注释4处的代码所执行的地方：dispatcher.await()，其实现源码如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要等待的任务数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger mNeedWaitCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用了 await 还没结束且需要等待的任务列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Task&gt; mNeedWaitTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CountDownLatch mCountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="built_in">int</span> WAITTIME = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">@UiThread</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、仅仅在测试阶段才输出需等待的任务列表数与任务名称</span></span><br><span class="line">        <span class="keyword">if</span> (DispatcherLog.isDebug()) &#123;</span><br><span class="line">            DispatcherLog.i(<span class="string">&quot;still has &quot;</span> + mNeedWaitCount.<span class="keyword">get</span>());</span><br><span class="line">            <span class="keyword">for</span> (Task task : mNeedWaitTasks) &#123;</span><br><span class="line">                DispatcherLog.i(<span class="string">&quot;needWait: &quot;</span> + task.getClass().getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、只要还有需要等待的任务没有执行完成，就调用mCountDownLatch的await方法进行等待，这里我们设定超时时间为10s</span></span><br><span class="line">        <span class="keyword">if</span> (mNeedWaitCount.<span class="keyword">get</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCountDownLatch == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;You have to call start() before call await()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mCountDownLatch.<span class="keyword">await</span>(WAITTIME, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，在注释1处，我们仅仅只会在测试阶段才会输出需等待的任务列表数与任务名称。然后，在注释2处，只要需要等待的任务数mNeedWaitCount大于0，即只要还有需要等待的任务没有执行完成，就调用mCountDownLatch的await方法进行等待，注意我们这里设定了超时时间为10s。当一个<strong>task执行完成后</strong>，无论它是异步还是非异步的，最终都会执行到<strong>mTaskDispatcher的markTaskDone(mTask)方法</strong>，我们看看它的实现源码，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 已经结束的Task</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;<span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="keyword">Task</span>&gt;&gt; mFinishedTasks = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> markTaskDone(<span class="keyword">Task</span> <span class="keyword">task</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ifNeedWait(<span class="keyword">task</span>)) &#123;</span><br><span class="line">        mFinishedTasks.add(<span class="keyword">task</span>.getClass());</span><br><span class="line">        mNeedWaitTasks.remove(<span class="keyword">task</span>);</span><br><span class="line">        mCountDownLatch.countDown();</span><br><span class="line">        mNeedWaitCount.getAndDecrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，这里每执行完成一个task，就会将mCountDownLatch的锁计数减1，与此同时，也会将我们的mNeedWaitCount这个原子整数包装类的数量减1。</p>
<p>此外，我们在前面说到了启动器将各个任务之间的依赖关系抽象成了一个有向无环图，在上面一系列的初始化代码中，InitJPushTask是需要依赖于GetDeviceIdTask的，<strong>那么，我们怎么告诉启动器它们两者之间的依赖关系呢</strong>？</p>
<p>这里只需要在InitJPushTask中<strong>重写dependsOn()方法，并返回包含GetDeviceIdTask的task列表即可</strong>，代码如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* InitJPushTask 需要在 getDeviceId 之后执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> InitJPushTask <span class="keyword">extends</span> <span class="keyword">Task</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="keyword">Task</span>&gt;&gt; dependsOn() &#123;</span><br><span class="line">        List&lt;<span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="keyword">Task</span>&gt;&gt; <span class="keyword">task</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">task</span>.add(GetDeviceIdTask.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">task</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        JPushInterface.init(mContext);</span><br><span class="line">        MyApplication app = (MyApplication) mContext;</span><br><span class="line">        JPushInterface.setAlias(mContext, <span class="number">0</span>, app.getDeviceId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此，我们的异步启动器就分析完毕了。下面我们来看看如何高效地进行延迟初始化。</p>
<h2 id="5、延迟初始化"><a href="#5、延迟初始化" class="headerlink" title="5、延迟初始化"></a>5、延迟初始化</h2><h3 id="1、常规方案：利用闪屏页的停留时间进行部分初始化"><a href="#1、常规方案：利用闪屏页的停留时间进行部分初始化" class="headerlink" title="1、常规方案：利用闪屏页的停留时间进行部分初始化"></a>1、常规方案：利用闪屏页的停留时间进行部分初始化</h3><ul>
<li>new Handler().postDelayed()。</li>
<li>界面UI展示后调用。</li>
</ul>
<h3 id="2、常规初始化痛点"><a href="#2、常规初始化痛点" class="headerlink" title="2、常规初始化痛点"></a>2、常规初始化痛点</h3><ul>
<li><strong>时机不容易控制</strong>：handler postDelayed指定的延迟时间不好估计。</li>
<li><strong>导致界面UI卡顿</strong>：此时用户可能还在滑动列表。</li>
</ul>
<h3 id="3、延迟优化最优解：延迟启动器"><a href="#3、延迟优化最优解：延迟启动器" class="headerlink" title="3、延迟优化最优解：延迟启动器"></a>3、延迟优化最优解：延迟启动器</h3><p><a href="https://link.juejin.cn/?target=https://github.com/zeshaoaaa/LaunchStarter">延迟启动器源码及使用demo地址</a></p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>利用IdleHandler特性，<strong>在CPU空闲时执行，对延迟任务进行分批初始化</strong>。</p>
<h4 id="延迟启动器优化实战与源码剖析"><a href="#延迟启动器优化实战与源码剖析" class="headerlink" title="延迟启动器优化实战与源码剖析"></a>延迟启动器优化实战与源码剖析</h4><p>延迟初始化启动器的代码很简单，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟初始化分发器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DelayInitDispatcher &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;<span class="keyword">Task</span>&gt; mDelayTasks = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueue.IdleHandler mIdleHandler = <span class="keyword">new</span>     MessageQueue.IdleHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> queueIdle() &#123;</span><br><span class="line">            <span class="comment">// 分批执行的好处在于每一个task占用主线程的时间相对</span></span><br><span class="line">            <span class="comment">// 来说很短暂，并且此时CPU是空闲的，这些能更有效地避免UI卡顿</span></span><br><span class="line">            <span class="keyword">if</span>(mDelayTasks.<span class="keyword">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">Task</span> <span class="keyword">task</span> = mDelayTasks.poll();</span><br><span class="line">                <span class="keyword">new</span> DispatchRunnable(<span class="keyword">task</span>).run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> !mDelayTasks.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DelayInitDispatcher addTask(<span class="keyword">Task</span> <span class="keyword">task</span>)&#123;</span><br><span class="line">        mDelayTasks.add(<span class="keyword">task</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> start()&#123;</span><br><span class="line">        Looper.myQueue().addIdleHandler(mIdleHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在DelayInitDispatcher中，我们提供了mDelayTasks队列用于将每一个task添加进来，使用者只需调用addTask方法即可。<strong>当CPU空闲时，mIdleHandler便会回调自身的queueIdle方法，这个时候我们可以将task一个一个地拿出来并执行</strong>。这种分批执行的好处在于每一个task占用主线程的时间相对来说很短暂，并且此时CPU是空闲的，这样能更有效地避免UI卡顿，真正地提升用户的体验。</p>
<p>至于使用就非常简单了，我们可以直接利用SplashActivity的广告页停留时间去进行延迟初始化，代码如下所示：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public <span class="literal">void</span> onWindowFocusChanged(boolean hasFocus) &#123;</span><br><span class="line">    super.onWindowFocusChanged(hasFocus);</span><br><span class="line">    GlobalHandler.getInstance<span class="function"><span class="params">()</span>.<span class="title">getHandler</span><span class="params">()</span>.<span class="title">post</span><span class="params">((Runnable) () -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (hasFocus) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            DelayInitDispatcher delayInitDispatcher = <span class="keyword">new</span> DelayInitDispatcher();</span></span></span><br><span class="line"><span class="params"><span class="function">            delayInitDispatcher.addTask(<span class="keyword">new</span> InitOtherTask())</span></span></span><br><span class="line"><span class="params"><span class="function">                    .start();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>能异步的task我们会优先使用异步启动器在Application的onCreate方法中加载（或者是必须在Application的onCreate方法完成前必须执行完的非异task务），对于不能异步的task，我们可以利用延迟启动器进行加载。如果任务可以到用时再加载，可以使用懒加载的方式</strong>。</p>
<h4 id="延迟启动器优势"><a href="#延迟启动器优势" class="headerlink" title="延迟启动器优势"></a>延迟启动器优势</h4><ul>
<li>执行时机明确。</li>
<li>缓解界面UI卡顿。</li>
<li>真正提升用户体验。</li>
</ul>
<h2 id="6、Multidex预加载优化"><a href="#6、Multidex预加载优化" class="headerlink" title="6、Multidex预加载优化"></a>6、Multidex预加载优化</h2><p>我们都知道，安装或者升级后首次 MultiDex 花费的时间过于漫长，我们需要进行Multidex的预加载优化。</p>
<h3 id="1、优化步骤"><a href="#1、优化步骤" class="headerlink" title="1、优化步骤"></a>1、优化步骤</h3><ul>
<li>1、启动时单独开一个进程去异步进行Multidex的第一次加载，即Dex提取和Dexopt操作。</li>
<li>2、此时，主进程Application进入while循环，不断检测Multidex操作是否完成。</li>
<li>3、执行到Multidex时，则已经发现提取并优化好了Dex，直接执行。MultiDex执行完之后主进程Application继续执行ContentProvider初始化和Application的onCreate方法。</li>
</ul>
<p><a href="https://link.juejin.cn/?target=https://github.com/lanshifu/MultiDexTest">Multidex优化Demo地址</a></p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>5.0以上默认使用ART，在安装时已将Class.dex转换为oat文件了，无需优化，所以应判断只有在主进程及SDK 5.0以下才进行Multidex的预加载。</p>
<h3 id="2、dex-opt过程是怎样的？"><a href="#2、dex-opt过程是怎样的？" class="headerlink" title="2、dex-opt过程是怎样的？"></a>2、dex-opt过程是怎样的？</h3><p>主要包括inline以及quick指令的优化。</p>
<h4 id="那么，inline是什么？"><a href="#那么，inline是什么？" class="headerlink" title="那么，inline是什么？"></a>那么，inline是什么？</h4><p>使编译器在函数调用处用函数体代码代替函数调用指令。</p>
<h4 id="inline的作用？"><a href="#inline的作用？" class="headerlink" title="inline的作用？"></a>inline的作用？</h4><p>函数调用的转移操作有一定的时间和空间方面的开销，特别是对于一些函数体不大且频繁调用的函数，解决其效率问题更为重要，引入inline函数就是为了解决这一问题。</p>
<h4 id="inline又是如何进行优化的？"><a href="#inline又是如何进行优化的？" class="headerlink" title="inline又是如何进行优化的？"></a>inline又是如何进行优化的？</h4><p>inline函数至少在三个方面提升了程序的时间性能：</p>
<ul>
<li>1、避免了函数调用必须执行的压栈出栈等操作。</li>
<li>2、由于函数体代码被移到函数调用处，编译器可以获得更多的上下文信息，并根据这些信息对函数体代码和被调用者代码进行更进一步的优化。</li>
<li>3、若不使用inline函数，程序执行至函数调用处，需要转而去执行函数体所在位置的代码。一般函数调用位置和函数代码所在位置在代码段中并不相近，这样很容易形成操作系统的缺页中断。操作系统需要把缺页地址的代码从硬盘移入内存，所需时间将成数量级增加。而使用inline函数则可以减少缺页中断发生的机会。</li>
</ul>
<h4 id="对于inline的使用，我们应该注意的问题？"><a href="#对于inline的使用，我们应该注意的问题？" class="headerlink" title="对于inline的使用，我们应该注意的问题？"></a>对于inline的使用，我们应该注意的问题？</h4><ul>
<li>1、由于inline函数在函数调用处插入函数体代码代替函数调用，若该函数在程序的很多位置被调用，有可能造成内存空间的浪费。</li>
<li>2、一般程序的压栈出栈操作也需要一定的代码，这段代码完成栈指针调整、参数传递、现场保护和恢复等操作。</li>
</ul>
<p>若函数的函数体代码量小于编译器生成的函数压栈出栈代码，则可以放心地定义为inline，这个时候占用内存空间反而会减小。而当函数体代码大于函数压栈出栈代码时，将函数定义为inline就会增加内存空间的使用。</p>
<ul>
<li>3、C++程序应该根据应用的具体场景、函数体大小、调用位置多少、函数调用的频率、应用场景对时间性能的要求，应用场景对内存性能的要求等各方面因素合理决定是否定义inline函数。</li>
<li>4、inline函数内不允许用循环语句和开关语句。</li>
</ul>
<h3 id="3、抖音BoostMultiDex优化"><a href="#3、抖音BoostMultiDex优化" class="headerlink" title="3、抖音BoostMultiDex优化"></a>3、抖音BoostMultiDex优化</h3><p>为了彻底解决MutiDex加载时间慢的问题，抖音团队深入挖掘了 Dalvik 虚拟机的底层系统机制，对 DEX 相关的处理逻辑进行了重新设计与优化，并推出了 BoostMultiDex 方案，它能够减少 80% 以上的黑屏等待时间，挽救低版本 Android 用户的升级安装体验。</p>
<p>具体的实现原理为：在第一次启动的时候，直接加载没有经过 OPT 优化的原始 DEX，先使得 APP 能够正常启动。然后在后台启动一个单独进程，慢慢地做完 DEX 的 OPT 工作，尽可能避免影响到前台 APP 的正常使用。绕过 ODEX 直接加载 DEX 的方案如下：</p>
<ul>
<li>1）、从 APK 中解压获取原始 Secondary DEX 文件的字节码</li>
<li>2）、通过 dlsym 获取dvm_dalvik_system_DexFile数组</li>
<li>3）、在数组中查询得到Dalvik_dalvik_system_DexFile_openDexFile_bytearray函数</li>
<li>4）、调用该函数，逐个传入之前从 APK 获取的 DEX 字节码，完成 DEX 加载，得到合法的DexFile对象</li>
<li>5）、把DexFile对象都添加到 APP 的PathClassLoader的 pathList 里</li>
</ul>
<p>补充：getDex 会抛出异常，原因是 memMap 需要被赋值，但是 Dalvik_dalvik_system_DexFile_openDexFile_bytearray 这个函数没有这个操作。分析代码后，我们发现，只要 dex_object 对象不为空，就会直接返回，不会再往下执行到取 memMap 的地方。因此，我们在加载完 DEX 数组之后，可以自己生成一个dex_object对象，并注入pDvmDex里面。</p>
<p>如有兴趣的同学可以看看这篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844904079206907911">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%</a></p>
<h2 id="7、类预加载优化"><a href="#7、类预加载优化" class="headerlink" title="7、类预加载优化"></a>7、类预加载优化</h2><p>在Application中提前异步加载初始化耗时较长的类。</p>
<h3 id="如何找到耗时较长的类？"><a href="#如何找到耗时较长的类？" class="headerlink" title="如何找到耗时较长的类？"></a>如何找到耗时较长的类？</h3><p>替换系统的ClassLoader，打印类加载的时间，按需选取需要异步加载的类。</p>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><ul>
<li>Class.forName()只加载类本身及其静态变量的引用类。</li>
<li>new 类实例 可以额外加载类成员变量的引用类。</li>
</ul>
<h2 id="8、WebView启动优化"><a href="#8、WebView启动优化" class="headerlink" title="8、WebView启动优化"></a>8、WebView启动优化</h2><ul>
<li>1、WebView首次创建比较耗时，需要预先创建WebView提前将其内核初始化。</li>
<li>2、使用WebView缓存池，用到WebView的时候都从缓存池中拿，注意内存泄漏问题。</li>
<li>3、本地离线包，即预置静态页面资源。</li>
</ul>
<h2 id="9、页面数据预加载"><a href="#9、页面数据预加载" class="headerlink" title="9、页面数据预加载"></a>9、页面数据预加载</h2><p>在主页空闲时，将其它页面的数据加载好保存到内存或数据库，等到打开该页面时，判断已经预加载过，就直接从内存或数据库取数据并显示。</p>
<h2 id="10、启动阶段不启动子进程"><a href="#10、启动阶段不启动子进程" class="headerlink" title="10、启动阶段不启动子进程"></a>10、启动阶段不启动子进程</h2><p>子进程会共享CPU资源，导致主进程CPU紧张。此外，在多进程情况下一定要可以在onCreate中去区分进程做一些初始化工作。</p>
<h3 id="注意启动顺序"><a href="#注意启动顺序" class="headerlink" title="注意启动顺序"></a>注意启动顺序</h3><p>App onCreate之前是ContentProvider初始化。</p>
<h2 id="11、闪屏页与主页的绘制优化"><a href="#11、闪屏页与主页的绘制优化" class="headerlink" title="11、闪屏页与主页的绘制优化"></a>11、闪屏页与主页的绘制优化</h2><ul>
<li>1、布局优化。</li>
<li>2、过渡绘制优化。</li>
</ul>
<p>关于布局与绘制优化可以参考<a target="_blank" rel="noopener" href="https://juejin.im/post/6844904080989487118">Android性能优化之绘制优化</a>。</p>
<!-- flag of hidden posts -->
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt=" WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/private/" rel="tag"># private</a>
          
            <a href="/tags/%E5%AE%89%E5%8D%93%E4%BC%98%E5%8C%96/" rel="tag"># 安卓优化</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:shenbh@189.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/ptwenzi?spm=1010.2135.3001.5113" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-clone"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/shenbh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://gitee.com/shen_bh" target="_blank" title="Gitee">
                      
                        <i class="fa fa-fw fa-git"></i>Gitee</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96"><span class="nav-text">启动速度优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%A4%A7%E7%BA%B2"><span class="nav-text">思维导图大纲</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">一、启动优化的意义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">二、应用启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E3%80%81%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">1 、应用启动的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8"><span class="nav-text">冷启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">启动流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%AD%E5%90%AF%E5%8A%A8"><span class="nav-text">热启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%A9%E5%90%AF%E5%8A%A8"><span class="nav-text">温启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-2"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-1"><span class="nav-text">启动流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ViewRootImpl%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">ViewRootImpl是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%86%B7%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96%E6%96%B9%E5%90%91"><span class="nav-text">2、冷启动分析及其优化方向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BB%BB%E5%8A%A1"><span class="nav-text">冷启动涉及的相关任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%89%8D"><span class="nav-text">冷启动之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E5%90%8E%E4%BB%BB%E5%8A%A1"><span class="nav-text">随后任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E5%90%91"><span class="nav-text">优化方向</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E6%A3%80%E6%B5%8B"><span class="nav-text">三、启动耗时检测</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8BLogcat"><span class="nav-text">1、查看Logcat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81adb-shell"><span class="nav-text">2、adb shell</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThisTime"><span class="nav-text">ThisTime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TotalTime"><span class="nav-text">TotalTime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WaitTime"><span class="nav-text">WaitTime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-text">特点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E6%89%93%E7%82%B9%EF%BC%88%E5%87%BD%E6%95%B0%E6%8F%92%E6%A1%A9%EF%BC%89"><span class="nav-text">3、代码打点（函数插桩）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Application-%E6%89%93%E7%82%B9"><span class="nav-text">Application 打点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAActivity%E6%89%93%E7%82%B9"><span class="nav-text">第一个Activity打点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-3"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8onWindowFocusChanged%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E4%BD%9C%E4%B8%BA%E5%90%AF%E5%8A%A8%E7%BB%93%E6%9D%9F%E7%82%B9%EF%BC%9F"><span class="nav-text">为什么不使用onWindowFocusChanged这个方法作为启动结束点？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81AOP-Aspect-Oriented-Programming-%E6%89%93%E7%82%B9"><span class="nav-text">4、AOP(Aspect Oriented Programming) 打点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BD%9C%E7%94%A8"><span class="nav-text">1、作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81AOP%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">2、AOP核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9"><span class="nav-text">1、横切关注点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%88%87%E9%9D%A2%EF%BC%88Aspect%EF%BC%89"><span class="nav-text">2、切面（Aspect）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%88JoinPoint%EF%BC%89"><span class="nav-text">3、连接点（JoinPoint）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%88%87%E5%85%A5%E7%82%B9%EF%BC%88PointCut%EF%BC%89"><span class="nav-text">4、切入点（PointCut）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89"><span class="nav-text">5、通知（Advice）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%87%86%E5%A4%87%EF%BC%9A%E6%8E%A5%E5%85%A5AspectJx%E8%BF%9B%E8%A1%8C%E5%88%87%E9%9D%A2%E7%BC%96%E7%A0%81"><span class="nav-text">3、准备：接入AspectJx进行切面编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81AOP%E5%9F%8B%E7%82%B9%E5%AE%9E%E6%88%98"><span class="nav-text">4、AOP埋点实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1Application%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%80%97%E6%97%B6%EF%BC%9F"><span class="nav-text">如何统计Application中的所有方法耗时？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Around%E5%92%8CBefore%E3%80%81After%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%88%AB"><span class="nav-text">Around和Before、After的最大区别:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93AOP%E7%89%B9%E6%80%A7"><span class="nav-text">5、总结AOP特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-%E2%80%94-TraceView"><span class="nav-text">5、启动速度分析工具 — TraceView</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">1、使用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Profile-CPU"><span class="nav-text">2、Profile CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Trace-types"><span class="nav-text">1、Trace types</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Trace-Java-Methods"><span class="nav-text">1、Trace Java Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Sample-Java-Methods"><span class="nav-text">2、Sample Java Methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Sample-C-x2F-C-Functions"><span class="nav-text">3、Sample C&#x2F;C++ Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Trace-System-Calls"><span class="nav-text">4、Trace System Calls</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Event-timeline"><span class="nav-text">2、Event timeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81CPU-timeline"><span class="nav-text">3、CPU timeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Thread-activity-timeline"><span class="nav-text">4、Thread activity timeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%A3%80%E6%9F%A5%E8%B7%9F%E8%B8%AA%E6%95%B0%E6%8D%AE%E7%AA%97%E5%8F%A3"><span class="nav-text">5、检查跟踪数据窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Call-Chart"><span class="nav-text">1、Call Chart</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA"><span class="nav-text">提示</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Flame-Chart"><span class="nav-text">2、Flame Chart</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="nav-text">使用技巧</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Top-Down"><span class="nav-text">3、Top Down</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Bottom-Up"><span class="nav-text">4、Bottom Up</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81TraceView%E5%B0%8F%E7%BB%93"><span class="nav-text">3、TraceView小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-4"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-text">作用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-%E2%80%94-Systrace"><span class="nav-text">6、启动速度分析工具 — Systrace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%8F%92%E6%A1%A9"><span class="nav-text">1、使用方式：代码插桩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-text">如何查看数据？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Systrace%E5%8E%9F%E7%90%86"><span class="nav-text">2、Systrace原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Systrace%E5%B0%8F%E7%BB%93"><span class="nav-text">3、Systrace小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-5"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="nav-text">作用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%90%AF%E5%8A%A8%E7%9B%91%E6%8E%A7"><span class="nav-text">7、启动监控</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%9B%91%E6%8E%A7%EF%BC%9A%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6"><span class="nav-text">1、实验室监控：视频录制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7"><span class="nav-text">2、线上监控</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87"><span class="nav-text">目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%90%AF%E5%8A%A8%E7%BB%93%E6%9D%9F%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%97%B6%E6%9C%BA"><span class="nav-text">1、启动结束的统计时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E6%89%A3%E9%99%A4%E9%80%BB%E8%BE%91"><span class="nav-text">2、启动时间扣除逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%90%AF%E5%8A%A8%E6%8E%92%E9%99%A4%E9%80%BB%E8%BE%91"><span class="nav-text">3、启动排除逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%8C%87%E6%A0%87%E6%9D%A5%E8%A1%A1%E9%87%8F%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E7%9A%84%E5%BF%AB%E6%85%A2%EF%BC%9F"><span class="nav-text">4、使用什么指标来衡量启动速度的快慢？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B3%E5%9D%87%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">平均启动时间的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E7%9A%84%E6%8C%87%E6%A0%87"><span class="nav-text">建议的指标</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%90%AF%E5%8A%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="nav-text">5、启动的类型有哪几种？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%B8%B8%E8%A7%84%E6%96%B9%E6%A1%88"><span class="nav-text">四、启动优化常规方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text">启动过程中的常见问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%8C%BA%E5%9F%9F"><span class="nav-text">优化区域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2"><span class="nav-text">1、主题切换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="nav-text">2、第三方库懒加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%BC%82%E6%AD%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="nav-text">3、异步初始化预备知识-线程优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Android%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="nav-text">1、Android线程调度原理剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86"><span class="nav-text">线程调度原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-text">线程调度模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%88%86%E6%97%B6%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-text">1、分时调度模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-text">2、抢占式调度模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B9%B2%E9%A2%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9F"><span class="nav-text">如何干预线程调度？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-text">Android线程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81nice%E5%80%BC"><span class="nav-text">1、nice值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81cgroup"><span class="nav-text">2、cgroup</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Android%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-text">2、Android异步方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Thread"><span class="nav-text">1、Thread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81HandlerThread"><span class="nav-text">2、HandlerThread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81IntentService"><span class="nav-text">3、IntentService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81AsyncTask"><span class="nav-text">4、AsyncTask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">5、线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81RxJava"><span class="nav-text">6、RxJava</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-text">异步方式总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Android%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98"><span class="nav-text">3、Android线程优化实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%87%86%E5%88%99"><span class="nav-text">线程使用准则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%A6%82%E4%BD%95%E9%94%81%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%80%85"><span class="nav-text">4、如何锁定线程创建者</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%83%8C%E6%99%AF"><span class="nav-text">锁定线程创建背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E6%A1%88"><span class="nav-text">锁定线程创建方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%88%98"><span class="nav-text">实战</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E6%94%B6%E6%95%9B%E4%BC%98%E9%9B%85%E5%AE%9E%E8%B7%B5%E5%88%9D%E6%AD%A5"><span class="nav-text">5、线程收敛优雅实践初步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%94%B6%E6%95%9B%E5%B8%B8%E8%A7%84%E6%96%B9%E6%A1%88"><span class="nav-text">线程收敛常规方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%BA%93%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">问题：基础库怎么使用线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%BA%93%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="nav-text">基础库优雅使用线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E7%BA%BF%E7%A8%8B%E5%BA%93%E6%97%B6%E5%8C%BA%E5%88%86%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="nav-text">统一线程库时区分任务类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%94%A8%E4%BA%8E%E6%89%A7%E8%A1%8C%E5%A4%9A%E7%B1%BB%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6"><span class="nav-text">实现用于执行多类型任务的基础线程池组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="nav-text">6、线程优化核心问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">1、线程使用为什么会遇到问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="nav-text">表现形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"><span class="nav-text">问题原因</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%80%8E%E4%B9%88%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AF%B9%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">2、怎么在项目中对线程进行优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%94%B6%E6%95%9B"><span class="nav-text">核心：线程收敛</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%BC%82%E6%AD%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">4、异步初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">1、核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%BC%82%E6%AD%A5%E4%BC%98%E5%8C%96%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">2、异步优化注意点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%BC%82%E6%AD%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%A1%88%E6%BC%94%E8%BF%9B"><span class="nav-text">3、异步初始化方案演进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%BC%82%E6%AD%A5%E4%BC%98%E5%8C%96%E6%9C%80%E4%BC%98%E8%A7%A3%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%90%AF%E5%8A%A8%E5%99%A8"><span class="nav-text">4、异步优化最优解：异步启动器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E5%BC%82%E6%AD%A5%E4%BC%98%E5%8C%96%E7%97%9B%E7%82%B9"><span class="nav-text">常规异步优化痛点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%99%A8%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">启动器核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%99%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">启动器流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%90%AF%E5%8A%A8%E5%99%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%8E%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-text">异步启动器优化实战与源码剖析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">5、延迟初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%B8%B8%E8%A7%84%E6%96%B9%E6%A1%88%EF%BC%9A%E5%88%A9%E7%94%A8%E9%97%AA%E5%B1%8F%E9%A1%B5%E7%9A%84%E5%81%9C%E7%95%99%E6%97%B6%E9%97%B4%E8%BF%9B%E8%A1%8C%E9%83%A8%E5%88%86%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">1、常规方案：利用闪屏页的停留时间进行部分初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%B8%B8%E8%A7%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%97%9B%E7%82%B9"><span class="nav-text">2、常规初始化痛点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%BB%B6%E8%BF%9F%E4%BC%98%E5%8C%96%E6%9C%80%E4%BC%98%E8%A7%A3%EF%BC%9A%E5%BB%B6%E8%BF%9F%E5%90%AF%E5%8A%A8%E5%99%A8"><span class="nav-text">3、延迟优化最优解：延迟启动器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%90%AF%E5%8A%A8%E5%99%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%E4%B8%8E%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-text">延迟启动器优化实战与源码剖析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%90%AF%E5%8A%A8%E5%99%A8%E4%BC%98%E5%8A%BF"><span class="nav-text">延迟启动器优势</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81Multidex%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="nav-text">6、Multidex预加载优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="nav-text">1、优化步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81dex-opt%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">2、dex-opt过程是怎样的？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%EF%BC%8Cinline%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">那么，inline是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inline%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">inline的作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inline%E5%8F%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="nav-text">inline又是如何进行优化的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8Einline%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">对于inline的使用，我们应该注意的问题？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%8A%96%E9%9F%B3BoostMultiDex%E4%BC%98%E5%8C%96"><span class="nav-text">3、抖音BoostMultiDex优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E7%B1%BB%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="nav-text">7、类预加载优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E8%80%97%E6%97%B6%E8%BE%83%E9%95%BF%E7%9A%84%E7%B1%BB%EF%BC%9F"><span class="nav-text">如何找到耗时较长的类？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="nav-text">注意</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81WebView%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96"><span class="nav-text">8、WebView启动优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="nav-text">9、页面数据预加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E4%B8%8D%E5%90%AF%E5%8A%A8%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">10、启动阶段不启动子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F"><span class="nav-text">注意启动顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81%E9%97%AA%E5%B1%8F%E9%A1%B5%E4%B8%8E%E4%B8%BB%E9%A1%B5%E7%9A%84%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96"><span class="nav-text">11、闪屏页与主页的绘制优化</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿炳</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('Copied')
          else $(this).text('Copy failed')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>