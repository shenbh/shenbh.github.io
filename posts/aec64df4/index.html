<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="clippings," />










<meta name="description" content="概述注：本文基于Android 10源码，为了文章的简洁性，引用源码的地方可能有所删减。 官方注释: SurfaceFlinger accepts buffers, composes buffers, and sends buffers to the display.The most common consumer of image streams is SurfaceFlinger, the s">
<meta property="og:type" content="article">
<meta property="og:title" content="Android-SurfaceFlinger启动与绘图原理">
<meta property="og:url" content="http://shenbh.github.io/posts/aec64df4/index.html">
<meta property="og:site_name" content="积跬步">
<meta property="og:description" content="概述注：本文基于Android 10源码，为了文章的简洁性，引用源码的地方可能有所删减。 官方注释: SurfaceFlinger accepts buffers, composes buffers, and sends buffers to the display.The most common consumer of image streams is SurfaceFlinger, the s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://shenbh.github.io/posts/aec64df4/SurfaceFlinger%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg">
<meta property="article:published_time" content="2025-07-03T08:36:52.955Z">
<meta property="article:modified_time" content="2025-07-03T09:10:16.733Z">
<meta property="article:author" content="阿炳">
<meta property="article:tag" content="clippings">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://shenbh.github.io/posts/aec64df4/SurfaceFlinger%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://shenbh.github.io/posts/aec64df4/"/>





  <title>Android-SurfaceFlinger启动与绘图原理 | 积跬步</title>
  








<meta name="generator" content="Hexo 6.1.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">积跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Just do IT Now.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shenbh.github.io/posts/aec64df4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积跬步">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Android-SurfaceFlinger启动与绘图原理</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-07-03T16:36:52+08:00">
                2025-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          
              <div class="post-description">
                  概述注：本文基于Android 10源码，为了文章的简洁性，引用源码的地方可能有所删减。 官方注释: SurfaceFlinger accepts buffers, composes buffers, and sends buffers to the display.The most common consumer of image streams is SurfaceFlinger, the s
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>注：本文基于Android 10源码，为了文章的简洁性，引用源码的地方可能有所删减。</p>
<p>官方注释: <code>SurfaceFlinger accepts buffers, composes buffers, and sends buffers to the display.The most common consumer of image streams is SurfaceFlinger, the system service that consumes the currently visible surfaces and composites them onto the display using information provided by the Window Manager. SurfaceFlinger is the only service that can modify the content of the display. SurfaceFlinger uses OpenGL and the Hardware Composer to compose a group of surfaces.</code></p>
<p>SurfaceFlinger 用来管理消费当前可见的 Surface, 所有被渲染的可见 Surface 都会被 SurfaceFlinger 通过 WindowManager 提供的信息合成(使用 OpenGL 和 HardWare Composer)提交到屏幕的后缓冲区，等待屏幕的下一个 Vsync 信号到来，再显示到屏幕上。SufaceFlinger 通过屏幕后缓冲区与屏幕建立联系，同时通过 Surface 与上层建立联系，起到了一个承上启下的作用。</p>
<p>surfaceflinger 是在 Android 系统启动时解析 init.rc 文件(参考 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/10/21/Android-init-zygote/">Android系统启动源码解析</a>)启动的守护进程，当 surfaceflinger 重启时会触发 zygote 重启。配置的 rc 文件位于 <code>/system/etc/init/surfaceflinger.rc</code>, 文件内容如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="symbol">core</span> <span class="symbol">animation</span></span><br><span class="line"></span><br><span class="line">    <span class="symbol">user</span> <span class="symbol">system</span></span><br><span class="line"></span><br><span class="line">    <span class="symbol">group</span> <span class="symbol">graphics</span> <span class="symbol">drmrpc</span> <span class="symbol">readproc</span></span><br><span class="line"></span><br><span class="line">    <span class="symbol">onrestart</span> <span class="symbol">restart</span> <span class="symbol">zygote</span></span><br><span class="line"></span><br><span class="line">    <span class="symbol">writepid</span> /<span class="symbol">dev</span>/<span class="symbol">stune</span>/<span class="symbol">foreground</span>/<span class="symbol">tasks</span></span><br><span class="line"></span><br><span class="line">    <span class="symbol">socket</span> <span class="symbol">pdx</span>/<span class="symbol">system</span>/<span class="symbol">vr</span>/<span class="symbol">display</span>/<span class="symbol">client</span>     <span class="symbol">stream</span> <span class="symbol">0666</span> <span class="symbol">system</span> <span class="symbol">graphics</span> <span class="symbol">u:<span class="symbol">object_r</span>:<span class="symbol">pdx_display_client_endpoint_socket</span>:<span class="symbol">s0</span></span></span><br><span class="line"></span><br><span class="line">    <span class="symbol">socket</span> <span class="symbol">pdx</span>/<span class="symbol">system</span>/<span class="symbol">vr</span>/<span class="symbol">display</span>/<span class="symbol">manager</span>    <span class="symbol">stream</span> <span class="symbol">0666</span> <span class="symbol">system</span> <span class="symbol">graphics</span> <span class="symbol">u:<span class="symbol">object_r</span>:<span class="symbol">pdx_display_manager_endpoint_socket</span>:<span class="symbol">s0</span></span></span><br><span class="line"></span><br><span class="line">    <span class="symbol">socket</span> <span class="symbol">pdx</span>/<span class="symbol">system</span>/<span class="symbol">vr</span>/<span class="symbol">display</span>/<span class="symbol">vsync</span>      <span class="symbol">stream</span> <span class="symbol">0666</span> <span class="symbol">system</span> <span class="symbol">graphics</span> <span class="symbol">u:<span class="symbol">object_r</span>:<span class="symbol">pdx_display_vsync_endpoint_socket</span>:<span class="symbol">s0</span></span></span><br></pre></td></tr></table></figure>

<h2 id="启动SurfaceFlinger"><a href="#启动SurfaceFlinger" class="headerlink" title="启动SurfaceFlinger"></a>启动SurfaceFlinger</h2><p>在解析执行了 init.rc 文件后，surfaceflinger 服务启动从 main_surfaceflinger.main() 方法开始：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When SF is launched in its own process, limit the number of binder threads to 4.</span></span><br><span class="line"></span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">setThreadPoolMaxThreadCount</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the thread pool</span></span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">ps</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line"></span><br><span class="line">    ps-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instantiate surfaceflinger</span></span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = <span class="keyword">new</span> <span class="built_in">SurfaceFlinger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setpriority</span>(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_sched_policy</span>(<span class="number">0</span>, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Put most SurfaceFlinger threads in the system-background cpuset Keeps us from unnecessarily</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// using big cores. Do this after the binder thread pool init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cpusets_enabled</span>()) <span class="built_in">set_cpuset_policy</span>(<span class="number">0</span>, SP_SYSTEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize before clients can connect</span></span><br><span class="line"></span><br><span class="line">    flinger-&gt;<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “SurfaceFlinger” Binder 服务注册到 ServiceManager</span></span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line"></span><br><span class="line">    sm-&gt;<span class="built_in">addService</span>(<span class="built_in">String16</span>(SurfaceFlinger::<span class="built_in">getServiceName</span>()), flinger, <span class="literal">false</span>, IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “gpu” Binder 服务注册到 ServiceManager</span></span><br><span class="line"></span><br><span class="line">    sp&lt;GpuService&gt; gpuservice = <span class="keyword">new</span> <span class="built_in">GpuService</span>();</span><br><span class="line"></span><br><span class="line">    sm-&gt;<span class="built_in">addService</span>(<span class="built_in">String16</span>(GpuService::SERVICE_NAME), gpuservice, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">startDisplayService</span>(); <span class="comment">// dependency on SF getting registered above</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run surface flinger in this thread</span></span><br><span class="line"></span><br><span class="line">    flinger-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释可以看出，该方法的主要功能如下：</p>
<ul>
<li>设置 surfaceflinger 进程的 binder 线程池数最多为4，然后启动 binder 线程池；</li>
<li>创建 SurfaceFlinger 对象，将 surfaceflinger 进程设置为高优先级及使用前台调度策略；</li>
<li>初始化 SurfaceFlinger；</li>
<li>将 <code>SurfaceFlinger</code> 和 <code>gpu</code> Binder 服务注册到 ServiceManager；</li>
<li>启动 DisplayService；</li>
<li>在当前主线程执行 SurfaceFlinger.run 方法。</li>
</ul>
<h2 id="实例化SurfaceFlinger"><a href="#实例化SurfaceFlinger" class="headerlink" title="实例化SurfaceFlinger"></a>实例化SurfaceFlinger</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line">SurfaceFlinger::<span class="built_in">SurfaceFlinger</span>() : <span class="built_in">SurfaceFlinger</span>(SkipInitialization) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行这里</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MessageQueue 类型</span></span><br><span class="line"></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">init</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息机制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::init</span><span class="params">(<span class="type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mFlinger = flinger;</span><br><span class="line"></span><br><span class="line">    mLooper = <span class="keyword">new</span> <span class="built_in">Looper</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="built_in">Handler</span>(*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化SurfaceFlinger"><a href="#初始化SurfaceFlinger" class="headerlink" title="初始化SurfaceFlinger"></a>初始化SurfaceFlinger</h2><p>SF 初始化的逻辑在 SurfaceFlinger.init 方法里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;SurfaceFlinger&#x27;s main thread ready to run. &quot;</span> <span class="string">&quot;Initializing graphics H/W...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别创建 app 和 SF 的 EventThread 线程</span></span><br><span class="line"></span><br><span class="line">    mEventThreadSource = std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mEventThread = std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mEventThreadSource.<span class="built_in">get</span>(), [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line"></span><br><span class="line">            impl::EventThread::<span class="built_in">InterceptVSyncsCallback</span>(), <span class="string">&quot;appEventThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mSfEventThreadSource = std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">&quot;sf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mSFEventThread = std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mSfEventThreadSource.<span class="built_in">get</span>(), [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line"></span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123; mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp); &#125;, <span class="string">&quot;sfEventThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventThread</span>(mSFEventThread.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    mVsyncModulator.<span class="built_in">setEventThread</span>(mSFEventThread.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RenderEngine 引擎(can&#x27;t fail)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getBE</span>().mRenderEngine = RE::impl::RenderEngine::<span class="built_in">create</span>(HAL_PIXEL_FORMAT_RGBA_8888, hasWideColorDisplay ? RE::RenderEngine::WIDE_COLOR_SUPPORT : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Hardware Composer 对象(通过 HAL 层的 HWComposer 硬件模块 或 软件模拟产生 Vsync 信号)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getBE</span>().mHwc.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">HWComposer</span>(std::<span class="built_in">make_unique</span>&lt;Hwc2::impl::Composer&gt;(<span class="built_in">getBE</span>().mHwcServiceName)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">registerCallback</span>(<span class="keyword">this</span>, <span class="built_in">getBE</span>().mComposerSequenceId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化显示屏 DisplayDevice</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">processDisplayHotplugEventsLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make the default display GLContext current so that we can create textures</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// when creating Layers (which may happens before we render something)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getDefaultDisplayDeviceLocked</span>()-&gt;<span class="built_in">makeCurrent</span>();</span><br><span class="line"></span><br><span class="line">    mEventControlThread = std::<span class="built_in">make_unique</span>&lt;impl::EventControlThread&gt;(</span><br><span class="line"></span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">bool</span> enabled) &#123; <span class="built_in">setVsyncEnabled</span>(HWC_DISPLAY_PRIMARY, enabled); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize our drawing state</span></span><br><span class="line"></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set initial conditions (e.g. unblank default device)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">initializeDisplays</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动开机动画服务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStartPropertySetThread-&gt;<span class="built_in">Start</span>() != NO_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Run StartPropertySetThread failed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SF 初始化时的主要功能：</p>
<ul>
<li>创建 HWComposer 对象；</li>
<li>初始化非虚拟显示屏；</li>
<li>分别启动 app 和 sf 的 EventThread 线程，创建了两个 DispSyncSource 对象，分别是用于绘制(app)和合成(SurfaceFlinger)；</li>
<li>启动开机动画服务；</li>
</ul>
<h2 id="向HWC注册回调"><a href="#向HWC注册回调" class="headerlink" title="向HWC注册回调"></a>向HWC注册回调</h2><p>在前一节的 SurfaceFlinger.init 方法中有一行代码: <code>getBE().mHwc-&gt;registerCallback(this, getBE().mComposerSequenceId)</code> 给 HWComposer 注册了回调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::registerCallback</span><span class="params">(HWC2::ComposerCallback* callback, <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mHwcDevice 是 Device 类型</span></span><br><span class="line"></span><br><span class="line">    mHwcDevice-&gt;<span class="built_in">registerCallback</span>(callback, sequenceId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Device::registerCallback</span><span class="params">(ComposerCallback* callback, <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRegisteredCallback) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Callback already registered. Ignored extra registration attempt.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRegisteredCallback = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;ComposerCallbackBridge&gt; <span class="title">callbackBridge</span><span class="params">(<span class="keyword">new</span> ComposerCallbackBridge(callback, sequenceId))</span></span>;</span><br><span class="line"></span><br><span class="line">    mComposer-&gt;<span class="built_in">registerCallback</span>(callbackBridge);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 mClient 向硬件注册回调</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Composer::registerCallback</span><span class="params">(<span class="type">const</span> sp&lt;IComposerCallback&gt;&amp; callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret = mClient-&gt;<span class="built_in">registerCallback</span>(callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以看一下 ComposerCallbackBridge 回调接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComposerCallbackBridge</span> : <span class="keyword">public</span> Hwc2::IComposerCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 热插拔</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onHotplug</span><span class="params">(Hwc2::Display display, IComposerCallback::Connection conn)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HWC2::Connection connection = <span class="built_in">static_cast</span>&lt;HWC2::Connection&gt;(conn);</span><br><span class="line"></span><br><span class="line">        mCallback-&gt;<span class="built_in">onHotplugReceived</span>(mSequenceId, display, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onRefresh</span><span class="params">(Hwc2::Display display)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mCallback-&gt;<span class="built_in">onRefreshReceived</span>(mSequenceId, display);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vsync</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onVsync</span><span class="params">(Hwc2::Display display, <span class="type">int64_t</span> timestamp)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mCallback-&gt;<span class="built_in">onVsyncReceived</span>(mSequenceId, display, timestamp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面 ComposerCallbackBridge 中的 mCallback 参数，传入的是 SurfaceFlinger 实例，它继承自 <code>HWC2::ComposerCallback</code> 接口，用来处理 HWC 的回调。</p>
<h2 id="接收HWC回调"><a href="#接收HWC回调" class="headerlink" title="接收HWC回调"></a>接收HWC回调</h2><p>当 HWComposer 产生 Vsync 信号时，回调 ComposerCallbackBridge.onVsync 方法，进而调用 SF.onVsyncReceived 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onVsyncReceived</span><span class="params">(<span class="type">int32_t</span> sequenceId, <span class="type">hwc2_display_t</span> displayId, <span class="type">int64_t</span> timestamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == DisplayDevice::DISPLAY_PRIMARY &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// mPrimaryHWVsyncEnabled 标识主屏幕对应的 HWC 的 VSYNC 功能有没有被开启</span></span><br><span class="line"></span><br><span class="line">            needsHwVsync = mPrimaryDispSync.<span class="built_in">addResyncSample</span>(timestamp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">enableHardwareVsync</span>();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">disableHardwareVsync</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mPrimaryDispSync 是一个 DispSync 对象，可以看出硬件产生的 Vsync 信号会交给同步模型 DispSync 的 addResyncSample 方法处理，根据该方法的返回值可以控制硬件是否继续发送垂直信号(SF.enableHardwareVsync &amp; SF.disableHardwareVsync)，即硬件的垂直信号并不是持续产生的，而是 DispSync 同步模型在需要(addResyncSample)的时候才 enable 的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::enableHardwareVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled &amp;&amp; mHWVsyncAvailable) &#123;</span><br><span class="line"></span><br><span class="line">        mPrimaryDispSync.<span class="built_in">beginResync</span>();</span><br><span class="line"></span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::disableHardwareVsync</span><span class="params">(<span class="type">bool</span> makeUnavailable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line"></span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        mPrimaryDispSync.<span class="built_in">endResync</span>();</span><br><span class="line"></span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (makeUnavailable) &#123;</span><br><span class="line"></span><br><span class="line">        mHWVsyncAvailable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是通过 EventControlThread 来完成的。</p>
<h2 id="EventControlThread"><a href="#EventControlThread" class="headerlink" title="EventControlThread"></a>EventControlThread</h2><p>EventControlThread 线程用来控制 HWC 是否应该发送 Vsync 信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">EventControlThread::<span class="built_in">EventControlThread</span>(EventControlThread::SetVSyncEnabledFunction function) : <span class="built_in">mSetVSyncEnabled</span>(function) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(mThread.<span class="built_in">native_handle</span>(), <span class="string">&quot;EventControlThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::setVsyncEnabled</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    mVsyncEnabled = enabled;</span><br><span class="line"></span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> keepRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> currentVsyncEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (keepRunning) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mSetVSyncEnabled</span>(currentVsyncEnabled); <span class="comment">// false--初始化 SF 时默认会关闭 HWC Vsync 的发送</span></span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        mCondition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, currentVsyncEnabled, keepRunning]() NO_THREAD_SAFETY_ANALYSIS &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> currentVsyncEnabled != mVsyncEnabled || keepRunning != mKeepRunning;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        currentVsyncEnabled = mVsyncEnabled;</span><br><span class="line"></span><br><span class="line">        keepRunning = mKeepRunning;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据之前的代码可以知道 mSetVSyncEnabled 传入的是 SF.setVsyncEnabled</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setVsyncEnabled</span><span class="params">(<span class="type">int</span> disp, <span class="type">int</span> enabled)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制 HWC 是否使能 Vsync</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">setVsyncEnabled</span>(disp, enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到默认会关闭 HWC Vsync 的发送，然后在执行 initializeDisplays 时会将其打开，调用流程: <code>SF.initializeDisplays -&gt; SF.onInitializeDisplays -&gt; SF.setPowerModeInternal -&gt; SF.resyncToHardwareVsync(true)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::resyncToHardwareVsync</span><span class="params">(<span class="type">bool</span> makeAvailable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line"></span><br><span class="line">        mHWVsyncAvailable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hardware vsync is not currently available, so abort the resync</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// attempt for now</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; activeConfig = <span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">getActiveConfig</span>(HWC_DISPLAY_PRIMARY);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> period = activeConfig-&gt;<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line"></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">setPeriod</span>(period);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line"></span><br><span class="line">        mPrimaryDispSync.<span class="built_in">beginResync</span>();</span><br><span class="line"></span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DispSync同步模型"><a href="#DispSync同步模型" class="headerlink" title="DispSync同步模型"></a>DispSync同步模型</h2><p>在 SF 的初始化过程中创建了两个 DispSyncSource 对象，分别是 App 绘制延时源和 SF 合成延时源，这两个源都基于 mPrimaryDispSync—一个 DispSync 对象，是对硬件 Hwc 垂直信号的同步模型，它在 SF 的构造方法中实例化。这是 Android 的优化策略，因为在 Vsync 信号到来后如果同时进行 App 的绘制和 SF 的合成流程，则可能会竞争 CPU 资源，从而影响效率。因此引入了 Vsync 同步模型 DispSync, 该模型会根据需要打开硬件的 Vsync 信号进行采样，然后同步 DispSync 模型，从而为上层的 APP 绘制延时源和 SF 合成延时源提供 Vsync 信号，这两个延时源分别添加一个相位偏移量(即上面代码中的 vsyncPhaseOffsetNs 和 sfVsyncPhaseOffsetNs)，以此错开在 Vsync 信号到来后 APP 绘制和 SF 合成的执行。</p>
<p>看一下 DispSync 的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DispSync::<span class="built_in">DispSync</span>(<span class="type">const</span> <span class="type">char</span>* name) : <span class="built_in">mName</span>(name), <span class="built_in">mRefreshSkipCount</span>(<span class="number">0</span>), <span class="built_in">mThread</span>(<span class="keyword">new</span> <span class="built_in">DispSyncThread</span>(name)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在 SurfaceFlinger 的构造函数里，会调用 mPrimaryDispSync.init 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::init</span><span class="params">(<span class="type">bool</span> hasSyncFramework, <span class="type">int64_t</span> dispSyncPresentTimeOffset)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动名为 DispSync 的线程</span></span><br><span class="line"></span><br><span class="line">    mThread-&gt;<span class="built_in">run</span>(<span class="string">&quot;DispSync&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">beginResync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DispSyncThread</span> : <span class="keyword">public</span> Thread &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 mCond.wait(mMutex) 等待被唤醒</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其他逻辑...</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行 DispSync 的初始化方法时会启动名为 DispSync 的线程, DispSync 线程通过调用 mCond.wait(mMutex) 阻塞自身线程，等待被唤醒。在接收到硬件 Vsync 信号后会回调到 SF.onVsyncReceived 方法，其中调用的 DispSync.addResyncSample 方法会更新同步模型的偏移量来使其和硬件的 VSYNC 信号同步，然后再通过 mCond.signal 唤醒 DispSync 线程。具体的算法就不看了，直接看 DispSync 线程被唤醒后的逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 mCond.wait(mMutex) 等待被唤醒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算下一次 VSYNC 信号的时间</span></span><br><span class="line"></span><br><span class="line">        targetTime = <span class="built_in">computeNextEventTimeLocked</span>(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还未到触发时间，则等待一段时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now &lt; targetTime) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集此次应该通知 Vsync 信号的所有监听者</span></span><br><span class="line"></span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations = <span class="built_in">gatherCallbackInvocationsLocked</span>(now);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callbackInvocations.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fireCallbackInvocations</span>(callbackInvocations);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector&lt;CallbackInvocation&gt; <span class="title">gatherCallbackInvocationsLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> onePeriodAgo = now - mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个监听者下一次 VSYNC 信号的发生时间可能都不同，因为可能设置了不同的偏移</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因此针对每个监听者都要计算下一次VSYNC信号</span></span><br><span class="line"></span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], onePeriodAgo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 需要通知则添加</span></span><br><span class="line"></span><br><span class="line">            CallbackInvocation ci;</span><br><span class="line"></span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;</span><br><span class="line"></span><br><span class="line">            ci.mEventTime = t;</span><br><span class="line"></span><br><span class="line">            callbackInvocations.<span class="built_in">push</span>(ci);</span><br><span class="line"></span><br><span class="line">            mEventListeners.<span class="built_in">editItemAt</span>(i).mLastEventTime = t;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fireCallbackInvocations</span><span class="params">(<span class="type">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; callbacks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调所有的监听者的 onDispSyncEvent 方法</span></span><br><span class="line"></span><br><span class="line">        callbacks[i].mCallback-&gt;<span class="built_in">onDispSyncEvent</span>(callbacks[i].mEventTime);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DispSync::addEventListener</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">nsecs_t</span> phase, Callback* callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mThread 是 DispSyncThread 类型，朝 mEventListeners 中添加监听器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mThread-&gt;<span class="built_in">addEventListener</span>(name, phase, callback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 DispSync.addEventListener 方法会添加 DispSync 同步模型的 Vsync 信号的监听器。</p>
<h2 id="DispSyncSource延时源"><a href="#DispSyncSource延时源" class="headerlink" title="DispSyncSource延时源"></a>DispSyncSource延时源</h2><p>上面已经讲过在 SF 的初始化过程中创建了两个 DispSyncSource 对象，分别是 App 绘制延时源和 SF 合成延时源，这两个源都基于 DispSync 同步模型来处理硬件 Vsync 信号，延时源通过对应的 EventThread 来管理。下面根据 DispSyncSource 源码看看从 DispSync 同步模型传递给 DispSyncSource 延时源的 Vsync 信号是怎么传递给需要的监听者的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VSyncSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onVSyncEvent</span><span class="params">(<span class="type">nsecs_t</span> when)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setVSyncEnabled</span><span class="params">(<span class="type">bool</span> enable)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setCallback</span><span class="params">(Callback* callback)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setPhaseOffset</span><span class="params">(<span class="type">nsecs_t</span> phaseOffset)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DispSync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onDispSyncEvent</span><span class="params">(<span class="type">nsecs_t</span> when)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DispSyncSource</span> <span class="keyword">final</span> : <span class="keyword">public</span> VSyncSource, <span class="keyword">private</span> DispSync::Callback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DispSyncSource</span>(DispSync* dispSync, <span class="type">nsecs_t</span> phaseOffset, <span class="type">bool</span> traceVsync, <span class="type">const</span> <span class="type">char</span>* name) :</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mName</span>(name), <span class="built_in">mDispSync</span>(dispSync), <span class="built_in">mPhaseOffset</span>(phaseOffset), <span class="built_in">mEnabled</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVSyncEnabled</span><span class="params">(<span class="type">bool</span> enable)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enable) &#123; <span class="comment">// 向 DispSync 添加监听器</span></span><br><span class="line"></span><br><span class="line">            mDispSync-&gt;<span class="built_in">addEventListener</span>(mName, mPhaseOffset, <span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 移除对 DispSync 的监听器</span></span><br><span class="line"></span><br><span class="line">            mDispSync-&gt;<span class="built_in">removeEventListener</span>(<span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mEnabled = enable;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCallback</span><span class="params">(VSyncSource::Callback* callback)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        mCallback = callback;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到 Vsync 信号后回调</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onDispSyncEvent</span><span class="params">(<span class="type">nsecs_t</span> when)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        VSyncSource::Callback* callback;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCallbackMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            callback = mCallback;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">            callback-&gt;<span class="built_in">onVSyncEvent</span>(when);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispSyncSource 延时源通过 DispSync 同步模型来构造实例，DispSync 通过调用接口方法 onDispSyncEvent 来通知 DispSyncSource 延时源收到了 Vsync 信号，然后通过 DispSyncSource 延时源设置的 callback.onVSyncEvent 方法将 Vsync 信号的到达事件通知给监听者(其实就是EventThread)。</p>
<ul>
<li>setVSyncEnabled: 控制是否监听来自于 DispSync 同步模型的 Vsync 信号</li>
<li>setCallback: 设置 DispSyncSource 延时源收到来自 DispSync 同步模型的 Vsync 信号后的监听者</li>
<li>onDispSyncEvent: DispSync 同步模型收到 Vsync 信号后通知 DispSyncSource 的回调方法，方法内部会回调通知通过 setCallback 方法设置的监听者(EventThread)</li>
</ul>
<h2 id="EventThread"><a href="#EventThread" class="headerlink" title="EventThread"></a>EventThread</h2><p>EventThread 用来负责管理 DispSyncSource 延时源，由于分别创建了用于 APP 绘制和 SF 合成的 DispSyncSource 源，因此也对应创建了两个分别用于管理它们的 EventThread 线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class EventThread : public android::EventThread, private VSyncSource::Callback &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    class Connection : public BnDisplayEventConnection &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class BnDisplayEventConnection : public SafeBnInterface&lt;IDisplayEventConnection&gt;</span></span><br><span class="line"></span><br><span class="line">EventThread::<span class="built_in">EventThread</span>(VSyncSource* src, ResyncWithRateLimitCallback resyncWithRateLimitCallback,</span><br><span class="line"></span><br><span class="line">        InterceptVSyncsCallback interceptVSyncsCallback, <span class="type">const</span> <span class="type">char</span>* threadName) : <span class="built_in">mVSyncSource</span>(src),</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>(resyncWithRateLimitCallback), <span class="built_in">mInterceptVSyncsCallback</span>(interceptVSyncsCallback) &#123;</span><br><span class="line"></span><br><span class="line">    mThread = std::<span class="built_in">thread</span>(&amp;EventThread::threadMain, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mKeepRunning) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待唤醒</span></span><br><span class="line"></span><br><span class="line">        signalConnections = <span class="built_in">waitForEventLocked</span>(&amp;lock, &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ET-waitForEventLocked"><a href="#ET-waitForEventLocked" class="headerlink" title="ET.waitForEventLocked"></a>ET.waitForEventLocked</h3><p>启动了 EventThread 后，调用 threadMain 方法，我们看一下 waitForEventLocked 方法的注释: <code>This will return when (1) a vsync event has been received, and (2) there was at least one connection interested in receiving it when we started waiting.</code> 即 waitForEventLocked 方法只有当 <strong>接收到了 Vsync 信号</strong> 且 <strong>至少有一个 Connection 正在等待 Vsync 信号</strong> 才会返回，否则会调用 mCondition.wait&#x2F;wait_for 方法一直等待：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;sp&lt;EventThread::Connection&gt; &gt; EventThread::<span class="built_in">waitForEventLocked</span>(</span><br><span class="line"></span><br><span class="line">        std::unique_lock&lt;std::mutex&gt;* lock, DisplayEventReceiver::Event* event) &#123;</span><br><span class="line"></span><br><span class="line">    Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (signalConnections.<span class="built_in">isEmpty</span>() &amp;&amp; mKeepRunning) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> eventPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> waitForVSync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> vsyncCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">nsecs_t</span> timestamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES; i++) &#123;</span><br><span class="line"></span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// we have a vsync event to dispatch</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mInterceptVSyncsCallback) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">mInterceptVSyncsCallback</span>(timestamp);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                *event = mVSyncEvent[i];</span><br><span class="line"></span><br><span class="line">                mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找正在等待连接的event</span></span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> count = mDisplayEventConnections.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function">sp&lt;Connection&gt; <span class="title">connection</span><span class="params">(mDisplayEventConnections[i].promote())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> added = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 需要 vsync 事件，因为至少有一个连接正在等待vsync</span></span><br><span class="line"></span><br><span class="line">                    waitForVSync = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// we consume the event only if it&#x27;s time (ie: we received a vsync event)</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (connection-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// fired this time around</span></span><br><span class="line"></span><br><span class="line">                            connection-&gt;count = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line"></span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection-&gt;count == <span class="number">1</span> || (vsyncCount % connection-&gt;count) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// continuous event, and time to report it</span></span><br><span class="line"></span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line"></span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 没有vsync事件需要处理但存在pending消息</span></span><br><span class="line"></span><br><span class="line">                    signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++i;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 该连接已死亡则直接移除</span></span><br><span class="line"></span><br><span class="line">                mDisplayEventConnections.<span class="built_in">removeAt</span>(i);</span><br><span class="line"></span><br><span class="line">                --count;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收到 Vsync 事件，但是没有 client 需要它</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">disableVSyncLocked</span>();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Vsync 事件还没到来且至少存在一个 client</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">enableVSyncLocked</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (waitForVSync) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待vsync事件和新的client注册，当vsync发生后，会调用mCondition.notify</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// If the screen is off, we can&#x27;t use h/w vsync, so we</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// use a 16ms timeout instead.  It doesn&#x27;t need to be</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// precise, we just need to keep feeding our clients.</span></span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> softwareSync = mUseSoftwareVSync;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> timeout = softwareSync ? <span class="number">16</span>ms : <span class="number">1000</span>ms;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mCondition.<span class="built_in">wait_for</span>(*lock, timeout) == std::cv_status::timeout) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 线程等待</span></span><br><span class="line"></span><br><span class="line">                mCondition.<span class="built_in">wait</span>(*lock);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到这里，表示存在需要 vsync 的连接以及收到了 vsync 事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下 disableVSyncLocked 和 enableVSyncLocked 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::enableVSyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mUseSoftwareVSync) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// never enable h/w VSYNC when screen is off</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mVsyncEnabled) &#123;</span><br><span class="line"></span><br><span class="line">            mVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setCallback</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setVSyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::disableVSyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVsyncEnabled) &#123;</span><br><span class="line"></span><br><span class="line">        mVsyncEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        mVSyncSource-&gt;<span class="built_in">setVSyncEnabled</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 enableVSyncLocked 和 disableVSyncLocked 这两个方法的作用： <strong>通过 DispSyncSource 同步源向 DispSync 同步模型的 DispSyncThread 线程添加或移除对 DispSync 同步模型中 Vsync 信号的监听器。同时 enableVSyncLocked 方法还通过 DispSyncSource.setCallback 方法设置了在 DispSyncSource 延时源收到来自 DispSync 同步模型的 Vsync 信号后的监听者</strong> 。</p>
<p>Vsync 事件到达后会将其保存在参数 mVSyncEvent 中，如果 timestamp 为 0 则表示没有 Vsync 信号到达。在 mDisplayEventConnections 中保存了注册的监听者，如果 <code>connection-&gt;count &gt;= 0</code> 则表示有监听者对 Vsync 信号感兴趣，于是 将 waitForVSync 置为 true 且将该监听者添加到 signalConnections 集合中。根据源码注释可知 <code>connection.count</code> 的含义如下：</p>
<ul>
<li>count &gt;&#x3D; 1: continuous event. count is the vsync rate – 会持续接收 Vsync 事件</li>
<li>count &#x3D;&#x3D; 0: one-shot event that has not fired – 只接受一次 Vsync 事件，初始化时 count 为 0</li>
<li>count &#x3D;&#x3D; -1: one-shot event that fired this round &#x2F; disabled – 不再接收 Vsync 事件</li>
</ul>
<p>在取得了 timestamp 和 waitForVSync 的值后：</p>
<ul>
<li><strong>若 Vsync 信号已经到达但没有感兴趣的监听者</strong> 则 <strong>通过 disableVSyncLocked 方法移除 DispSyncSource 对 DispSync 同步模型的 Vsync 信号的监听</strong></li>
<li><strong>若有感兴趣的监听者但 Vsync 信号还未达到</strong> 则 <strong>通过 enableVSyncLocked 方法将 DispSyncSource 添加到 DispSync 同步模型的监听者集合</strong></li>
<li><strong>若 Vsync 信号未到达且没有其他等待的事件</strong> 则 <strong>如果 waitForVSync &#x3D;&#x3D; true 则要等待 Vsync 信号(不会无限等待，有超时时间)，否则阻塞当前线程</strong></li>
</ul>
<h3 id="MQ-setEventThread"><a href="#MQ-setEventThread" class="headerlink" title="MQ.setEventThread"></a>MQ.setEventThread</h3><p>接下来 SF 初始化过程中调用了 MessageQueue.setEventThread 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sp&lt;IDisplayEventConnection&gt; mEvents;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::setEventThread</span><span class="params">(android::EventThread* eventThread)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEventThread == eventThread) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEventTube.<span class="built_in">getFd</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;<span class="built_in">removeFd</span>(mEventTube.<span class="built_in">getFd</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line"></span><br><span class="line">    mEvents = eventThread-&gt;<span class="built_in">createEventConnection</span>(); <span class="comment">// 创建连接</span></span><br><span class="line"></span><br><span class="line">    mEvents-&gt;<span class="built_in">stealReceiveChannel</span>(&amp;mEventTube);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mEventTube 是 BitTube 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 mEventTube(BitTube), 一旦有数据到来则调用 cb_eventReceiver 方法</span></span><br><span class="line"></span><br><span class="line">    mLooper-&gt;<span class="built_in">addFd</span>(mEventTube.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;BnDisplayEventConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Connection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gui::BitTube mChannel;</span></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">stealReceiveChannel</span>(gui::BitTube* outChannel) &#123;</span><br><span class="line"></span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Connection 后调用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> EventThread::Connection::<span class="built_in">onFirstRef</span>() &#123;</span><br><span class="line"></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    mDisplayEventConnections.<span class="built_in">add</span>(connection); <span class="comment">// 将 connection 加入连接列表</span></span><br><span class="line"></span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到 MQ.setEventThread 方法创建了一个 Connection 连接且将其加入了 mDisplayEventConnections 列表</strong> 。接着调用 Looper.addFd 方法监听 mEventTube 中的数据，下面看下这个方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::addFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> ident, <span class="type">int</span> events, Looper_callbackFunc callback, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addFd</span>(fd, ident, events, callback ? <span class="keyword">new</span> <span class="built_in">SimpleLooperCallback</span>(callback) : <span class="literal">NULL</span>, data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::addFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> ident, <span class="type">int</span> events, <span class="type">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!callback.<span class="built_in">get</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mAllowNonCallbacks) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Invalid attempt to set NULL callback but not allowed for this looper.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ident &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Invalid attempt to set NULL callback with ident &lt; 0.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        ident = POLL_CALLBACK; <span class="comment">// -2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request;</span><br><span class="line"></span><br><span class="line">    request.fd = fd;</span><br><span class="line"></span><br><span class="line">    request.ident = ident;</span><br><span class="line"></span><br><span class="line">    request.events = events;</span><br><span class="line"></span><br><span class="line">    request.callback = callback;</span><br><span class="line"></span><br><span class="line">    request.data = data;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> requestIndex = mRequests.<span class="built_in">indexOfKey</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123; <span class="comment">// 之前不存在这个request</span></span><br><span class="line"></span><br><span class="line">        mRequests.<span class="built_in">add</span>(fd, request);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 之前存在则替换</span></span><br><span class="line"></span><br><span class="line">        mRequests.<span class="built_in">replaceValueAt</span>(requestIndex, request);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SimpleLooperCallback::<span class="built_in">SimpleLooperCallback</span>(Looper_callbackFunc callback) : <span class="built_in">mCallback</span>(callback) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SimpleLooperCallback::handleEvent</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mCallback</span>(fd, events, data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 Looper.addFd 方法会根据传入的参数创建一个 request 对象，并将其加入 mRequests 列表。接下来会在 poll 方法中取出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pollOnce</span>(timeoutMillis, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis, <span class="type">int</span>* outFd, <span class="type">int</span>* outEvents, <span class="type">void</span>** outData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.<span class="built_in">size</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> Response&amp; response = mResponses.<span class="built_in">itemAt</span>(mResponseIndex++);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> ident = response.request.ident;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123; <span class="comment">// ident &gt;= 0 则返回</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ident;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">pollInner</span>(timeoutMillis);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">        Response&amp; response = mResponses.<span class="built_in">editItemAt</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> fd = response.request.fd;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> events = response.events;</span><br><span class="line"></span><br><span class="line">            <span class="type">void</span>* data = response.request.data;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke the callback.</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> callbackResult = response.request.callback-&gt;<span class="built_in">handleEvent</span>(fd, events, data);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// handleEvent 返回 0 则会移除该 fd, 而在 Choreographer 逻辑中会返回 1 以一直保持 callback</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">removeFd</span>(fd, response.request.seq);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，当调用 addFd 函数时传入的 fd 有数据接收时，则会根据传入的 callback 参数执行不同的逻辑：</p>
<ul>
<li>callback 是一个函数时则 <code>response.request.callback-&gt;handleEvent</code> 直接调用该函数</li>
<li>callback 是一个对象时则 <code>response.request.callback-&gt;handleEvent</code> 调用的是该对象自定义的 handleEvent 方法</li>
</ul>
<h3 id="SurfaceFlinger-run"><a href="#SurfaceFlinger-run" class="headerlink" title="SurfaceFlinger.run"></a>SurfaceFlinger.run</h3><p>在 SurfaceFlinger 初始化完成后会调用其 run 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">// 循环等待事件</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">waitForEvent</span>();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::waitForEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">waitMessage</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::waitMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">        IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">flushCommands</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int32_t</span> ret = mLooper-&gt;<span class="built_in">pollOnce</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 SurfaceFlinger 主线程通过死循环执行 MessageQueue.waitMessage 方法等待消息的到来，其内部调用的便是上面看过的 Looper.pollOnce 方法。</p>
<h3 id="ET-onVSyncEvent"><a href="#ET-onVSyncEvent" class="headerlink" title="ET.onVSyncEvent"></a>ET.onVSyncEvent</h3><p>上面当 DispSync 同步模型产生 Vsync 信号后，会通知 DispSyncSource 源，进而回调监听者(EventThread)的 onVSyncEvent 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::onVSyncEvent</span><span class="params">(<span class="type">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line"></span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.timestamp = timestamp;</span><br><span class="line"></span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line"></span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onVSyncEvent 方法中执行 mCondition.notify_all 唤醒了 EventThread 线程，接着上面 EventThread 线程的逻辑开始看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mKeepRunning) &#123;</span><br><span class="line"></span><br><span class="line">        DisplayEventReceiver::Event event;</span><br><span class="line"></span><br><span class="line">        Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">        signalConnections = <span class="built_in">waitForEventLocked</span>(&amp;lock, &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dispatch events to listeners...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> count = signalConnections.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> sp&lt;Connection&gt;&amp; <span class="title">conn</span><span class="params">(signalConnections[i])</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// now see if we still need to report this event</span></span><br><span class="line"></span><br><span class="line">            <span class="type">status_t</span> err = conn-&gt;<span class="built_in">postEvent</span>(event);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">postEvent</span>(<span class="type">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">DisplayEventReceiver::sendEvents</span><span class="params">(gui::BitTube* dataChannel, Event <span class="type">const</span>* events, <span class="type">size_t</span> count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gui::BitTube::<span class="built_in">sendObjects</span>(dataChannel, events, count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过 BitTube::sendObjects 发送数据，根据前面 addFd 方法的解析，当接收到数据时，会调用 MessageQueue::cb_eventReceiver 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MessageQueue* queue = <span class="built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue-&gt;<span class="built_in">eventReceiver</span>(fd, events);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::<span class="built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line"></span><br><span class="line">                mHandler-&gt;<span class="built_in">dispatchInvalidate</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchInvalidate</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::INVALIDATE));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp; message) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line"></span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line"></span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是进入 SF.onMessageReceived 方法，开始进行图形合成输出逻辑。</p>
<h2 id="图像合成流程"><a href="#图像合成流程" class="headerlink" title="图像合成流程"></a>图像合成流程</h2><h3 id="SF-onMessageReceived"><a href="#SF-onMessageReceived" class="headerlink" title="SF.onMessageReceived"></a>SF.onMessageReceived</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="type">int32_t</span> what)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> frameMissed = !mHadClientComposition &amp;&amp; mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;</span><br><span class="line"></span><br><span class="line">                    (mPreviousPresentFence-&gt;<span class="built_in">getSignalTime</span>() == Fence::SIGNAL_TIME_PENDING);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frameMissed) &#123;</span><br><span class="line"></span><br><span class="line">                mTimeStats.<span class="built_in">incrementMissedFrames</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPropagateBackpressure) &#123;<span class="comment">// 丢帧且Backpressure则跳过此次Transaction和refresh</span></span><br><span class="line"></span><br><span class="line">                    <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> refreshNeeded = <span class="built_in">handleMessageTransaction</span>();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= <span class="built_in">handleMessageInvalidate</span>();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Signal a refresh if a transaction modified the window state, a new buffer was latched, </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// or if HWC has requested a full repaint</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 最终会调用 SF.handleMessageRefresh 方法</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">signalRefresh</span>();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">handleMessageRefresh</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SF-signalLayerUpdate"><a href="#SF-signalLayerUpdate" class="headerlink" title="SF.signalLayerUpdate"></a>SF.signalLayerUpdate</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::signalLayerUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">invalidate</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mEvents 是 EventThread.Connection 类型</span></span><br><span class="line"></span><br><span class="line">    mEvents-&gt;<span class="built_in">requestNextVsync</span>(); <span class="comment">// 请求下一次Vsync信号</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> EventThread::Connection::<span class="built_in">requestNextVsync</span>() &#123;</span><br><span class="line"></span><br><span class="line">    mEventThread-&gt;<span class="built_in">requestNextVsync</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::requestNextVsync</span><span class="params">(<span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mResyncWithRateLimitCallback) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        connection-&gt;count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒EventThread线程</span></span><br><span class="line"></span><br><span class="line">        mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看一下 mResyncWithRateLimitCallback 参数，它是在 SF 初始化创建 EventThread 时传入的， <code>mResyncWithRateLimitCallback()</code> 调用的是 SF.resyncWithRateLimit 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SF 向硬件请求 Vsync 的间隔必须大于 500ns, 否则忽略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::resyncWithRateLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">nsecs_t</span> kIgnoreDelay = <span class="built_in">ms2ns</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">nsecs_t</span> sLastResyncAttempted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now - sLastResyncAttempted &gt; kIgnoreDelay) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">resyncToHardwareVsync</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sLastResyncAttempted = now;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此 signalLayerUpdate 方法的作用是请求接收下一次 Vsync 信号。</p>
<h3 id="SF-handleMessageTransaction"><a href="#SF-handleMessageTransaction" class="headerlink" title="SF.handleMessageTransaction"></a>SF.handleMessageTransaction</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handleMessageTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> transactionFlags = <span class="built_in">peekTransactionFlags</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">handleTransaction</span>(transactionFlags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleTransaction</span><span class="params">(<span class="type">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    transactionFlags = <span class="built_in">getTransactionFlags</span>(eTransactionMask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用每个 Layer 的 doTransaction 方法，处理 layers 的改变</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">handleTransactionLocked</span>(transactionFlags);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SF-handleMessageInvalidate"><a href="#SF-handleMessageInvalidate" class="headerlink" title="SF.handleMessageInvalidate"></a>SF.handleMessageInvalidate</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handleMessageInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the set of layers that need updates -- mLayersWithQueuedFrames.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储需要更新的 layers</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">handlePageFlip</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SF-handleMessageRefresh"><a href="#SF-handleMessageRefresh" class="headerlink" title="SF.handleMessageRefresh"></a>SF.handleMessageRefresh</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> refreshStartTime = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果图层有更新则执行 invalidate 过程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">preComposition</span>(refreshStartTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重建每个显示屏的所有可见的 Layer 列表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 HWComposer 的 Layer</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setUpHWComposer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合成所有 Layer 的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">doComposition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调每个 layer 的 onPostComposition 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">postComposition</span>(refreshStartTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空需要更新的 layers 列表</span></span><br><span class="line"></span><br><span class="line">    mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码过多，篇幅所限，具体的代码不贴出来了，需要的话可以去 SurfaceFlinger.cpp 的源码中查阅。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 SurfaceFlinger 的启动流程中：</p>
<ol>
<li>首先会创建 SurfaceFlinger 对象，在构造器中创建了 DispSync 同步模型对象；</li>
<li>然后执行初始化 SurfaceFlinger 的逻辑：<ul>
<li>注册监听，接收 HWC 的相关事件。</li>
<li>启动 APP 和 SF 的 EventThread 线程，用来管理基于 DispSync 创建的两个 DispSyncSource 延时源对象，分别是用于绘制(app–mEventThreadSource)和合成(SurfaceFlinger–mSfEventThreadSource)。启动了 EventThread 线程后，会一直阻塞在 waitForEventLocked 方法中(期间会根据需要设置监听器)，直到 <strong>接收到 Vsync 信号</strong> 且 <strong>至少有一个连接正在等待 Vsync 信号</strong> 才会继续执行线程逻辑，即通知监听者；</li>
<li>通过 MessageQueue.setEventThread 方法创建了一个连接，并通过 Looper.addFd 方法监听 BitTube 数据。</li>
<li>创建 HWComposer 对象(通过 HAL 层的 HWComposer 硬件模块 或 软件模拟产生 Vsync 信号)， <strong>现在的 Android 系统基本上都可以看成是通过硬件 HWComposer 产生 Vsync 信号，而不使用软件模拟，所以下面解析都只谈及硬件 HWComposer 的 Vsync 信号</strong> ；</li>
<li>初始化非虚拟的显示屏；</li>
<li>启动开机动画服务；</li>
</ul>
</li>
<li>最后执行 SurfaceFlinger.run 逻辑，该方法会在 SurfaceFlinger 主线程通过死循环执行 MessageQueue.waitMessage 方法等待消息的到来，其内部调用了 Looper.pollOnce 方法，该方法会从 Looper.addFd 方法监听的 BitTube 中读取数据，当有数据到来时执行对应的回调方法。</li>
</ol>
<p>当硬件或软件模拟发出 Vsync 信号时：</p>
<ol>
<li>回调 SF 相关方法，SF 调用 DispSync 同步模型的方法处理 Vsync 信号(统计和计算模型的偏移和周期)，并根据返回值判断是否使能&#x2F;关闭 HWC Vsync 信号的发出。</li>
<li>DispSync 根据计算的偏移和周期计算下次 Vsync 信号发生时间，并通知监听者 Vsync 信号到达的事件，传递给 DispSyncSource 延时源，延时源通过 EventThread 来管理 Vsync 信号的收发。</li>
<li>EventThread 调用连接 Connection 对象向 BitTube 发送数据，触发 addFd 函数中设置的回调方法，回调方法进而调用 SF.onMessageReceived 函数，然后进行图像的合成等工作。</li>
</ol>
<p>另一方面，Choreographer 会通过上面创建的 APP 延时源 mEventThreadSource 对象及其对应的 EventThread 线程来监听同步模拟发出的 Vsync 信号，然后进行绘制(measure&#x2F;layout&#x2F;draw)操作。具体逻辑见 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/09/07/Android-Choreographer%E5%8E%9F%E7%90%86/">Android-Choreographer原理</a> 。</p>
<p>将 SurfaceFlinger 的工作流程总结如下图：</p>
<p><img src="/posts/aec64df4/SurfaceFlinger%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="SurfaceFlinger工作流程"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/clippings/" rel="tag"># clippings</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/237b0369/" rel="next" title="Android-Jetpack组件之DataStore">
                <i class="fa fa-chevron-left"></i> Android-Jetpack组件之DataStore
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/a1ae6392/" rel="prev" title="Android-Surface原理解析">
                Android-Surface原理解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">439</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:shenbh@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/ptwenzi?spm=1010.2135.3001.5113" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-clone"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8SurfaceFlinger"><span class="nav-text">启动SurfaceFlinger</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96SurfaceFlinger"><span class="nav-text">实例化SurfaceFlinger</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96SurfaceFlinger"><span class="nav-text">初始化SurfaceFlinger</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91HWC%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83"><span class="nav-text">向HWC注册回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6HWC%E5%9B%9E%E8%B0%83"><span class="nav-text">接收HWC回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EventControlThread"><span class="nav-text">EventControlThread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DispSync%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="nav-text">DispSync同步模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DispSyncSource%E5%BB%B6%E6%97%B6%E6%BA%90"><span class="nav-text">DispSyncSource延时源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EventThread"><span class="nav-text">EventThread</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ET-waitForEventLocked"><span class="nav-text">ET.waitForEventLocked</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MQ-setEventThread"><span class="nav-text">MQ.setEventThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SurfaceFlinger-run"><span class="nav-text">SurfaceFlinger.run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ET-onVSyncEvent"><span class="nav-text">ET.onVSyncEvent</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90%E6%B5%81%E7%A8%8B"><span class="nav-text">图像合成流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SF-onMessageReceived"><span class="nav-text">SF.onMessageReceived</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SF-signalLayerUpdate"><span class="nav-text">SF.signalLayerUpdate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SF-handleMessageTransaction"><span class="nav-text">SF.handleMessageTransaction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SF-handleMessageInvalidate"><span class="nav-text">SF.handleMessageInvalidate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SF-handleMessageRefresh"><span class="nav-text">SF.handleMessageRefresh</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿炳</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('Copied')
          else $(this).text('Copy failed')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>