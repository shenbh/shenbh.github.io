<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="private,Java知识点," />










<meta name="description" content="JVM大纲 JVM参数1234-Xms7000m	【初始化堆大小】-Xmx8192m	【最大堆大小】-XX:PermSize&#x3D;1024m	【[非堆内存]永久代初始大小】-XX:MaxPermSize&#x3D;2048m	【[非堆内存]永久代最大大小】      深入理解Java虚拟机到底是什么 进程是操作系统的执行单位。虚拟机在运行的时候它就是一个操作系统中的进程实例，当它没有在运行时（作为可执行文件存放">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM与性能优化">
<meta property="og:url" content="http://shenbh.github.io/posts/1172390494/index.html">
<meta property="og:site_name" content="YULI">
<meta property="og:description" content="JVM大纲 JVM参数1234-Xms7000m	【初始化堆大小】-Xmx8192m	【最大堆大小】-XX:PermSize&#x3D;1024m	【[非堆内存]永久代初始大小】-XX:MaxPermSize&#x3D;2048m	【[非堆内存]永久代最大大小】      深入理解Java虚拟机到底是什么 进程是操作系统的执行单位。虚拟机在运行的时候它就是一个操作系统中的进程实例，当它没有在运行时（作为可执行文件存放">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://shenbh.github.io/posts/1172390494/%E5%A4%A7%E7%BA%B2-Jvm.png">
<meta property="og:image" content="http://shenbh.github.io/posts/1172390494/JVM%E5%AE%9E%E4%BE%8B%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E6%9C%89%E4%B8%89%E4%B8%AA%E5%AD%90%E7%B3%BB%E7%BB%9F.jpg">
<meta property="og:image" content="http://shenbh.github.io/posts/1172390494/jvm%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://shenbh.github.io/posts/1172390494/jdk%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://shenbh.github.io/posts/1172390494/image-20221227173633256.png">
<meta property="og:image" content="http://shenbh.github.io/posts/1172390494/image-20221227173737947.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235423381-1926278401.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235633553-1910724119.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235555303-769658219.jpg">
<meta property="article:published_time" content="2019-12-27T01:53:33.000Z">
<meta property="article:modified_time" content="2024-04-10T01:52:33.000Z">
<meta property="article:author" content="阿炳">
<meta property="article:tag" content="private">
<meta property="article:tag" content="Java知识点">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://shenbh.github.io/posts/1172390494/%E5%A4%A7%E7%BA%B2-Jvm.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://shenbh.github.io/posts/1172390494/"/>





  <title>JVM与性能优化 | YULI</title><meta name="robots" content="noindex">
  








<meta name="generator" content="Hexo 6.1.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YULI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Just do IT Now.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shenbh.github.io/posts/1172390494/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YULI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JVM与性能优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-27T09:53:33+08:00">
                2019-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JVM大纲"><a href="#JVM大纲" class="headerlink" title="JVM大纲"></a>JVM大纲</h1><p><img src="/posts/1172390494/%E5%A4%A7%E7%BA%B2-Jvm.png" alt="大纲-Jvm"></p>
<h1 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h1><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-Xms7000m	【初始化堆大小】</span></span><br><span class="line"><span class="deletion">-Xmx8192m	【最大堆大小】</span></span><br><span class="line"><span class="deletion">-XX:PermSize=1024m	【[非堆内存]永久代初始大小】</span></span><br><span class="line"><span class="deletion">-XX:MaxPermSize=2048m	【[非堆内存]永久代最大大小】</span></span><br></pre></td></tr></table></figure>





<h1 id="深入理解Java虚拟机到底是什么"><a href="#深入理解Java虚拟机到底是什么" class="headerlink" title="深入理解Java虚拟机到底是什么"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/20380971">深入理解Java虚拟机到底是什么</a></h1><ul>
<li><p>进程是操作系统的执行单位。虚拟机在运行的时候它就是一个操作系统中的进程实例，当它没有在运行时（作为可执行文件存放于文件系统中）可以把它叫做程序。</p>
</li>
<li><p>命令行中一个命令对应的就是一个可执行的二进制文件。</p>
</li>
<li><p>执行Java程序时，真正执行的是一个叫做Java虚拟机的进程，而不是一个个class文件。这个叫做虚拟机的进程处理一些底层的操作，如内存的分配和释放等。–&gt;可将class文件中的信息看做对虚拟机的控制信息，也就是一种虚拟指令。</p>
</li>
<li><p>class文件作为Java虚拟机的原料被输入到Java虚拟机内部，由类加载器这个子系统进行处理。类加载器在运行时<strong>根据需要</strong>加载类</p>
</li>
<li><p>由虚拟机加载的类，加载到内存中后，虚拟机的执行引擎（可看成<em><strong>消化系统</strong></em>）会读取并执行它里面的字节码指令。执行过程还会把各个class文件动态连接起来。</p>
</li>
<li><p>Java虚拟机的自动内存管理，由垃圾收集子系统负责。</p>
</li>
</ul>
<p><img src="/posts/1172390494/JVM%E5%AE%9E%E4%BE%8B%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E6%9C%89%E4%B8%89%E4%B8%AA%E5%AD%90%E7%B3%BB%E7%BB%9F.jpg" alt="JVM实例在运行中有三个子系统"></p>
<h1 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h1><h2 id="jvm工作流程"><a href="#jvm工作流程" class="headerlink" title="jvm工作流程"></a>jvm工作流程</h2><p><img src="/posts/1172390494/jvm%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="jvm工作流程"></p>
<h2 id="jdk结构"><a href="#jdk结构" class="headerlink" title="jdk结构"></a>jdk结构</h2><p><img src="/posts/1172390494/jdk%E7%BB%93%E6%9E%84.png" alt="jdk结构"></p>
<h2 id="运行时数据区（Runtime-Data-Area）"><a href="#运行时数据区（Runtime-Data-Area）" class="headerlink" title="运行时数据区（Runtime Data Area）"></a>运行时数据区（Runtime Data Area）</h2><p><img src="/posts/1172390494/image-20221227173633256.png" alt="运行时数据区"></p>
<table>
<thead>
<tr>
<th>区域</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>每条线程都需要有一个程序计数器，计数器记录的是正在执行的<strong>指令地址</strong>，如果正在执行的是Natvie 方法，这个计数器值为空（Undefined）</td>
</tr>
<tr>
<td>java虚拟机栈</td>
<td>Java方法执行的内存模型，每个方法执行的时候，都会创建一个栈帧用于保存<strong>局部变量表，操作数栈，动态链接，方法出口信息等</strong>。一个方法调用的过程就是一个栈帧从VM栈入栈到出栈的过程</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>与VM栈发挥的作用非常相似，VM栈执行Java方法（字节码）服务，Native方法栈执行的是Native方法服务。</td>
</tr>
<tr>
<td>Java堆</td>
<td>此内存区域唯一的目的就是存放对象实例，几乎所有的对象都在这分配内存</td>
</tr>
<tr>
<td>方法区</td>
<td>方法区是各个内存所共享的内存空间，方法区中主要存放被JVM加载的类信息、常量、静态变量、即时编译后的代码等数据</td>
</tr>
</tbody></table>
<p><img src="/posts/1172390494/image-20221227173737947.png" alt="Java虚拟机栈"></p>
<p>局部变量表：（用的是索引来访问）存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。<strong>对于基本数据类型的变量直接存储它的值；对于引用类型的变量，存储其指向对象的引用</strong>。局部变量表的大小在编译期即可确定其大小，因此在程序执行期局部变量表的大小是不会改变的。</p>
<p><strong>存储内容</strong>：引用对象，returnAddress类型。Long和double类型占用2各局部变量空间，其余的数据类型占据一个。局部变量表空间在编译期完成分配。</p>
<p><strong>操作数栈</strong>：（用的是弹栈&#x2F;压栈来访问）可以理解为java虚拟机栈中的一个用于计算的临时数据存储区。栈最典型的一个应用就是用来<strong>对表达式求值</strong>。一个线程执行方法的过程中，实际就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的<strong>所有计算过程</strong>都是在借助于<strong>操作数栈来完成的</strong>。</p>
<p>每个线程都有个自己的Java栈<strong>线程私有，互不干扰</strong>。</p>
<h2 id="方法指令"><a href="#方法指令" class="headerlink" title="方法指令"></a>方法指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>invokeinterface</td>
<td>用以调用接口方法</td>
</tr>
<tr>
<td>invokevirtual</td>
<td>指令用于调用对象的实例方法</td>
</tr>
<tr>
<td>invokestatic</td>
<td>用以调用类&#x2F;静态方法</td>
</tr>
<tr>
<td>invokespecial</td>
<td>用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法</td>
</tr>
</tbody></table>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><table>
<thead>
<tr>
<th>类加载器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BootstrapClassLoader</td>
<td>Bootstrap类加载器负责加载rt.jar中的JDK类文件，它是所有类加载器的父加载器。Bootstrap类加载器没有任何父类加载器，如果你调用String.class.getClassLoader()，会返回null，任何基于此的代码会抛出NUllPointerException异常。Bootstrap加载器被称为初始类加载器</td>
</tr>
<tr>
<td>ExtClasssLoader</td>
<td>而Extension将加载类的请求先委托给它的父加载器，也就是Bootstrap，如果没有成功加载的话，再从jre&#x2F;lib&#x2F;ext目录下或者java.ext.dirs系统属性定义的目录下加载类。Extension加载器由sun.misc.Launcher$ExtClassLoader实现</td>
</tr>
<tr>
<td>AppClassLoader</td>
<td>第三种默认的加载器就是System类加载器（又叫作Application类加载器）了。它负责从classpath环境变量中加载某些应用相关的类，classpath环境变量通常由-classpath或-cp命令行选项来定义，或者是JAR中的Manifest的classpath属性。Application类加载器是Extension类加载器的子加载器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>工作原理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>委托机制</td>
<td>加载任务委托交给父类加载器，如果不行就向下传递委托任务，由其子类加载器加载，保证java核心库的安全性</td>
</tr>
<tr>
<td>可见性机制</td>
<td>子类加载器可以看到父类加载器加载的类，而反之则不行</td>
</tr>
<tr>
<td>单一性机制</td>
<td>父加载器加载过的类不能被子加载器加载第二次</td>
</tr>
</tbody></table>
<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><ul>
<li>解释执行</li>
</ul>
<blockquote>
<p>源码 –&gt; Parser –&gt; 抽象语法树（AST）–&gt; 解释执行</p>
</blockquote>
<ul>
<li>编译执行</li>
</ul>
<blockquote>
<p>源码 –&gt; 编译&amp;链接 –&gt; 机器指令 –&gt; 在硬件上直接执行</p>
</blockquote>
<ul>
<li>字节码</li>
</ul>
<blockquote>
<p>源码 –&gt; 编译 –&gt; 字节码 –&gt; 在虚拟机上执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">源码--&gt; 编译 --&gt; 字节码((字节码)) --&gt; 在虚拟机上执行</span><br><span class="line">字节码--&gt; JIT --&gt; 机器指令 --&gt; 在硬件上直接执行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">字节码--&gt; Mac虚拟机 --&gt; Mac</span><br><span class="line">字节码--&gt; Linux虚拟机 --&gt; Linux</span><br><span class="line">字节码--&gt; Windows虚拟机 --&gt; Windows</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为解释执行弱点：解释器需要遍历抽象语法树来解释执行，效率非常低，被字节码打败了。</p>
<p>又因为编译执行占据了系统级编程的地盘，操作系统、网络、数据库、虚拟机等核心领域都是。所以无法被字节码替代。</p>
</blockquote>
<h1 id="class文件字节码结构"><a href="#class文件字节码结构" class="headerlink" title="class文件字节码结构"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0248780eae06">class文件字节码结构</a></h1><h2 id="class字节码示例"><a href="#class字节码示例" class="headerlink" title="class字节码示例"></a>class字节码示例</h2><p>如简单的HelloWorld.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用文本编辑器打开HelloWorld.class文件，是这样的</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cafe</span> babe <span class="number">0000</span> <span class="number">0033</span> <span class="number">0022</span> <span class="number">0</span>a00 <span class="number">0600</span> <span class="number">1409</span></span><br><span class="line"><span class="attribute">0015</span> <span class="number">0016</span> <span class="number">0800</span> <span class="number">170</span>a <span class="number">0018</span> <span class="number">0019</span> <span class="number">0700</span> <span class="number">1</span>a07</span><br><span class="line"><span class="attribute">001b</span> <span class="number">0100</span> <span class="number">063</span>c <span class="number">696</span>e <span class="number">6974</span> <span class="number">3</span>e01 <span class="number">0003</span> <span class="number">2829</span></span><br><span class="line"><span class="attribute">5601</span> <span class="number">0004</span> <span class="number">436</span>f <span class="number">6465</span> <span class="number">0100</span> <span class="number">0</span>f4c <span class="number">696</span>e <span class="number">654</span>e</span><br><span class="line"><span class="attribute">756d</span> <span class="number">6265</span> <span class="number">7254</span> <span class="number">6162</span> <span class="number">6</span>c65 <span class="number">0100</span> <span class="number">124</span>c <span class="number">6</span>f63</span><br><span class="line"><span class="attribute">616c</span> <span class="number">5661</span> <span class="number">7269</span> <span class="number">6162</span> <span class="number">6</span>c65 <span class="number">5461</span> <span class="number">626</span>c <span class="number">6501</span></span><br><span class="line"><span class="attribute">0004</span> <span class="number">7468</span> <span class="number">6973</span> <span class="number">0100</span> <span class="number">264</span>c <span class="number">636</span>f <span class="number">6</span>d2f <span class="number">6578</span></span><br><span class="line"><span class="attribute">616d</span> <span class="number">706</span>c <span class="number">652</span>f <span class="number">6</span>d79 <span class="number">6170</span> <span class="number">706</span>c <span class="number">6963</span> <span class="number">6174</span></span><br><span class="line"><span class="attribute">696f</span> <span class="number">6</span>e2f <span class="number">4865</span> <span class="number">6</span>c6c <span class="number">6</span>f57 <span class="number">6</span>f72 <span class="number">6</span>c64 <span class="number">3</span>b01</span><br><span class="line"><span class="attribute">0004</span> <span class="number">6</span>d61 <span class="number">696</span>e <span class="number">0100</span> <span class="number">1628</span> <span class="number">5</span>b4c <span class="number">6</span>a61 <span class="number">7661</span></span><br><span class="line"><span class="attribute">2f6c</span> <span class="number">616</span>e <span class="number">672</span>f <span class="number">5374</span> <span class="number">7269</span> <span class="number">6</span>e67 <span class="number">3</span>b29 <span class="number">5601</span></span><br><span class="line"><span class="attribute">0004</span> <span class="number">6172</span> <span class="number">6773</span> <span class="number">0100</span> <span class="number">135</span>b <span class="number">4</span>c6a <span class="number">6176</span> <span class="number">612</span>f</span><br><span class="line"><span class="attribute">6c61</span> <span class="number">6</span>e67 <span class="number">2</span>f53 <span class="number">7472</span> <span class="number">696</span>e <span class="number">673</span>b <span class="number">0100</span> <span class="number">0</span>a53</span><br><span class="line"><span class="attribute">6f75</span> <span class="number">7263</span> <span class="number">6546</span> <span class="number">696</span>c <span class="number">6501</span> <span class="number">000</span>f <span class="number">4865</span> <span class="number">6</span>c6c</span><br><span class="line"><span class="attribute">6f57</span> <span class="number">6</span>f72 <span class="number">6</span>c64 <span class="number">2</span>e6a <span class="number">6176</span> <span class="number">610</span>c <span class="number">0007</span> <span class="number">0008</span></span><br><span class="line"><span class="attribute">0700</span> <span class="number">1</span>c0c <span class="number">001</span>d <span class="number">001</span>e <span class="number">0100</span> <span class="number">0</span>c48 <span class="number">656</span>c <span class="number">6</span>c6f</span><br><span class="line"><span class="attribute">2057</span> <span class="number">6</span>f72 <span class="number">6</span>c64 <span class="number">2107</span> <span class="number">001</span>f <span class="number">0</span>c00 <span class="number">2000</span> <span class="number">2101</span></span><br><span class="line"><span class="attribute">0024</span> <span class="number">636</span>f <span class="number">6</span>d2f <span class="number">6578</span> <span class="number">616</span>d <span class="number">706</span>c <span class="number">652</span>f <span class="number">6</span>d79</span><br><span class="line"><span class="attribute">6170</span> <span class="number">706</span>c <span class="number">6963</span> <span class="number">6174</span> <span class="number">696</span>f <span class="number">6</span>e2f <span class="number">4865</span> <span class="number">6</span>c6c</span><br><span class="line"><span class="attribute">6f57</span> <span class="number">6</span>f72 <span class="number">6</span>c64 <span class="number">0100</span> <span class="number">106</span>a <span class="number">6176</span> <span class="number">612</span>f <span class="number">6</span>c61</span><br><span class="line"><span class="attribute">6e67</span> <span class="number">2</span>f4f <span class="number">626</span>a <span class="number">6563</span> <span class="number">7401</span> <span class="number">0010</span> <span class="number">6</span>a61 <span class="number">7661</span></span><br><span class="line"><span class="attribute">2f6c</span> <span class="number">616</span>e <span class="number">672</span>f <span class="number">5379</span> <span class="number">7374</span> <span class="number">656</span>d <span class="number">0100</span> <span class="number">036</span>f</span><br><span class="line"><span class="attribute">7574</span> <span class="number">0100</span> <span class="number">154</span>c <span class="number">6</span>a61 <span class="number">7661</span> <span class="number">2</span>f69 <span class="number">6</span>f2f <span class="number">5072</span></span><br><span class="line"><span class="attribute">696e</span> <span class="number">7453</span> <span class="number">7472</span> <span class="number">6561</span> <span class="number">6</span>d3b <span class="number">0100</span> <span class="number">136</span>a <span class="number">6176</span></span><br><span class="line"><span class="attribute">612f</span> <span class="number">696</span>f <span class="number">2</span>f50 <span class="number">7269</span> <span class="number">6</span>e74 <span class="number">5374</span> <span class="number">7265</span> <span class="number">616</span>d</span><br><span class="line"><span class="attribute">0100</span> <span class="number">0770</span> <span class="number">7269</span> <span class="number">6</span>e74 <span class="number">6</span>c6e <span class="number">0100</span> <span class="number">1528</span> <span class="number">4</span>c6a</span><br><span class="line"><span class="attribute">6176</span> <span class="number">612</span>f <span class="number">6</span>c61 <span class="number">6</span>e67 <span class="number">2</span>f53 <span class="number">7472</span> <span class="number">696</span>e <span class="number">673</span>b</span><br><span class="line"><span class="attribute">2956</span> <span class="number">0021</span> <span class="number">0005</span> <span class="number">0006</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0002</span> <span class="number">0001</span></span><br><span class="line"><span class="attribute">0007</span> <span class="number">0008</span> <span class="number">0001</span> <span class="number">0009</span> <span class="number">0000</span> <span class="number">002</span>f <span class="number">0001</span> <span class="number">0001</span></span><br><span class="line"><span class="attribute">0000</span> <span class="number">0005</span> <span class="number">2</span>ab7 <span class="number">0001</span> b100 <span class="number">0000</span> <span class="number">0200</span> <span class="number">0</span>a00</span><br><span class="line"><span class="attribute">0000</span> <span class="number">0600</span> <span class="number">0100</span> <span class="number">0000</span> <span class="number">0</span>a00 <span class="number">0</span>b00 <span class="number">0000</span> <span class="number">0</span>c00</span><br><span class="line"><span class="attribute">0100</span> <span class="number">0000</span> <span class="number">0500</span> <span class="number">0</span>c00 <span class="number">0</span>d00 <span class="number">0000</span> <span class="number">0900</span> <span class="number">0</span>e00</span><br><span class="line"><span class="attribute">0f00</span> <span class="number">0100</span> <span class="number">0900</span> <span class="number">0000</span> <span class="number">3700</span> <span class="number">0200</span> <span class="number">0100</span> <span class="number">0000</span></span><br><span class="line"><span class="attribute">09b2</span> <span class="number">0002</span> <span class="number">1203</span> b600 <span class="number">04</span>b1 <span class="number">0000</span> <span class="number">0002</span> <span class="number">000</span>a</span><br><span class="line"><span class="attribute">0000</span> <span class="number">000</span>a <span class="number">0002</span> <span class="number">0000</span> <span class="number">000</span>c <span class="number">0008</span> <span class="number">000</span>d <span class="number">000</span>b</span><br><span class="line"><span class="attribute">0000</span> <span class="number">000</span>c <span class="number">0001</span> <span class="number">0000</span> <span class="number">0009</span> <span class="number">0010</span> <span class="number">0011</span> <span class="number">0000</span></span><br><span class="line"><span class="attribute">0001</span> <span class="number">0012</span> <span class="number">0000</span> <span class="number">0002</span> <span class="number">0013</span> </span><br></pre></td></tr></table></figure>

<p>利用 <code>javap -verbose HelloWorld.class</code>：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Last modified <span class="number">2021</span><span class="number">-1</span><span class="number">-7</span>; size <span class="number">586</span> <span class="built_in">bytes</span></span><br><span class="line">  MD5 checksum bf91e508b76a0dc7d4c0250b0e55f75b</span><br><span class="line">  Compiled from <span class="string">&quot;HelloWorld.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> class com.example.myapplication.HelloWorld</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">51</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#20         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #2 = Fieldref           #21.#22        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #3 = <span class="built_in">String</span>             #23            <span class="comment">// Hello World!</span></span><br><span class="line">   #4 = Methodref          #24.#25        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #5 = Class              #26            <span class="comment">// com/example/myapplication/HelloWorld</span></span><br><span class="line">   #6 = Class              #27            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/example/myapplication/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               (<span class="meta">[</span>Ljava/lang/<span class="built_in">String</span>;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               <span class="meta">[</span>Ljava/lang/<span class="built_in">String</span>;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #21 = Class              #28            <span class="comment">// java/lang/System</span></span><br><span class="line">  #22 = NameAndType        #29:#30        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #23 = Utf8               Hello World!</span><br><span class="line">  #24 = Class              #31            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #25 = NameAndType        #32:#33        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #26 = Utf8               com/example/myapplication/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/<span class="built_in">String</span>;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.example.myapplication.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      <span class="built_in">stack</span>=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #1                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  this   Lcom/example/myapplication/HelloWorld;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> static <span class="literal">void</span> main(java.lang.<span class="built_in">String</span><span class="meta">[</span><span class="meta">]</span>);</span><br><span class="line">    descriptor: (<span class="meta">[</span>Ljava/lang/<span class="built_in">String</span>;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      <span class="built_in">stack</span>=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #2                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #3                  <span class="comment">// String Hello World!</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #4                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   <span class="meta">[</span>Ljava/lang/<span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;HelloWorld.java&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>.class文件是一组以8位字节为基础单位的二进制流，每个数据严格按顺序排列在.class文件中，中间没有任何分隔符</p>
</blockquote>
<p><code>.class</code>具体数值以及解释</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th>名称</th>
<th>解释</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u4</td>
<td>magic</td>
<td>魔数</td>
<td>1</td>
</tr>
<tr>
<td align="center">u2</td>
<td>minor_version</td>
<td>次版本号</td>
<td>1</td>
</tr>
<tr>
<td align="center">u2</td>
<td>major_version</td>
<td>主版本号</td>
<td>1</td>
</tr>
<tr>
<td align="center">u2</td>
<td>constant_pool_count</td>
<td>常量池常量个数</td>
<td>1</td>
</tr>
<tr>
<td align="center">cp_info</td>
<td>constant_pool</td>
<td>常量池</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td align="center">u2</td>
<td>access_flags</td>
<td>访问标记</td>
<td>1</td>
</tr>
<tr>
<td align="center">u2</td>
<td>this_class</td>
<td>类索引</td>
<td>1</td>
</tr>
<tr>
<td align="center">u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>1</td>
</tr>
<tr>
<td align="center">u2</td>
<td>interfaces_count</td>
<td>接口索引数量</td>
<td>1</td>
</tr>
<tr>
<td align="center">u2</td>
<td>interfaces</td>
<td>接口内容</td>
<td>interfaces_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td>field_count</td>
<td>字段表字段数量</td>
<td>1</td>
</tr>
<tr>
<td align="center">field_info</td>
<td>fields</td>
<td>字段表</td>
<td>field_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td>methods_count</td>
<td>方发表方法数量</td>
<td>1</td>
</tr>
<tr>
<td align="center">method_info</td>
<td>methods</td>
<td>方法表</td>
<td>methods_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td>attributes_count</td>
<td>属性表属性数量</td>
<td>1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<h2 id="jvm类的加载机制"><a href="#jvm类的加载机制" class="headerlink" title="jvm类的加载机制"></a>jvm类的加载机制</h2><h3 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h3><p>jvm虚拟机规范中没有规定加载的时机，但是有以下5种情况的要立即对类进行初始化：</p>
<ol>
<li><p>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这4条字节码指定时，若类没有进行过初始化，则会触发初始化。</p>
<p>生成这4条指令最常见的场景：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入到常量池的静态字段除外）以及调用一个类的静态方法的时候。</p>
</li>
<li><p>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候</p>
</li>
<li><p>当初始化一个类的时候，发现其父类未被初始化过，则先触发其父类的初始化</p>
</li>
<li><p>当虚拟机启动时，用户需指定一个要执行的主类（包含<code>main()</code>方法的类），虚拟机会先初始化这个主类。</p>
</li>
<li><p>当使用 JDK1.7 的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invodeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。</p>
</li>
</ol>
<h3 id="类的加载流程"><a href="#类的加载流程" class="headerlink" title="类的加载流程"></a>类的加载流程</h3><p>类的加载流程大致有5个步骤：加载、验证、准备、解析和初始化。</p>
<blockquote>
<p>invokestatic：用于调用静态方法<br>invokespecial：用于调用私有实例方法、构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法<br>invokevirtual：用于调用非私有实例方法。<br>invokeinterface：用于调用接口方法。<br>invokedynamic：用于调用动态方法。</p>
</blockquote>
<h1 id="JVM-与性能优化"><a href="#JVM-与性能优化" class="headerlink" title="JVM 与性能优化"></a>JVM 与性能优化</h1><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a><a target="_blank" rel="noopener" href="https://juejin.im/post/5e020808e51d4558181d3cf5">原文链接</a></h2><p>《JVM 与性能优化》</p>
<h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><h3 id="1-虚拟机的历史"><a href="#1-虚拟机的历史" class="headerlink" title="1. 虚拟机的历史"></a>1. 虚拟机的历史</h3><h3 id="2-未来Java技术一览"><a href="#2-未来Java技术一览" class="headerlink" title="2. 未来Java技术一览"></a>2. 未来Java技术一览</h3><h3 id="3-运行时区数据"><a href="#3-运行时区数据" class="headerlink" title="3. 运行时区数据"></a>3. 运行时区数据</h3><p>各个区域的作用</p>
<p><strong>1. 程序计数器</strong></p>
<p>当前线程执行的字节码的行号指示器，占用空间小，也无法干涉<br><strong>2. 栈</strong></p>
<p>每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息，然后放入栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈帧。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。<br>栈帧大小缺省为 1M，可用参数-Xss 调整大小，例如-Xss256k<br><strong>3. 堆</strong></p>
<p>几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Xms：堆的最小值</span><br><span class="line">-Xmx：堆的最大值</span><br><span class="line">-Xmn：新生代的大小</span><br><span class="line">-XX：NewSize：新生代最小值</span><br><span class="line">-XX：MaxNewSize：新生代最大值</span><br></pre></td></tr></table></figure>
<p>例如-Xmx256m</p>
<p><strong>4. 方法区（线程共享）</strong></p>
<ol>
<li>用于存储已经被虚拟机加载的类信息、常量(“zdy”,”123”等)、静态变量(static 变量)等数据，可用以下参数调整：<br> jdk1.7 及以前：-XX:PermSize; -XX:MaxPermSize<br> jdk1.8以后：-XX:MetaspaceSize; -XX:MaxMetaspaceSize<br> jdk1.8以后大小就只受本机总内存的限制，如 -XX:MaxMetaspaceSize&#x3D;3M</li>
<li>运行时常量池<br>各个版本内存区域的变化</li>
</ol>
<ul>
<li>1.6 运行时常量池在方法区</li>
<li>1.7 运行时常量池在堆</li>
<li>1.8 运行时常量池在元数据区</li>
</ul>
<ol start="3">
<li>直接内存（线程共享）<br>不是虚拟机运行时数据区的一部分，也不是 java 虚拟机规范中定义的内存区域；如果使用了 NIO(使用 native 函数库直接分配堆外内存，不经过 JVM 内存直接访问系统物理内存的类–DirectBuffer)，这块区域会被频繁使用，在 java 堆内可以用 directByteBuffer 对象直接引用并操作；这块内存不受 java 堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize 来设置(默认与堆内存最大值一样)，所以也会有 OOM 的异常。</li>
</ol>
<h3 id="4-站在线程角度来看堆和栈"><a href="#4-站在线程角度来看堆和栈" class="headerlink" title="4. 站在线程角度来看堆和栈"></a>4. 站在线程角度来看堆和栈</h3><h3 id="5-深入辨析堆和栈"><a href="#5-深入辨析堆和栈" class="headerlink" title="5. 深入辨析堆和栈"></a>5. 深入辨析堆和栈</h3><ul>
<li><p>功能</p>
<ul>
<li>以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、float、long、byte、float、double、boolean、char等）以及对象的引用变量，其内存分配在栈上，变量出了作用域会自动释放。</li>
<li>堆内存用来存储 Java 中的对象。无论是成员变量、局部变量、类变量，它们指向的对象都存储在堆内存中。</li>
</ul>
</li>
<li><p>线程独享还是共享</p>
<ul>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。</li>
<li>堆内存中对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>
</ul>
</li>
<li><p>空间大小<br>栈的内存远小于堆内存</p>
</li>
</ul>
<h3 id="6-方法的出入栈"><a href="#6-方法的出入栈" class="headerlink" title="6. 方法的出入栈"></a>6. 方法的出入栈</h3><ol>
<li>栈帧</li>
</ol>
<p>一个方法的调用就会在栈上分配一个栈帧</p>
<ol start="2">
<li>栈上分配</li>
</ol>
<p>虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处就是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。</p>
<p>栈上分配需要的技术基础：逃逸分析。逃逸分析的目的是判断对象的作用域是否逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定属于逃逸对象。</p>
<p>栈上分配的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的 User 的对象实例，分配 100,000,000次，启用栈上分配只需 6ms，不启用要 3s</p>
<h3 id="7-虚拟机中的对象"><a href="#7-虚拟机中的对象" class="headerlink" title="7. 虚拟机中的对象"></a>7. 虚拟机中的对象</h3><p><strong>分配过程</strong></p>
<p>虚拟机遇到一条 new 指令时相应的类加载过程：</p>
<ol>
<li>如何划分可用空间（虚拟机将为新生对象分配内存）：</li>
</ol>
<ul>
<li>若 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲控件那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”</li>
<li>若 Java 堆中内存并不是规整的，已使用的内存和空闲的相互交错，那没办吧进行简单的指针碰撞。虚拟机需要维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的控件划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”</li>
<li>Java 堆是否规整取决于所采用的垃圾收集器是否带有压缩整理功能决定。</li>
</ul>
<ol start="2">
<li>在并发情况下的线程安全问题</li>
<li>创建对象在虚拟机中是非常频繁的行为，即时只是修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象 A 分配内存，指针还未来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。<br>解决方案：</li>
</ol>
<ul>
<li>一种是堆分配内存空间的动作进行同步处理–实际上虚拟机采用CAS 配上失败重试的方式保证更新操作的原子性</li>
<li>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），如果设置了虚拟机参数-XX:UseTLAB，在线程初始化时，也会同时申请一块指定大小的内存，只给当前线程使用，这样每个线程都有属于自己的 Buffer。当 Buffer 容量不够的情况再重新从 Eden 区域申请一块继续使用。<br>TLAB 目的是在给新对象分配内存空间时，让每个 Java 应用线程在使用自己专属的分配指针来分配空间，减少了同步开销。<br>TLAB 让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其他线程无法在这个区域分配而已，当一个 TLAB 用满（分配指针 top 撞上分配极限 end 了），就新申请一个 TLAB</li>
</ul>
<ol start="3">
<li>分配完内存，虚拟机会将分配到的内存空间都初始化为零值（如 int 值为 0，boolean 值为 false）</li>
<li>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头之中。</li>
<li>上面工作完成了，从虚拟机视角看一个新对象已经产生了，但从 Java 程序员视角看对象才刚刚开始，所有字段值都为零值，还需要完成程序员意愿的初始化工作。</li>
</ol>
<p><strong>内存布局</strong></p>
<p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为3 个区域：对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)<br>对象头包括两部分信息：</p>
<ul>
<li>一是存储对象自身运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等；</li>
<li>另一是类型指针，即对象指向它类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求对对象的大小必须是 8 字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。</li>
</ul>
<p><strong>对象的访问定位</strong></p>
<p>Java 程序通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。<br>使用句柄：那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br>使用直接指针访问：reference 中存储的就是对象地址。<br>两种方式各有优势：</p>
<ul>
<li>使用句柄最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
<li>使用直接指针最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。<br>对于 Sun HotSpot 而言，使用的就是直接指针访问方式进行对象访问的。</li>
</ul>
<h3 id="8-堆参数设置和内存溢出实战"><a href="#8-堆参数设置和内存溢出实战" class="headerlink" title="8. 堆参数设置和内存溢出实战"></a>8. 堆参数设置和内存溢出实战</h3><ol>
<li>Java堆溢出</li>
<li>新生代配置</li>
<li>方法区和运行时常量池溢出</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>本机直接内存溢出</li>
</ol>
<h2 id="垃圾回收器和内存分配策略"><a href="#垃圾回收器和内存分配策略" class="headerlink" title="垃圾回收器和内存分配策略"></a>垃圾回收器和内存分配策略</h2><h3 id="1-GC概述"><a href="#1-GC概述" class="headerlink" title="1. GC概述"></a>1. GC概述</h3><h3 id="2-判断对象的存活"><a href="#2-判断对象的存活" class="headerlink" title="2. 判断对象的存活"></a>2. 判断对象的存活</h3><p><strong>1. 引用计数法</strong></p>
<p>优点：快、方便、实现简单。缺点：对象相互引用时，很难判断对象是否该回收。</p>
<p><strong>2. 可达性分析</strong></p>
<p>来判断对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用连（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的（可被回收）。</p>
<p>作为 GC Roots 的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ol>
<h3 id="3-辨析强、弱等各种应用"><a href="#3-辨析强、弱等各种应用" class="headerlink" title="3. 辨析强、弱等各种应用"></a>3. 辨析强、弱等各种应用</h3><ul>
<li><p>强引用</p>
</li>
<li><p>软引用 SoftReference</p>
</li>
</ul>
<p> 一些有用但是并非必需。当将要发生 OMM 之前这些软引用对象会被回收</p>
<ul>
<li>弱引用 WeakReference</li>
</ul>
<p> 一些有用但是并非必需。当 GC 发生时，必定会被回收</p>
<ul>
<li>虚引用 PhantomReference</li>
</ul>
<p> 幽灵引用，最弱。被垃圾回收时会受到一个通知</p>
<h3 id="4-GC算法"><a href="#4-GC算法" class="headerlink" title="4. GC算法"></a>4. GC算法</h3><p><strong>1. 标记-清除算法</strong></p>
<p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p><strong>2. 复制算法</strong></p>
<p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存用完了就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半。</p>
<p><strong>3. 标记-整理算法</strong></p>
<p>首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h3 id="5-分代收集"><a href="#5-分代收集" class="headerlink" title="5. 分代收集"></a>5. 分代收集</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br>专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<h3 id="6-Stop-The-World现象"><a href="#6-Stop-The-World现象" class="headerlink" title="6. Stop The World现象"></a>6. Stop The World现象</h3><p>GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数</p>
<h3 id="7-GC日志解读"><a href="#7-GC日志解读" class="headerlink" title="7. GC日志解读"></a>7. GC日志解读</h3><h3 id="8-内存分配与回收策略"><a href="#8-内存分配与回收策略" class="headerlink" title="8. 内存分配与回收策略"></a>8. 内存分配与回收策略</h3><p>   对象优先在Eden分配，如果说Eden内存空间不足，就会发生Minor GC<br>   大对象直接进入老年代，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组，1、导致内存有空间，还是需要提前进行垃圾回收获取连续空间来放他们，2、会进行大量的内存复制。<br>   -XX:PretenureSizeThreshold 参数 ，大于这个数量直接在老年代分配，缺省为0 ，表示绝不会直接分配在老年代。<br>   长期存活的对象将进入老年代，默认15岁，-XX:MaxTenuringThreshold调整<br>   动态对象年龄判定，为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄<br>   空间分配担保：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代.只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC。</p>
<h3 id="9-内存泄露和内存溢出辨析"><a href="#9-内存泄露和内存溢出辨析" class="headerlink" title="9. 内存泄露和内存溢出辨析"></a>9. 内存泄露和内存溢出辨析</h3><p>内存溢出：实实在在的内存空间不足导致；<br>内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下。</p>
<h3 id="10-JDK为我们提供的工具"><a href="#10-JDK为我们提供的工具" class="headerlink" title="10. JDK为我们提供的工具"></a>10. JDK为我们提供的工具</h3><ul>
<li><p>jps<br>列出当前机器上正在运行的虚拟机进程<br>-p  :仅仅显示VM 标示，不显示jar,class, main参数等信息.<br>-m:输出主函数传入的参数. 下的hello 就是在执行程序时从命令行输入的参数<br>-l: 输出应用程序主类完整package名称或jar完整名称.<br>-v: 列出jvm参数, -Xms20m -Xmx50m是启动程序指定的jvm参数</p>
</li>
<li><p>jstat<br>是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。<br>假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat-gc 2764 250 20<br>常用参数：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-class (类加载器) </span></span><br><span class="line"><span class="deletion">-compiler (JIT) </span></span><br><span class="line"><span class="deletion">-gc (GC堆状态) </span></span><br><span class="line"><span class="deletion">-gccapacity (各区大小) </span></span><br><span class="line"><span class="deletion">-gccause (最近一次GC统计和原因) </span></span><br><span class="line"><span class="deletion">-gcnew (新区统计)</span></span><br><span class="line"><span class="deletion">-gcnewcapacity (新区大小)</span></span><br><span class="line"><span class="deletion">-gcold (老区统计)</span></span><br><span class="line"><span class="deletion">-gcoldcapacity (老区大小)</span></span><br><span class="line"><span class="deletion">-gcpermcapacity (永久区大小)</span></span><br><span class="line"><span class="deletion">-gcutil (GC统计汇总)</span></span><br><span class="line"><span class="deletion">-printcompilation (HotSpot编译统计)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>jinfo<br>查看和修改虚拟机的参数</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jinfo </span>–sysprops 可以查看由System.getProperties()取得的参数</span><br><span class="line"><span class="keyword">jinfo </span>–flag 未被显式指定的参数的系统默认值</span><br><span class="line"><span class="keyword">jinfo </span>–flags（注意s）显示虚拟机的参数</span><br><span class="line"><span class="keyword">jinfo </span>–flag +[参数] 可以增加参数，但是仅限于由<span class="keyword">java </span>-XX:+PrintFlagsFinal –version查询出来且 </span><br><span class="line">为manageable的参数</span><br><span class="line"><span class="keyword">jinfo </span>–flag -[参数] 可以去除参数</span><br></pre></td></tr></table></figure>
</li>
<li><p>jmap<br>用于生成堆转储快照（一般称为heapdump或dump文件）。jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux&#x2F;Solaris下使用。<br>jmap -dump:live,format&#x3D;b,file&#x3D;heap.bin &lt;pid<br>Sun JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。</p>
</li>
<li><p>jhat<br>jhat dump文件名<br>后屏幕显示“Server is ready.”的提示后，用户在浏览器中键入<code>http://localhost：7000/就可以访问详情</code></p>
</li>
<li><p>jstack<br>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。<br>在代码中可以用java.lang.Thread类的getAllStackTraces（）方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。</p>
</li>
</ul>
<p>管理远程进程需要在远程程序的启动参数中增加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Djava.rmi.server.hostname=…..</span><br><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">-Dcom.sun.management.jmxremote.port=<span class="number">8888</span></span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span></span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="11-了解MAT"><a href="#11-了解MAT" class="headerlink" title="11. 了解MAT"></a>11. 了解MAT</h3><ul>
<li>浅堆和深堆<br><strong>浅堆</strong> :（Shallow Heap）是指一个对象所消耗的内存。例如，在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。<br><strong>深堆</strong> ：这个对象被GC回收后，可以真实释放的内存大小，也就是只能通过对象被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象所持有的对象的集合。深堆是指对象的保留集中所有的对象的浅堆大小之和。<br>__举例__：对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内</li>
</ul>
<h3 id="12-垃圾回收器"><a href="#12-垃圾回收器" class="headerlink" title="12. 垃圾回收器"></a>12. 垃圾回收器</h3><ol>
<li>垃圾回收器概览<br>Serial&#x2F;Serial Old、ParNew 、Parallel Scavenge（ParallerGC）&#x2F;Parallel Old、Concurrent Mark Sweep （CMS）、G1</li>
<li>垃圾回收器工作详解</li>
<li>G1详解</li>
<li>未来的垃圾回收<br>ZGC通过技术手段把stw的情况控制在仅有一次，就是第一次的初始标记才会发生，这样也就不难理解为什么GC停顿时间不随着堆增大而上升了，再大我也是通过并发的时间去回收了<br>关键技术<ol>
<li><pre><code>有色指针（Colored Pointers）
</code></pre>
<ol start="2">
<li><pre><code>加载屏障（Load Barrier）
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="JVM执行子系统"><a href="#JVM执行子系统" class="headerlink" title="JVM执行子系统"></a>JVM执行子系统</h2><h3 id="1-Class类文件本质"><a href="#1-Class类文件本质" class="headerlink" title="1. Class类文件本质"></a>1. Class类文件本质</h3><ol>
<li>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石，也是语言无关性的基础。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</li>
<li>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。<br> Class文件是<strong>一组以8位字节为基础单位的二进制流</strong>。</li>
</ol>
<h3 id="2-Class文件格式"><a href="#2-Class文件格式" class="headerlink" title="2. Class文件格式"></a>2. Class文件格式</h3><p>  各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。<br>  Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数和表</strong>。<br>  无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。<br>  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件<strong>本质上就是一张表</strong>。</p>
<p><strong>1. 格式详解</strong></p>
<p>   Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。按顺序包括：</p>
<ul>
<li>魔数与Class文件的版本</li>
</ul>
<pre><code>每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。
紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。
</code></pre>
<ul>
<li>常量池</li>
</ul>
<pre><code>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的
常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。
字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。
而符号引用则属于编译原理方面的概念，包括了下面三类常量：
类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符
</code></pre>
<ul>
<li>访问标志</li>
</ul>
<pre><code>用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等
</code></pre>
<ul>
<li>类索引、父类索引与接口索引集合</li>
</ul>
<pre><code>这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中
</code></pre>
<ul>
<li>字段表集合</li>
</ul>
<pre><code>描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量。
而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。
字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。
</code></pre>
<ul>
<li>方法表集合</li>
</ul>
<pre><code>描述了方法的定义，但是方法里的Java代码，经过编译器编译成字节码指令后，存放在属性表集合中的方法属性表集合中一个名为“Code”的属性里面。
与字段表集合相类似的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”
</code></pre>
<ul>
<li>属性表集合</li>
</ul>
<p>  存储Class文件、字段表、方法表都自己的属性表集合，以用于描述某些场景专有的信息。如方法的代码就存储在Code属性表中。</p>
<h3 id="3-字节码指令"><a href="#3-字节码指令" class="headerlink" title="3. 字节码指令"></a>3. 字节码指令</h3><ul>
<li>悉知</li>
</ul>
<pre><code>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。
由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256条。
大多数的指令都包含了其操作所对应的数据类型信息。例如：
iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。
大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型
阅读字节码作为了解Java虚拟机的基础技能，请熟练掌握。请熟悉并掌握常见指令即可。
</code></pre>
<ul>
<li>加载和存储指令</li>
</ul>
<pre><code>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容。
将一个局部变量加载到操作栈：iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_＜n＞、dload、dload_＜n＞、aload、aload_＜n＞。
将一个数值从操作数栈存储到局部变量表：istore、istore_＜n＞、lstore、lstore_＜n＞、fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞。
将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞。
扩充局部变量表的访问索引的指令：wide。
</code></pre>
<ul>
<li>运算或算术指令</li>
</ul>
<pre><code>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。
加法指令：iadd、ladd、fadd、dadd。
减法指令：isub、lsub、fsub、dsub。
乘法指令：imul、lmul、fmul、dmul等等
</code></pre>
<ul>
<li>类型转换指令</li>
</ul>
<pre><code>可以将两种不同的数值类型进行相互转换，
Java虚拟机直接支持以下数值类型的宽化类型转换（即小范围类型向大范围类型的安全转换）：
int类型到long、float或者double类型。
long类型到float、double类型。
float类型到double类型。
处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。
</code></pre>
<ul>
<li>创建类实例的指令</li>
</ul>
<pre><code>new
</code></pre>
<ul>
<li>创建数组的指令</li>
</ul>
<pre><code>newarray、anewarray、multianewarray
</code></pre>
<ul>
<li>访问字段指令</li>
</ul>
<pre><code>getfield、putfield、getstatic、putstatic
</code></pre>
<ul>
<li>数组存取相关指令</li>
</ul>
<pre><code>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。
将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。
取数组长度的指令：arraylength。
</code></pre>
<ul>
<li>检查类实例类型的指令</li>
</ul>
<pre><code>instanceof、checkcast
</code></pre>
<p>   *操作数栈管理指令<br>  如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：将操作数栈的栈顶一个或两个元素出栈：pop、pop2。<br>  复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。<br>  将栈最顶端的两个数值互换：swap</p>
<ul>
<li>控制转移指令</li>
</ul>
<pre><code>控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令如下。
条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。
复合条件分支：tableswitch、lookupswitch。
无条件分支：goto、goto_w、jsr、jsr_w、ret。
</code></pre>
<ul>
<li>方法调用指令</li>
</ul>
<pre><code>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。
invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
invokestatic指令用于调用类方法（static方法）。
invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。
方法调用指令与数据类型无关。
</code></pre>
<ul>
<li>方法返回指令</li>
</ul>
<pre><code>是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。
</code></pre>
<ul>
<li>异常处理指令</li>
</ul>
<pre><code>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现
</code></pre>
<ul>
<li>同步指令</li>
</ul>
<p>  有monitorenter和monitorexit两条指令来支持synchronized关键字的语义</p>
<h3 id="4-类加载机制"><a href="#4-类加载机制" class="headerlink" title="4. 类加载机制"></a>4. 类加载机制</h3><p><strong>1. 加载过程详解</strong></p>
<ul>
<li>概述</li>
</ul>
<p> 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）<br> 对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<ul>
<li><p>注意<br>  对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。<br>  常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。<br>  也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。</p>
</li>
<li><p>加载阶段<br>  虚拟机需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
</li>
<li><p>验证</p>
</li>
</ul>
<p> 是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<ul>
<li><p>准备阶段<br>  是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：<br>  public static int value&#x3D;123；<br>  那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞（）方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。表7-1列出了Java中所有基本数据类型的零值。<br>  假设上面类变量value的定义变为：public static final int value&#x3D;123；<br>  编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
</li>
<li><p>解析阶段</p>
</li>
</ul>
<p> 是虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<ul>
<li>类初始化阶段<br>  是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞（）方法的过程。＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。<br>  ＜clinit＞（）方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞（）方法。<br>  虚拟机会保证一个类的＜clinit＞（）方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞（）方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞（）方法完毕。如果在一个类的＜clinit＞（）方法中有耗时很长的操作，就可能造成多个进程阻塞。</li>
</ul>
<p><strong>2. 类加载器</strong></p>
<ol>
<li>自定义类加载对类进行加密和解密</li>
</ol>
<p>重写findClass方法</p>
<ol start="2">
<li>系统的类加载器</li>
</ol>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。<br>这里所指的“相等”，包括代表类的Class对象的equals（）方法、isAssignableFrom（）方法、isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。<br>在自定义ClassLoader的子类时候，我们常见的会有两种做法，一种是重写loadClass方法，另一种是重写findClass方法。其实这两种方法本质上差不多，毕竟loadClass也会调用findClass，但是从逻辑上讲我们最好不要直接修改loadClass的内部逻辑。我建议的做法是只在findClass里重写自定义类的加载方法。<br>loadClass这个方法是实现双亲委托模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委托模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</p>
<ol start="3">
<li>双亲委派模型</li>
</ol>
<p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。<br><strong>启动类加载器</strong>（<code>Bootstrap ClassLoader</code>）：这个类加载器负责将存放在<code>＜JAVA_HOME＞\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。<br><strong>扩展类加载器</strong>（<code>Extension ClassLoader</code>）：这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>＜JAVA_HOME＞\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。<br><strong>应用程序类加载器</strong>（<code>Application ClassLoader</code>）：这个类加载器由<code>sun.misc.Launcher $App-ClassLoader</code>实现。由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader（）</code>方法的返回值，所以一般也称它为<strong>系统类加载器</strong>。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<br>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。<br>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。<br>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于<strong>模型最顶端的启动类加载器</strong>进行加载，<strong>因此Object类在程序的各种类加载器环境中都是同一个类</strong>。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p>
<p><strong>双亲委托机制（谁先加载就用谁作为执行的class）–》热修复的原理</strong></p>
<p><strong>3. Tomcat类加载机制</strong></p>
<p>Tomcat本身也是一个java项目，因此其也需要被JDK的类加载机制加载，也就必然存在引导类加载器、扩展类加载器和应用(系统)类加载器。<br>Common ClassLoader作为Catalina ClassLoader和Shared ClassLoader的parent，而Shared ClassLoader又可能存在多个children类加载器WebApp ClassLoader，一个WebApp ClassLoader实际上就对应一个Web应用，那Web应用就有可能存在Jsp页面，这些Jsp页面最终会转成class类被加载，因此也需要一个Jsp的类加载器。<br>需要注意的是，在代码层面Catalina ClassLoader、Shared ClassLoader、Common ClassLoader对应的实体类实际上都是URLClassLoader或者SecureClassLoader，一般我们只是根据加载内容的不同和加载父子顺序的关系，在逻辑上划分为这三个类加载器；而WebApp ClassLoader和JasperLoader都是存在对应的类加载器类的。<br>当tomcat启动时，会创建几种类加载器：<br>1 Bootstrap 引导类加载器 加载JVM启动所需的类，以及标准扩展类（位于jre&#x2F;lib&#x2F;ext下）<br>2 System 系统类加载器 加载tomcat启动的类，比如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME&#x2F;bin下。<br>3 Common 通用类加载器 加载tomcat使用以及应用通用的一些类，位于CATALINA_HOME&#x2F;lib下，比如servlet-api.jar<br>4 webapp 应用类加载器每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF&#x2F;lib下的jar文件中的class 和 WEB-INF&#x2F;classes下的class文件。</p>
<h3 id="5-栈帧详解"><a href="#5-栈帧详解" class="headerlink" title="5. 栈帧详解"></a>5. 栈帧详解</h3><h3 id="6-方法调用详解"><a href="#6-方法调用详解" class="headerlink" title="6. 方法调用详解"></a>6. 方法调用详解</h3><p>调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。<br>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p>
<h3 id="7-基于栈的字节码解释执行引擎"><a href="#7-基于栈的字节码解释执行引擎" class="headerlink" title="7. 基于栈的字节码解释执行引擎"></a>7. 基于栈的字节码解释执行引擎</h3><ol>
<li>基于栈的指令集与基于寄存器的指令集</li>
<li>分析代码在虚拟机中执行情况</li>
</ol>
<h2 id="编写高效优雅的Java程序员"><a href="#编写高效优雅的Java程序员" class="headerlink" title="编写高效优雅的Java程序员"></a>编写高效优雅的Java程序员</h2><h3 id="1-构造器参数太多怎么办？"><a href="#1-构造器参数太多怎么办？" class="headerlink" title="1. 构造器参数太多怎么办？"></a>1. 构造器参数太多怎么办？</h3><p>  用builder模式，用在<br>  1、5个或者5个以上的成员变量<br>  2、参数不多，但是在未来，参数会增加</p>
<h3 id="2-不需要实例化的类应该构造器私有"><a href="#2-不需要实例化的类应该构造器私有" class="headerlink" title="2. 不需要实例化的类应该构造器私有"></a>2. 不需要实例化的类应该构造器私有</h3><h3 id="3-不要创建不必要的对象"><a href="#3-不要创建不必要的对象" class="headerlink" title="3. 不要创建不必要的对象"></a>3. 不要创建不必要的对象</h3><ul>
<li><p>避免无意中创建的对象，如自动装箱循环内因为会自动装箱拆箱，创建无用的对象。</p>
</li>
<li><p>可以在类的多个实例之间重用的成员变量，尽量使用static。</p>
</li>
</ul>
<h3 id="4-避免使用终结方法"><a href="#4-避免使用终结方法" class="headerlink" title="4. 避免使用终结方法"></a>4. 避免使用终结方法</h3><p>  finalizer方法，jdk不能保证何时执行，也不能保证一定会执行。如果有确实要释放的资源应该用try&#x2F;finally。</p>
<h3 id="5-使类和成员的可访问性最小化"><a href="#5-使类和成员的可访问性最小化" class="headerlink" title="5. 使类和成员的可访问性最小化"></a>5. 使类和成员的可访问性最小化</h3><p>  编写程序和设计架构，最重要的目标之一就是模块之间的解耦。使类和成员的可访问性最小化无疑是有效的途径之一。</p>
<h3 id="6-使可变性最小化"><a href="#6-使可变性最小化" class="headerlink" title="6. 使可变性最小化"></a>6. 使可变性最小化</h3><p>  尽量使类不可变，不可变的类比可变的类更加易于设计、实现和使用，而且更不容易出错，更安全。<br>  常用的手段：<br>  不提供任何可以修改对象状态的方法；<br>  使所有的域都是final的。<br>  使所有的域都是私有的。<br>  使用写时复制机制。带来的问题：会导致系统产生大量的对象，而且性能有一定的影响，需要在使用过程中小心权衡。</p>
<h3 id="7-优先使用复合"><a href="#7-优先使用复合" class="headerlink" title="7. 优先使用复合"></a>7. 优先使用复合</h3><p>  继承容易破坏封装性，而且会使子类的实现依赖于父类。<br>  复合则是在类中增加一个私有域，引用类的一个实例，这样的话就避免了依赖类的具体实现。<br>  只有在子类确实是父类的一个子类型时，才比较适合用继承。</p>
<h3 id="8-接口优于抽象类"><a href="#8-接口优于抽象类" class="headerlink" title="8. 接口优于抽象类"></a>8. 接口优于抽象类</h3><h3 id="9-可变参数要谨慎使用"><a href="#9-可变参数要谨慎使用" class="headerlink" title="9. 可变参数要谨慎使用"></a>9. 可变参数要谨慎使用</h3><p>  可变参数是允许传0个参数的<br>  如果是参数个数在1~多个之间的时候，要做单独的业务控制</p>
<h3 id="10-返回零长度的数组或集合，不要返回null"><a href="#10-返回零长度的数组或集合，不要返回null" class="headerlink" title="10. 返回零长度的数组或集合，不要返回null"></a>10. 返回零长度的数组或集合，不要返回null</h3><h3 id="11-优先使用标准的异常"><a href="#11-优先使用标准的异常" class="headerlink" title="11. 优先使用标准的异常"></a>11. 优先使用标准的异常</h3><p>要尽量追求代码的重用，同时减少类加载的数目，提高类装载的性能。<br>常用的异常：<br>IlegalAraumentException  – 调用者传递的参数不合适<br>lllegalStateException – 接收的对象状态不对，<br>NullPointException  -空指针异常<br>UnsupportedOperationException –不支持的操作</p>
<h3 id="12-用枚举代替int常量"><a href="#12-用枚举代替int常量" class="headerlink" title="12. 用枚举代替int常量"></a>12. 用枚举代替int常量</h3><h3 id="13-将局部变量的作用域最小化"><a href="#13-将局部变量的作用域最小化" class="headerlink" title="13. 将局部变量的作用域最小化"></a>13. 将局部变量的作用域最小化</h3><ol>
<li>在第一次使用的地方进行声明</li>
<li>局部变量都是要自行初始化，初始化条件不满足，就不要声明<br>最小化的好处，减小局部变量表的大小，提示性能；同时避免局部变量过早声明导致不正确的使用。</li>
</ol>
<h3 id="14-精确计算，避免使用float和double"><a href="#14-精确计算，避免使用float和double" class="headerlink" title="14. 精确计算，避免使用float和double"></a>14. 精确计算，避免使用float和double</h3><h3 id="15-当心字符串连接的性能"><a href="#15-当心字符串连接的性能" class="headerlink" title="15. 当心字符串连接的性能"></a>15. 当心字符串连接的性能</h3><p>在存在大量字符串拼接或者大型字符串拼接的时候，尽量使用StringBuilder和StringBuffer</p>
<h2 id="深入了解性能优化"><a href="#深入了解性能优化" class="headerlink" title="深入了解性能优化"></a>深入了解性能优化</h2><h3 id="1-常用的性能评价-x2F-测试指标"><a href="#1-常用的性能评价-x2F-测试指标" class="headerlink" title="1. 常用的性能评价&#x2F;测试指标"></a>1. 常用的性能评价&#x2F;测试指标</h3><p><strong>1. 响应时间</strong></p>
<ul>
<li>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。<br>常用操作的响应时间列表：<table <tr <td操作< td <td响应时间< < tr <td打开一个站点< <td几秒< <td数据库查询一条记录（有索引）< <td十几毫秒< <td机械磁盘一次寻址定位< <td4毫秒< <td从机械磁盘顺序读取1m数据< <td2毫秒< <td从ssd磁盘顺序读取1m数据< <td0.3毫秒< <td从远程分布式换成redis读取一个数据< <td0.5毫秒< <td从内存读取1m数据< <td十几微秒< <tdjava程序本地方法调用< <td几微秒< <td网络传输2kb数据< <td1微秒< table< li>
</table></li></ul>
<p><strong>2. 并发数</strong></p>
<p>同一时刻，对服务器有实际交互的请求数。<br>和网站在线用户数的关联：1000个同时在线用户数，可以估计并发数在5%到15%之间，也就是同时并发数在50~150之间。</p>
<p><strong>3. 吞吐量</strong></p>
<p>对单位时间内完成的工作量(请求)的量度</p>
<p><strong>4. 相互之间的关系</strong></p>
<ul>
<li><p>系统吞吐量和系统并发数以及响应时间的关系：<br>理解为高速公路的通行状况：<br>吞吐量是每天通过收费站的车辆数目（可以换算成收费站收取的高速费），<br>并发数是高速公路上的正在行驶的车辆数目，<br>响应时间是车速。<br>车辆很少时，车速很快。但是收到的高速费也相应较少；随着高速公路上车辆数目的增多，车速略受影响，但是收到的高速费增加很快；<br>随着车辆的继续增加，车速变得越来越慢，高速公路越来越堵，收费不增反降；<br>如果车流量继续增加，超过某个极限后，任务偶然因素都会导致高速全部瘫痪，车走不动，当然后也收不着，而高速公路成了停车场（资源耗尽）。</p>
<h3 id="2-常用的性能优化手段"><a href="#2-常用的性能优化手段" class="headerlink" title="2. 常用的性能优化手段"></a>2. 常用的性能优化手段</h3><p><strong>1. 总原则</strong></p>
</li>
<li><p>避免过早优化<br>不应该把大量的时间耗费在小的性能改进上，过早考虑优化是所有噩梦的根源。<br>所以，我们应该编写清晰，直接，易读和易理解的代码，真正的优化应该留到以后，等到性能分析表明优化措施有巨大的收益时再进行。<br>但是过早优化，不表示我们应该编写已经知道的对性能不好的的代码结构。</p>
</li>
<li><p>进行系统性能测试<br>所有的性能调优，都有应该建立在性能测试的基础上，直觉很重要，但是要用数据说话，可以推测，但是要通过测试求证。</p>
</li>
<li><p>寻找系统瓶颈，分而治之，逐步优化<br>性能测试后，对整个请求经历的各个环节进行分析，排查出现性能瓶颈的地方，定位问题，分析影响性能的的主要因素是什么？内存、磁盘IO、网络、CPU，还是代码问题？架构设计不足？或者确实是系统资源不足？</p>
</li>
</ul>
<p><strong>2. 前端优化手段</strong></p>
<p><strong>浏览器&#x2F;App</strong></p>
<ul>
<li><p>减少请求数；<br>合并CSS，Js，图片</p>
</li>
<li><p>使用客户端缓冲；<br>静态资源文件缓存在浏览器中，有关的属性Cache-Control和Expires<br>如果文件发生了变化，需要更新，则通过改变文件名来解决。</p>
</li>
<li><p>启用压缩<br>减少网络传输量，但会给浏览器和服务器带来性能的压力，需要权衡使用。</p>
</li>
<li><p>资源文件加载顺序<br>css放在页面最上面，js放在最下面</p>
</li>
<li><p>减少Cookie传输<br>cookie包含在每次的请求和响应中，因此哪些数据写入cookie需要慎重考虑</p>
</li>
<li><p>给用户一个提示<br>有时候在前端给用户一个提示，就能收到良好的效果。毕竟用户需要的是不要不理他。</p>
</li>
</ul>
<p><strong>CDN加速</strong></p>
<p>CDN，又称内容分发网络，本质仍然是一个缓存，而且是将数据缓存在用户最近的地方。无法自行实现CDN的时候，可以考虑商用CDN服务。</p>
<p><strong>反向代理缓存</strong></p>
<p>将静态资源文件缓存在反向代理服务器上，一般是Nginx。</p>
<p><strong>WEB组件分离</strong></p>
<p>将js，css和图片文件放在不同的域名下。可以提高浏览器在下载web组件的并发数。因为浏览器在下载同一个域名的的数据存在并发数限制。</p>
<p><strong>3. 应用服务性能优化</strong></p>
<p><strong>4. 存储性能优化</strong></p>
<ul>
<li><p>选择合适的数据结构<br>选择ArrayList和LinkedList对我们的程序性能影响很大，为什么？因为ArrayList内部是数组实现，存在着不停的扩容和数据复制。</p>
</li>
<li><p>选择更优的算法<br>举个例子，最大子列和问题：<br>给定一个整数序列，a0, a1, a2, …… , an（项可以为负数），求其中最大的子序列和。<br>如果所有整数都是负数，那么最大子序列和为0；<br>例如（a[1],a[2],a[3],a[4],a[5],a[6]）&#x3D;(-2,11,-4,13,-5,-2)时，<br>最大子段和为20，子段为a[2],a[3],a[4]。<br>最坏的算法：穷举法，所需要的的计算时间是O(n^3).<br>一般的算法：分治法的计算时间复杂度为O(nlogn).<br>最好的算法：最大子段和的动态规划算法，计算时间复杂度为O(n)<br>n越大，时间就相差越大，比如10000个元素，最坏的算法和最好的算法之间的差距绝非多线程或者集群化能轻松解决的。</p>
</li>
<li><p>编写更少的代码<br>同样正确的程序，小程序比大程序要快，这点无关乎编程语言。</p>
<h3 id="3-详细了解应用服务性能优化"><a href="#3-详细了解应用服务性能优化" class="headerlink" title="3. 详细了解应用服务性能优化"></a>3. 详细了解应用服务性能优化</h3></li>
</ul>
<p><strong>1. 缓存</strong></p>
<ol>
<li><p>缓存的基本原理和本质<br>缓存是将数据存在访问速度较高的介质中。可以减少数据访问的时间，同时避免重复计算。</p>
</li>
<li><p>合理使用缓存的准则<br>频繁修改的数据，尽量不要缓存，读写比2:1以上才有缓存的价值。<br>缓存一定是热点数据。<br>应用需要容忍一定时间的数据不一致。<br>缓存可用性问题，一般通过热备或者集群来解决。<br>缓存预热，新启动的缓存系统没有任何数据，可以考虑将一些热点数据提前加载到缓存系统。<br>解决缓存击穿：<br>1、布隆过滤器，或者2、把不存在的数据也缓存起来 ，比如有请求总是访问key &#x3D; 23的数据，但是这个key &#x3D; 23的数据在系统中不存在，可以考虑在缓存中构建一个( key&#x3D;23 value &#x3D; null)的数据。</p>
</li>
<li><p>分布式缓存与一致性哈希</p>
</li>
</ol>
<ul>
<li>以集群的方式提供缓存服务，有两种实现；<ol>
<li>需要更新同步的分布式缓存，所有的服务器保存相同的缓存数据，带来的问题就是，缓存的数据量受限制，其次，数据要在所有的机器上同步，代价很大。</li>
<li>每台机器只缓存一部分数据，然后通过一定的算法选择缓存服务器。常见的余数hash算法存在当有服务器上下线的时候，大量缓存数据重建的问题。所以提出了一致性哈希算法。</li>
</ol>
</li>
<li>一致性哈希<ol>
<li>首先求出服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。</li>
<li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li>
<li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台服务器上。<br>一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。<br>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题，此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</li>
</ol>
</li>
</ul>
<p><strong>2. 集群</strong></p>
<p><strong>3. 异步</strong></p>
<ol>
<li>同步和异步，阻塞和非阻塞<br> <strong>同步和异步关注的是结果消息的通信机制</strong></li>
</ol>
<ul>
<li>同步<br>同步的意思就是调用方需要主动等待结果的返回</li>
<li>异步<br>异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知，回调函数等。</li>
</ul>
<p>  <strong>阻塞和非阻塞主要关注的是等待结果返回调用方的状态</strong></p>
<ul>
<li>阻塞<br>是指结果返回之前，当前线程被挂起，不做任何事</li>
<li>非阻塞<br>是指结果在返回之前，线程可以做一些其他事，不会被挂起。</li>
<li>同步阻塞<br>同步阻塞基本也是编程中最常见的模型，打个比方你去商店买衣服，你去了之后发现衣服卖完了，那你就在店里面一直等，期间不做任何事(包括看手机)，等着商家进货，直到有货为止，这个效率很低。jdk里的BIO就属于 同步阻塞</li>
<li>同步非阻塞<br>同步非阻塞在编程中可以抽象为一个轮询模式，你去了商店之后，发现衣服卖完了，这个时候不需要傻傻的等着，你可以去其他地方比如奶茶店，买杯水，但是你还是需要时不时的去商店问老板新衣服到了吗。jdk里的NIO就属于 同步非阻塞</li>
<li>异步阻塞<br>异步阻塞这个编程里面用的较少，有点类似你写了个线程池,submit然后马上future.get()，这样线程其实还是挂起的。有点像你去商店买衣服，这个时候发现衣服没有了，这个时候你就给老板留给电话，说衣服到了就给我打电话，然后你就守着这个电话，一直等着他响什么事也不做。这样感觉的确有点傻，所以这个模式用得比较少。</li>
<li>异步非阻塞<br>好比你去商店买衣服，衣服没了，你只需要给老板说这是我的电话，衣服到了就打。然后你就随心所欲的去玩，也不用操心衣服什么时候到，衣服一到，电话一响就可以去买衣服了。jdk里的AIO就属于异步</li>
</ul>
<ol start="2">
<li>常见异步的手段<ul>
<li>Servlet异步<br>servlet3中才有，支持的web容器在tomcat7和jetty8以后。</li>
<li>多线程</li>
<li>消息队列</li>
<li>集群<br>可以很好的将用户的请求分配到多个机器处理，对总体性能有很大的提升</li>
<li>程序代码级别<br>一个应用的性能归根结底取决于代码是如何编写的。</li>
</ul>
</li>
</ol>
<p><strong>4. 应用相关</strong></p>
<ol>
<li>代码级别<br> <strong>一个应用的性能归根结底取决于代码是如何编写的。</strong></li>
</ol>
<ul>
<li>选择合适的数据结构<br>选择ArrayList和LinkedList对我们的程序性能影响很大，为什么？因为ArrayList内部是数组实现，存在着不停的扩容和数据复制。</li>
<li>选择更优的算法<br>举个例子，最大子列和问题：<br>给定一个整数序列，a0, a1, a2, …… , an（项可以为负数），求其中最大的子序列和。<br>如果所有整数都是负数，那么最大子序列和为0；<br>例如（a[1],a[2],a[3],a[4],a[5],a[6]）&#x3D;(-2,11,-4,13,-5,-2)时，<br>最大子段和为20，子段为a[2],a[3],a[4]。<br>最坏的算法：穷举法，所需要的的计算时间是O(n^3).<br>一般的算法：分治法的计算时间复杂度为O(nlogn).<br>最好的算法：最大子段和的动态规划算法，计算时间复杂度为O(n)<br>n越大，时间就相差越大，比如10000个元素，最坏的算法和最好的算法之间的差距绝非多线程或者集群化能轻松解决的。</li>
<li>编写更少的代码<br>同样正确的程序，小程序比大程序要快，这点无关乎编程语言。</li>
</ul>
<ol>
<li>并发编程</li>
<li>充分利用CPU多核，</li>
<li>实现线程安全的类，避免线程安全问题</li>
<li>同步下减少锁的竞争</li>
<li>资源的复用<br>目的是减少开销很大的系统资源的创建和销毁，比如数据库连接，网络通信连接，线程资源等等。</li>
<li>JVM</li>
<li>与JIT编译器相关的优化<ul>
<li>热点编译的概念<br>对于程序来说，通常只有一部分代码被经常执行，这些关键代码被称为应用的热点，执行的越多就认为是越热。将这些代码编译为本地机器特定的二进制码，可以有效提高应用性能。</li>
<li>选择编译器类型<br>-server，更晚编译，但是编译后的优化更多，性能更高<br>-client，很早就开始编译</li>
<li>代码缓存相关<br>在编译后，会有一个代码缓存保存编译后的代码，一旦这个缓存满了，jvm将无法继续编译代码。<br> 当jvm提示：  CodeCache is full，就表示需要增加代码缓存大小。<br> –XX:ReservedCodeCacheSize&#x3D;N可以用来调整这个大小。</li>
<li>编译阈值<br>代码是否进行编译，取决于代码执行的频度，是否到达编译阈值。<br>计数器有两种：方法调用计数器和方法里的循环回边计数器<br>一个方法是否达到编译阈值取决于方法中的两种计数器之和。编译阈值调整的参数为：-XX:CompileThreshold&#x3D;N<br>方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。另外，可以使用-XX：CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。<br>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。</li>
<li>编译线程<br>进行代码编译的时候，是采用多线程进行编译的。</li>
<li>方法内联<br>内联默认开启，-XX:-Inline，可以关闭，但是不要关闭，一旦关闭对性能有巨大影响。<br>方法是否内联取决于方法有多热和方法的大小，<br>很热的方法如果方法字节码小于325字节才会内联，这个大小由参数 -XX:MaxFreqInlinesSzie&#x3D;N 调整，但是这个很热与热点编译不同，没有任何参数可以调整热度。<br>方法小于35个字节码，一定会内联，这个大小可以通过参数-XX:MaxInlinesSzie&#x3D;N 调整。</li>
</ul>
</li>
</ol>
<ul>
<li>逃逸分析<br>是JVM所做的最激进的优化，最好不要调整相关的参数。</li>
</ul>
<ol start="2">
<li>GC调优</li>
</ol>
<ul>
<li><p>目的<br>GC的时间够小<br>GC的次数够少<br>发生Full GC的周期足够的长，时间合理，最好是不发生。</p>
</li>
<li><p>调优的原则和步骤</p>
</li>
</ul>
<ol>
<li>大多数的java应用不需要GC调优</li>
<li>大部分需要GC调优的，不是参数问题，是代码问题</li>
<li>在实际使用中，分析GC情况优化代码比优化GC参数要多得多；</li>
<li>GC调优是最后的手段<br> GC调优的最重要的三个选项：<br> 第一位：选择合适的GC回收器<br> 第二位：选择合适的堆大小<br> 第三位：选择年轻代在堆中的比重</li>
</ol>
<p><strong>步骤</strong></p>
<ol>
<li>监控GC的状态</li>
</ol>
<p>使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化；</p>
<ol start="2">
<li><p>分析结果，判断是否需要优化<br>如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化；<br>注：如果满足下面的指标，则一般不需要进行GC：<br>Minor GC执行时间不到50ms；<br>Minor GC执行不频繁，约10秒一次；<br>Full GC执行时间不到1s；<br>Full GC执行频率不算频繁，不低于10分钟1次；</p>
</li>
<li><p>调整GC类型和内存分配<br>如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择；</p>
</li>
<li><p>不断的分析和调整<br>通过不断的试验和试错，分析并找到最合适的参数</p>
</li>
<li><p>全面应用参数<br>如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。</p>
</li>
<li><p>JVM调优实战<br><strong>推荐策略</strong></p>
</li>
</ol>
<ul>
<li>年轻代大小选择</li>
</ul>
<ol>
<li>响应时间优先的应用:尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象.</li>
<li>吞吐量优先的应用:尽可能的设置大,可能到达Gbit的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用.</li>
<li>避免设置过小.当新生代设置过小时会导致:<ol>
<li>YGC次数更加频繁 </li>
<li>可能导致YGC对象直接进入旧生代,如果此时旧生代满了,会触发FGC.</li>
</ol>
</li>
</ol>
<ul>
<li>年老代大小选择</li>
</ul>
<ol>
<li><p>响应时间优先的应用:年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得:<br>并发垃圾收集信息、持久代并发收集次数、传统GC信息、花在年轻代和年老代回收上的时间比例。</p>
</li>
<li><p>吞吐量优先的应用一般都有一个很大的年轻代和一个较小的年老代.原因是,这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象</p>
</li>
<li><p>存储性能优化</p>
</li>
<li><p>尽量使用SSD</p>
</li>
<li><p>定时清理数据或者按数据的性质分开存放</p>
</li>
</ol>
<h2 id="看博文的摘录"><a href="#看博文的摘录" class="headerlink" title="看博文的摘录"></a>看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenyangyao/p/5296807.html">博文</a>的摘录</h2><p>一个对象创建的过程：</p>
<ul>
<li><p>对象创建过程一般是从 new 指令开始，JVM 首先对符号进行解析，如果找不到对应的符号引用，那么这个类还没有被加载，因此 JVM 会进行类加载过程。符号引用解析完毕之后，JVM 会为对象在堆中分配内存，HopSpot虚拟机实现的 Java 对象包括三个部分：对象头、实例字段和对齐填充字段，需要注意的是，<strong>实例字段包括自身定义的和从父类继承（继承是一种逻辑关系，不是简单的“复制”。唯有创建对象时的实例字段可以简单的看成“复制”）下来的（即使父类的实例字段被子类覆盖或者被 private 修饰，都照样为其分配内存）。</strong></p>
</li>
<li><p>为对象分配堆内存后，将该内存（除对象头区域）进行零值初始化，也就是为何 JAVA 的属性字段无须显示初始化就可以被使用的原因（而方法的局部变量却必须显示初始化后才可以访问）。</p>
</li>
<li><p>最后，JVM 会调用对象的构造函数，调用顺序会一直上溯到 Object 类。</p>
</li>
</ul>
<p>对象创建完毕一般会有一个引用指向这个对象。JAVA 中存在基本类型（int、double 等）和引用类型（类、接口、内部类、枚举类、数组类型的引用等）两种数据类型。题外话，C++和 Java 的引用只是“名称”一样，本质没有什么关系，C++中的引用只是给现存变量起了一个<strong>别名</strong>（引用变量只是一个符号引用而已，编译器并不会给引用分配新的内存），而 Java 的引用变量则是<strong>真正地变量</strong>，<strong>具有自己的内存空间</strong>，只是不同的引用变量可以“指向”同一个对象而已。<strong>Java 中的引用其实就是对 C++中指针的封装</strong>。</p>
<p>对象创建过程</p>
<p><img src="https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235423381-1926278401.png" alt="对象创建过程"></p>
<p>HotSpot 虚拟机对象头<img src="https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235633553-1910724119.png" alt="HotSpot 虚拟机对象头"></p>
<p>对象引用的两种实现方式<img src="https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235555303-769658219.jpg" alt="通过句柄访问对象"></p>
<h1 id="另一篇比较好的博文：深入理解JVM—JVM内存模型"><a href="#另一篇比较好的博文：深入理解JVM—JVM内存模型" class="headerlink" title="另一篇比较好的博文：深入理解JVM—JVM内存模型"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dingyingsi/p/3760447.html">另一篇比较好的博文：深入理解JVM—JVM内存模型</a></h1><p>疑问：主存、工作内存与JVM内存模型有没有关系，如果有那么在其中的哪一块</p>
<h1 id="《JVM相关口水话》-x2F-https-github-com-Omooo-Android-Notes-blob-master-blogs-Java-E5-8F-A3-E6-B0-B4-E8-AF-9D-JVM-20-E7-9B-B8-E5-85-B3-E5-8F-A3-E6-B0-B4-E8-AF-9D-md-https-github-com-Omooo-Android-Notes-blob-master-blogs-Java-口水话-JVM-相关口水话-md"><a href="#《JVM相关口水话》-x2F-https-github-com-Omooo-Android-Notes-blob-master-blogs-Java-E5-8F-A3-E6-B0-B4-E8-AF-9D-JVM-20-E7-9B-B8-E5-85-B3-E5-8F-A3-E6-B0-B4-E8-AF-9D-md-https-github-com-Omooo-Android-Notes-blob-master-blogs-Java-口水话-JVM-相关口水话-md" class="headerlink" title="[《JVM相关口水话》](.&#x2F;[https://github.com/Omooo/Android-Notes/blob/master/blogs/Java/%E5%8F%A3%E6%B0%B4%E8%AF%9D/JVM%20%E7%9B%B8%E5%85%B3%E5%8F%A3%E6%B0%B4%E8%AF%9D.md](https://github.com/Omooo/Android-Notes/blob/master/blogs/Java/口水话/JVM 相关口水话.md))"></a>[《JVM相关口水话》](.&#x2F;[<a target="_blank" rel="noopener" href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Java/%E5%8F%A3%E6%B0%B4%E8%AF%9D/JVM%20%E7%9B%B8%E5%85%B3%E5%8F%A3%E6%B0%B4%E8%AF%9D.md]">https://github.com/Omooo/Android-Notes/blob/master/blogs/Java/%E5%8F%A3%E6%B0%B4%E8%AF%9D/JVM%20%E7%9B%B8%E5%85%B3%E5%8F%A3%E6%B0%B4%E8%AF%9D.md]</a>(<a target="_blank" rel="noopener" href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Java/%E5%8F%A3%E6%B0%B4%E8%AF%9D/JVM">https://github.com/Omooo/Android-Notes/blob/master/blogs/Java/口水话/JVM</a> 相关口水话.md))</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><!-- flag of hidden posts -->
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt=" WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/private/" rel="tag"># private</a>
          
            <a href="/tags/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag"># Java知识点</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">95</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:shenbh@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/ptwenzi?spm=1010.2135.3001.5113" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-clone"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/shenbh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://gitee.com/shen_bh" target="_blank" title="Gitee">
                      
                        <i class="fa fa-fw fa-git"></i>Gitee</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E5%A4%A7%E7%BA%B2"><span class="nav-text">JVM大纲</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E5%8F%82%E6%95%B0"><span class="nav-text">JVM参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">深入理解Java虚拟机到底是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm"><span class="nav-text">jvm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">jvm工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jdk%E7%BB%93%E6%9E%84"><span class="nav-text">jdk结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88Runtime-Data-Area%EF%BC%89"><span class="nav-text">运行时数据区（Runtime Data Area）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="nav-text">方法指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">类加载器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text">字节码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#class%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84"><span class="nav-text">class文件字节码结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#class%E5%AD%97%E8%8A%82%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">class字节码示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">jvm类的加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="nav-text">类的加载时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="nav-text">类的加载流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">JVM 与性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E6%96%87%E9%93%BE%E6%8E%A5"><span class="nav-text">原文链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-text">JVM内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="nav-text">1. 虚拟机的历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%AA%E6%9D%A5Java%E6%8A%80%E6%9C%AF%E4%B8%80%E8%A7%88"><span class="nav-text">2. 未来Java技术一览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E6%95%B0%E6%8D%AE"><span class="nav-text">3. 运行时区数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%AB%99%E5%9C%A8%E7%BA%BF%E7%A8%8B%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%A0%86%E5%92%8C%E6%A0%88"><span class="nav-text">4. 站在线程角度来看堆和栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B7%B1%E5%85%A5%E8%BE%A8%E6%9E%90%E5%A0%86%E5%92%8C%E6%A0%88"><span class="nav-text">5. 深入辨析堆和栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%96%B9%E6%B3%95%E7%9A%84%E5%87%BA%E5%85%A5%E6%A0%88"><span class="nav-text">6. 方法的出入栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">7. 虚拟机中的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%A0%86%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%AE%9E%E6%88%98"><span class="nav-text">8. 堆参数设置和内存溢出实战</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-text">垃圾回收器和内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-GC%E6%A6%82%E8%BF%B0"><span class="nav-text">1. GC概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E6%B4%BB"><span class="nav-text">2. 判断对象的存活</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BE%A8%E6%9E%90%E5%BC%BA%E3%80%81%E5%BC%B1%E7%AD%89%E5%90%84%E7%A7%8D%E5%BA%94%E7%94%A8"><span class="nav-text">3. 辨析强、弱等各种应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-GC%E7%AE%97%E6%B3%95"><span class="nav-text">4. GC算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="nav-text">5. 分代收集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Stop-The-World%E7%8E%B0%E8%B1%A1"><span class="nav-text">6. Stop The World现象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-GC%E6%97%A5%E5%BF%97%E8%A7%A3%E8%AF%BB"><span class="nav-text">7. GC日志解读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-text">8. 内存分配与回收策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%BE%A8%E6%9E%90"><span class="nav-text">9. 内存泄露和内存溢出辨析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-JDK%E4%B8%BA%E6%88%91%E4%BB%AC%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-text">10. JDK为我们提供的工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E4%BA%86%E8%A7%A3MAT"><span class="nav-text">11. 了解MAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">12. 垃圾回收器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-text">JVM执行子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Class%E7%B1%BB%E6%96%87%E4%BB%B6%E6%9C%AC%E8%B4%A8"><span class="nav-text">1. Class类文件本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">2. Class文件格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="nav-text">3. 字节码指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">4. 类加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%A0%88%E5%B8%A7%E8%AF%A6%E8%A7%A3"><span class="nav-text">5. 栈帧详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="nav-text">6. 方法调用详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-text">7. 基于栈的字节码解释执行引擎</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88%E4%BC%98%E9%9B%85%E7%9A%84Java%E7%A8%8B%E5%BA%8F%E5%91%98"><span class="nav-text">编写高效优雅的Java程序员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E5%A4%AA%E5%A4%9A%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">1. 构造器参数太多怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%8D%E9%9C%80%E8%A6%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E7%B1%BB%E5%BA%94%E8%AF%A5%E6%9E%84%E9%80%A0%E5%99%A8%E7%A7%81%E6%9C%89"><span class="nav-text">2. 不需要实例化的类应该构造器私有</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%8D%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">3. 不要创建不必要的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="nav-text">4. 避免使用终结方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BD%BF%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-text">5. 使类和成员的可访问性最小化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BD%BF%E5%8F%AF%E5%8F%98%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-text">6. 使可变性最小化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%90%88"><span class="nav-text">7. 优先使用复合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%8E%A5%E5%8F%A3%E4%BC%98%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">8. 接口优于抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E8%A6%81%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">9. 可变参数要谨慎使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E8%BF%94%E5%9B%9E%E9%9B%B6%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84%E6%88%96%E9%9B%86%E5%90%88%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9Enull"><span class="nav-text">10. 返回零长度的数组或集合，不要返回null</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-text">11. 优先使用标准的异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E7%94%A8%E6%9E%9A%E4%B8%BE%E4%BB%A3%E6%9B%BFint%E5%B8%B8%E9%87%8F"><span class="nav-text">12. 用枚举代替int常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%B0%86%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-text">13. 将局部变量的作用域最小化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E7%B2%BE%E7%A1%AE%E8%AE%A1%E7%AE%97%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8float%E5%92%8Cdouble"><span class="nav-text">14. 精确计算，避免使用float和double</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E5%BD%93%E5%BF%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-text">15. 当心字符串连接的性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">深入了解性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7-x2F-%E6%B5%8B%E8%AF%95%E6%8C%87%E6%A0%87"><span class="nav-text">1. 常用的性能评价&#x2F;测试指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="nav-text">2. 常用的性能优化手段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">3. 详细了解应用服务性能优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9C%8B%E5%8D%9A%E6%96%87%E7%9A%84%E6%91%98%E5%BD%95"><span class="nav-text">看博文的摘录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E7%AF%87%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E5%8D%9A%E6%96%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E2%80%94JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">另一篇比较好的博文：深入理解JVM—JVM内存模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E3%80%8AJVM%E7%9B%B8%E5%85%B3%E5%8F%A3%E6%B0%B4%E8%AF%9D%E3%80%8B-x2F-https-github-com-Omooo-Android-Notes-blob-master-blogs-Java-E5-8F-A3-E6-B0-B4-E8-AF-9D-JVM-20-E7-9B-B8-E5-85-B3-E5-8F-A3-E6-B0-B4-E8-AF-9D-md-https-github-com-Omooo-Android-Notes-blob-master-blogs-Java-%E5%8F%A3%E6%B0%B4%E8%AF%9D-JVM-%E7%9B%B8%E5%85%B3%E5%8F%A3%E6%B0%B4%E8%AF%9D-md"><span class="nav-text">[《JVM相关口水话》](.&#x2F;[https:&#x2F;&#x2F;github.com&#x2F;Omooo&#x2F;Android-Notes&#x2F;blob&#x2F;master&#x2F;blogs&#x2F;Java&#x2F;%E5%8F%A3%E6%B0%B4%E8%AF%9D&#x2F;JVM%20%E7%9B%B8%E5%85%B3%E5%8F%A3%E6%B0%B4%E8%AF%9D.md](https:&#x2F;&#x2F;github.com&#x2F;Omooo&#x2F;Android-Notes&#x2F;blob&#x2F;master&#x2F;blogs&#x2F;Java&#x2F;口水话&#x2F;JVM 相关口水话.md))</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-text">问题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿炳</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('Copied')
          else $(this).text('Copy failed')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>