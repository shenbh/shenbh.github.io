<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="private,安卓优化," />










<meta name="description" content="深入探索 Android 内存优化本篇是 Android 内存优化的进阶篇，难度可以说达到了炼狱级别，建议对内存优化不是非常熟悉的仔细看看前篇文章： Android性能优化之内存优化，其中详细分析了以下几大模块：  1）、Android的内存管理机制 2）、优化内存的意义 3）、避免内存泄漏 4）、优化内存空间 5）、图片管理模块的设计与实现  如果你对以上基础内容都比较了解了，那么我们便开始 A">
<meta property="og:type" content="article">
<meta property="og:title" content="优化-深入探索Android内存优化">
<meta property="og:url" content="http://shenbh.github.io/posts/1b5cb750/index.html">
<meta property="og:site_name" content="AB">
<meta property="og:description" content="深入探索 Android 内存优化本篇是 Android 内存优化的进阶篇，难度可以说达到了炼狱级别，建议对内存优化不是非常熟悉的仔细看看前篇文章： Android性能优化之内存优化，其中详细分析了以下几大模块：  1）、Android的内存管理机制 2）、优化内存的意义 3）、避免内存泄漏 4）、优化内存空间 5）、图片管理模块的设计与实现  如果你对以上基础内容都比较了解了，那么我们便开始 A">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f43687a9164d92991056e717958001~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/474d3904c80846c9a4401a13b869dda7~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbb5e763b52642feabeaf2c53fe9ad2a~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/476f7ef262f94a269ff35f057f95e0dd~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11b50f4998d34df6a3412e09891d00a7~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c0743df8f634d3ab5904e60bf8979a2~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0da6b1b086bd4b5d81ad87b6795cbc27~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f410fd1ebeee4843b086e67ed770b408~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56a1a83e428047c5b080a4202bbb7d30~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2020-09-03T02:31:58.000Z">
<meta property="article:modified_time" content="2022-11-02T07:22:54.651Z">
<meta property="article:author" content="阿炳">
<meta property="article:tag" content="private">
<meta property="article:tag" content="安卓优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f43687a9164d92991056e717958001~tplv-k3u1fbpfcp-zoom-1.image">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://shenbh.github.io/posts/1b5cb750/"/>





  <title>优化-深入探索Android内存优化 | AB</title><meta name="robots" content="noindex">
  








<meta name="generator" content="Hexo 6.1.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AB</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Just do IT Now.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shenbh.github.io/posts/1b5cb750/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">优化-深入探索Android内存优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-03T10:31:58+08:00">
                2020-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="深入探索-Android-内存优化"><a href="#深入探索-Android-内存优化" class="headerlink" title="深入探索 Android 内存优化"></a><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904099998089230">深入探索 Android 内存优化</a></h1><p>本篇是 Android 内存优化的进阶篇，难度可以说达到了炼狱级别，建议对内存优化不是非常熟悉的仔细看看前篇文章： <a target="_blank" rel="noopener" href="https://juejin.im/post/6844904096541966350">Android性能优化之内存优化</a>，其中详细分析了以下几大模块：</p>
<ul>
<li>1）、Android的内存管理机制</li>
<li>2）、优化内存的意义</li>
<li>3）、避免内存泄漏</li>
<li>4）、优化内存空间</li>
<li>5）、图片管理模块的设计与实现</li>
</ul>
<p>如果你对以上基础内容都比较了解了，那么我们便开始 Android 内存优化的探索之旅吧。</p>
<blockquote>
<p>本篇文章非常长，建议收藏后慢慢享用~</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f43687a9164d92991056e717958001~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<h1 id="一、重识内存优化"><a href="#一、重识内存优化" class="headerlink" title="一、重识内存优化"></a>一、重识内存优化</h1><p>Android给每个应用进程分配的内存都是非常有限的，那么，<strong>为什么不能把图片下载下来都放到磁盘中呢</strong>？那是因为放在 <strong>内存</strong> 中，展示会更 “<strong>快</strong>”，快的原因有两点，如下所示：</p>
<ul>
<li>1）、<strong>硬件快</strong>：内存本身读取、存入速度快。</li>
<li>2）、<strong>复用快</strong>：解码成果有效保存，复用时，直接使用解码后对象，而不是再做一次图像解码。</li>
</ul>
<p>这里说一下解码的概念。Android系统要在屏幕上展示图片的时候只认 “<strong>像素缓冲</strong>”，而这也是大多数操作系统的特征。而我们 <strong>常见的jpg，png等图片格式，都是把 “像素缓冲” 使用不同的手段压缩后的结果</strong>，所以这些格式的图片，要在设备上 <strong>展示</strong>，就 <strong>必须经过一次解码</strong>，它的 <strong>执行速度会受图片压缩比、尺寸等因素影响</strong>。(官方建议：<strong>把从内存中淘汰的图片，降低压缩比后存储到本地，以备后用，这样可以最大限度地降低以后复用时的解码开销</strong>。)</p>
<p>下面，我们来了解一下内存优化的一些重要概念。</p>
<h2 id="1、手机RAM"><a href="#1、手机RAM" class="headerlink" title="1、手机RAM"></a>1、手机RAM</h2><p>手机不使用 <strong>PC</strong> 的 <strong>DDR内存</strong>，采用的是 <strong>LPDDR RAM</strong>，即 ”<strong>低功耗双倍数据速率内存</strong>“。其计算规则如下所示：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">LPDDR</span>系列的带宽 = 时钟频率 ✖️内存总线位数 / <span class="number">8</span></span><br><span class="line"><span class="attribute">LPDDR4</span> = <span class="number">1600</span>MHZ ✖️<span class="number">64</span> / <span class="number">8</span> ✖️双倍速率 = <span class="number">25</span>.<span class="number">6</span>GB/s。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="那么内存占用是否越少越好？"><a href="#那么内存占用是否越少越好？" class="headerlink" title="那么内存占用是否越少越好？"></a>那么内存占用是否越少越好？</h3><p>当系统 <strong>内存充足</strong> 的时候，我们可以 <strong>多用</strong> 一些获得 <strong>更好的性能</strong>。当系统 <strong>内存不足</strong> 的时候，我们希望可以做到 ”<strong>用时分配，及时释放</strong>“。</p>
<h2 id="2、内存优化的纬度"><a href="#2、内存优化的纬度" class="headerlink" title="2、内存优化的纬度"></a>2、内存优化的纬度</h2><p>对于Android内存优化来说又可以细分为如下两个维度，如下所示：</p>
<ul>
<li>1）、<strong>RAM优化</strong></li>
<li>2）、<strong>ROM优化</strong></li>
</ul>
<h3 id="1、RAM优化"><a href="#1、RAM优化" class="headerlink" title="1、RAM优化"></a>1、RAM优化</h3><p>主要是 <strong>降低运行时内存</strong>。它的 <strong>目的</strong> 有如下三个：</p>
<ul>
<li><strong>1）、防止应用发生OOM</strong>。</li>
<li><strong>2）、降低应用由于内存过大被LMK机制杀死的概率</strong>。</li>
<li><strong>3）、避免不合理使用内存导致GC次数增多，从而导致应用发生卡顿</strong>。</li>
</ul>
<h3 id="2、ROM优化"><a href="#2、ROM优化" class="headerlink" title="2、ROM优化"></a>2、ROM优化</h3><p>降低应用占ROM的体积，进行APK瘦身。它的 <strong>目的</strong> 主要是为了 <strong>降低应用占用空间，避免因ROM空间不足导致程序无法安装</strong>。</p>
<h2 id="3、内存问题"><a href="#3、内存问题" class="headerlink" title="3、内存问题"></a>3、内存问题</h2><p>那么，内存问题主要是有哪几类呢？内存问题通常来说，可以细分为如下 <strong>三类</strong>:</p>
<ul>
<li>1）、<strong>内存抖动</strong></li>
<li>2）、<strong>内存泄漏</strong></li>
<li>3）、<strong>内存溢出</strong></li>
</ul>
<p>下面，我们来了解下它们。</p>
<h3 id="1、内存抖动"><a href="#1、内存抖动" class="headerlink" title="1、内存抖动"></a>1、内存抖动</h3><p>内存波动图形呈 <strong>锯齿张</strong>、<strong>GC导致卡顿</strong>。</p>
<p>这个问题在 <strong>Dalvik虚拟机</strong> 上会 <strong>更加明显</strong>，而 <strong>ART虚拟机</strong> 在 <strong>内存管理跟回收策略</strong> 上都做了 <strong>大量优化</strong>，<strong>内存分配和GC效率相比提升了5~10倍</strong>，所以 <strong>出现内存抖动的概率会小很多</strong>。</p>
<h3 id="2、内存泄漏"><a href="#2、内存泄漏" class="headerlink" title="2、内存泄漏"></a>2、内存泄漏</h3><p>Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些还存活的对象作为内存遍历的根节点GC Roots，通过对GC Roots的可达性来判断是否需要回收。内存泄漏就是 <strong>在当前应用周期内不再使用的对象被GC Roots引用，导致不能回收，使实际可使用内存变小</strong>。简言之，就是 <strong>对象被持有导致无法释放或不能按照对象正常的生命周期进行释放</strong>。一般来说，<strong>可用内存减少、频繁GC，容易导致内存泄漏</strong>。</p>
<h3 id="3、内存溢出"><a href="#3、内存溢出" class="headerlink" title="3、内存溢出"></a>3、内存溢出</h3><p>即OOM，OOM时会导致程序异常。Android设备出厂以后，java虚拟机对单个应用的最大内存分配就确定下来了，超出这个值就会OOM。<strong>单个应用可用的最大内存对应于 &#x2F;system&#x2F;build.prop 文件中的 dalvik.vm.heapgrowthlimit</strong>。</p>
<p>此外，除了因内存泄漏累积到一定程度导致OOM的情况以外，也有一次性申请很多内存，比如说 <strong>一次创建大的数组或者是载入大的文件如图片的时候会导致OOM</strong>。而且，实际情况下 <strong>很多OOM就是因图片处理不当</strong> 而产生的。</p>
<h1 id="二、常见工具选择"><a href="#二、常见工具选择" class="headerlink" title="二、常见工具选择"></a>二、常见工具选择</h1><p>在 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844904096541966350#heading-24">Android性能优化之内存优化</a> 中我们已经介绍过了相关的优化工具，这里再简单回顾一下。</p>
<h2 id="1、Memory-Profiler"><a href="#1、Memory-Profiler" class="headerlink" title="1、Memory Profiler"></a>1、Memory Profiler</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>1）、<strong>实时图表展示应用内存使用量</strong>。</li>
<li>2）、<strong>用于识别内存泄漏、抖动等</strong>。</li>
<li>3）、<strong>提供捕获堆转储、强制GC以及根据内存分配的能力</strong>。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>1）、<strong>方便直观</strong></li>
<li>2）、<strong>线下使用</strong></li>
</ul>
<h2 id="2、Memory-Analyzer"><a href="#2、Memory-Analyzer" class="headerlink" title="2、Memory Analyzer"></a>2、Memory Analyzer</h2><p>强大的 <strong>Java Heap</strong> 分析工具，查找 <strong>内存泄漏及内存占用</strong>， 生成 <strong>整体报告</strong>、<strong>分析内存问题</strong> 等等。建议 <strong>线下深入使用</strong>。</p>
<h2 id="3、LeakCanary"><a href="#3、LeakCanary" class="headerlink" title="3、LeakCanary"></a>3、LeakCanary</h2><p><strong>自动化</strong> 内存泄漏检测神器。建议仅用于<strong>线下集成</strong>。</p>
<p>它的 <strong>缺点</strong> 比较明显，具体有如下两点：</p>
<ul>
<li>1）、虽然使用了 <strong>idleHandler与多进程</strong>，但是 <strong>dumphprof 的 SuspendAll Thread 的特性依然会导致应用卡顿</strong>。</li>
<li>2）、<strong>在三星等手机，系统会缓存最后一个Activity，此时应该采用更严格的检测模式</strong>。</li>
</ul>
<h1 id="三、Android内存管理机制回顾"><a href="#三、Android内存管理机制回顾" class="headerlink" title="三、Android内存管理机制回顾"></a>三、Android内存管理机制回顾</h1><p>ART 和 Dalvik 虚拟机使用 <strong>分页和内存映射</strong> 来管理内存。下面我们先从Java的内存分配开始说起。</p>
<h2 id="1、Java-内存分配"><a href="#1、Java-内存分配" class="headerlink" title="1、Java 内存分配"></a>1、Java 内存分配</h2><p>Java的 <strong>内存分配区域</strong> 分为如下 <strong>五部分</strong>：</p>
<ul>
<li><strong>1）、方法区：主要存放静态常量</strong>。</li>
<li><strong>2）、虚拟机栈：Java变量引用</strong>。</li>
<li><strong>3）、本地方法栈：native变量引用</strong>。</li>
<li><strong>4）、堆：对象</strong>。</li>
<li><strong>5）、程序计数器：计算当前线程的当前方法执行到多少行</strong>。</li>
</ul>
<h2 id="2、Java-内存回收算法"><a href="#2、Java-内存回收算法" class="headerlink" title="2、Java 内存回收算法"></a>2、Java 内存回收算法</h2><h3 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a>1、标记-清除算法</h3><p>流程可简述为 <strong>两步</strong>：</p>
<ul>
<li><strong>1）、标记所有需要回收的对象</strong>。</li>
<li><strong>2）、统一回收所有被标记的对象</strong>。</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>实现比较简单。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>1）、标记、清除<strong>效率不高</strong>。</li>
<li>2）、产生<strong>大量内存碎片</strong>。</li>
</ul>
<h3 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h3><p>流程可简述为 <strong>三步</strong>：</p>
<ul>
<li><strong>1）、将内存划分为大小相等的两块</strong>。</li>
<li><strong>2）、一块内存用完之后复制存活对象到另一块</strong>。</li>
<li><strong>3）、清理另一块内存</strong>。</li>
</ul>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>实现简单，运行高效，<strong>每次仅需遍历标记一半的内存区域</strong>。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>会<strong>浪费一半的空间</strong>，代价大。</p>
<h3 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a>3、标记-整理算法</h3><p>流程可简述为 <strong>三步</strong>：</p>
<ul>
<li><strong>1）、标记过程与 标记-清除算法 一样</strong>。</li>
<li><strong>2）、存活对象往一端进行移动</strong>。</li>
<li><strong>3）、清理其余内存</strong>。</li>
</ul>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>1）、避免 标记-清除 导致的内存碎片</strong>。</li>
<li><strong>2）、避免复制算法的空间浪费</strong>。</li>
</ul>
<h3 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h3><p>现在 <strong>主流的虚拟机</strong> 一般用的比较多的还是分代收集算法，它具有如下 <strong>特点</strong>：</p>
<ul>
<li><strong>1）、结合多种算法优势</strong>。</li>
<li><strong>2）、新生代对象存活率低，使用 复制算法</strong>。</li>
<li><strong>3）、老年代对象存活率高，使用 标记-整理算法</strong>。</li>
</ul>
<h2 id="3、Android-内存管理机制"><a href="#3、Android-内存管理机制" class="headerlink" title="3、Android 内存管理机制"></a>3、Android 内存管理机制</h2><p>Android 中的内存是 <strong>弹性分配</strong> 的，<strong>分配值 与 最大值 受具体设备影响</strong>。</p>
<p>对于 <strong>OOM场景</strong> 其实可以细分为如下两种：</p>
<ul>
<li><strong>1）、内存真正不足</strong>。</li>
<li><strong>2）、可用（被分配的）内存不足</strong>。</li>
</ul>
<p>我们需要着重注意一下这两种的区分。</p>
<h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><p>以Android中虚拟机的角度来说，我们要清楚 <strong>Dalvik 与 ART 区别</strong>，<strong>Dalvik</strong> 仅固定<strong>一种回收算法</strong>，而 <strong>ART</strong> 回收算法可在 <strong>运行期按需选择</strong>，并且，<strong>ART</strong> 具备 <strong>内存整理</strong> 能力，<strong>减少内存空洞</strong>。</p>
<p>最后，<strong>LMK（Low Memory killer）</strong> 机制保证了<strong>进程资源的合理利用</strong>，它的<strong>实现原理</strong>主要是 <strong>根据进程分类和回收收益来综合决定的一套算法集</strong>。</p>
<h1 id="四、内存抖动"><a href="#四、内存抖动" class="headerlink" title="四、内存抖动"></a>四、内存抖动</h1><p>当 <strong>内存频繁分配和回收</strong> 导致内存 <strong>不稳定</strong>，就会出现内存抖动，它通常表现为  <strong>频繁GC、内存曲线呈锯齿状</strong>。</p>
<p>并且，它的危害也很严重，通常会导致 <strong>页面卡顿</strong>，甚至造成 <strong>OOM</strong>。</p>
<h2 id="1、那么，为什么内存抖动会导致-OOM？"><a href="#1、那么，为什么内存抖动会导致-OOM？" class="headerlink" title="1、那么，为什么内存抖动会导致 OOM？"></a>1、那么，为什么内存抖动会导致 OOM？</h2><p>主要原因有如下两点：</p>
<ul>
<li>1）、<strong>频繁创建对象，导致内存不足及碎片（不连续）</strong>。</li>
<li>2）、<strong>不连续的内存片无法被分配，导致OOM</strong>。</li>
</ul>
<h2 id="2、内存抖动解决实战"><a href="#2、内存抖动解决实战" class="headerlink" title="2、内存抖动解决实战"></a>2、内存抖动解决实战</h2><p>这里我们假设有这样一个场景：点击按钮使用 handler 发送一个空消息，handler 的 handleMessage 接收到消息后创建内存抖动，即在 for 循环创建 100个容量为10万 的 strings 数组并在 30ms 后继续发送空消息。</p>
<p>一般使用 <strong>Memory Profiler （表现为 频繁GC、内存曲线呈锯齿状）结合代码排查</strong>即可找到内存抖动出现的地方。</p>
<p>通常的技巧就是着重查看 <strong>循环或频繁被调用</strong> 的地方。</p>
<h2 id="3、内存抖动常见案例"><a href="#3、内存抖动常见案例" class="headerlink" title="3、内存抖动常见案例"></a>3、内存抖动常见案例</h2><p>下面列举一些导致内存抖动的常见案例，如下所示：</p>
<h3 id="1、字符串使用加号拼接"><a href="#1、字符串使用加号拼接" class="headerlink" title="1、字符串使用加号拼接"></a>1、字符串使用加号拼接</h3><ul>
<li>1）、<strong>使用StringBuilder替代</strong>。</li>
<li>2）、<strong>初始化时设置容量，减少StringBuilder的扩容</strong>。</li>
</ul>
<h3 id="2、资源复用"><a href="#2、资源复用" class="headerlink" title="2、资源复用"></a>2、资源复用</h3><ul>
<li>1）、使用 <strong>全局缓存池</strong>，以 <strong>重用频繁申请和释放的对象</strong>。</li>
<li>2）、注意 <strong>结束</strong> 使用后，需要 <strong>手动释放对象池中的对象</strong>。</li>
</ul>
<h3 id="3、减少不合理的对象创建"><a href="#3、减少不合理的对象创建" class="headerlink" title="3、减少不合理的对象创建"></a>3、减少不合理的对象创建</h3><ul>
<li>1）、<strong>ondraw、getView 中创建的对象尽量进行复用</strong>。</li>
<li>2）、<strong>避免在循环中不断创建局部变量</strong>。</li>
</ul>
<h3 id="4、使用合理的数据结构"><a href="#4、使用合理的数据结构" class="headerlink" title="4、使用合理的数据结构"></a>4、使用合理的数据结构</h3><p>使用 <strong>SparseArray类族、ArrayMap</strong> 来替代 <strong>HashMap</strong>。</p>
<h1 id="五、内存优化体系化搭建"><a href="#五、内存优化体系化搭建" class="headerlink" title="五、内存优化体系化搭建"></a>五、内存优化体系化搭建</h1><p>在开始我们今天正式的主题之前，我们先来回归一下内存泄漏的概念与解决技巧。</p>
<p>所谓的内存泄漏就是 <strong>内存中存在已经没有用的对象</strong>。它的 <strong>表现</strong> 一般为  <strong>内存抖动、可用内存逐渐减少</strong>。 它的 <strong>危害</strong> 即会导致 <strong>内存不足、GC频繁、OOM</strong>。</p>
<p>而对于 <strong>内存泄漏的分析</strong> 一般可简述为如下 <strong>两步</strong>：</p>
<ul>
<li>1）、<strong>使用 Memory Profiler 初步观察</strong>。</li>
<li>2）、<strong>通过 Memory Analyzer 结合代码确认</strong>。</li>
</ul>
<h2 id="1、MAT回顾"><a href="#1、MAT回顾" class="headerlink" title="1、MAT回顾"></a>1、MAT回顾</h2><h3 id="MAT查找内存泄漏"><a href="#MAT查找内存泄漏" class="headerlink" title="MAT查找内存泄漏"></a>MAT查找内存泄漏</h3><p>对于MAT来说，其常规的查找内存泄漏的方式可以细分为如下三步：</p>
<ul>
<li>1）、首先，<strong>找到当前 Activity，在 Histogram 中选择其 List Objects 中的 with incoming reference（哪些引用引向了我）</strong>。</li>
<li>2）、然后，<strong>选择当前的一个 Path to GC Roots&#x2F;Merge to GC Roots 的 exclude All 弱软虚引用</strong>。</li>
<li>3）、最后，<strong>找到的泄漏对象在左下角下会有一个小圆圈</strong>。</li>
</ul>
<p>此外，在 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844904096541966350">Android性能优化之内存优化</a> 还有几种进阶的使用方式，这里就不一一赘述了，下面，我们来看看关于 MAT 使用时的一些关键细节。</p>
<h3 id="MAT的关键使用细节"><a href="#MAT的关键使用细节" class="headerlink" title="MAT的关键使用细节"></a>MAT的关键使用细节</h3><p>要全面掌握MAT的用法，必须要先了解 <strong>隐藏在 MAT 使用中的四大细节</strong>，如下所示：</p>
<ul>
<li><p>1）、<strong>善于使用 Regex 查找对应泄漏类</strong>。</p>
</li>
<li><p>2）、<strong>使用 group by package 查找对应包下的具体类</strong>。</p>
</li>
<li><p>3）、</p>
<p>明白 with outgoing references 和 with incoming references 的区别</p>
<p>。</p>
<ul>
<li><strong>with outgoing references：它引用了哪些对象</strong>。</li>
<li><strong>with incoming references：哪些对象引用了它</strong>。</li>
</ul>
</li>
<li><p>4）、</p>
<p>了解 Shallow Heap 和 Retained Heap 的区别</p>
<p>。</p>
<ul>
<li><strong>Shallow Heap：表示对象自身占用的内存</strong>。</li>
<li><strong>Retained Heap：对象自身占用的内存 + 对象引用的对象所占用的内存</strong>。</li>
</ul>
</li>
</ul>
<h3 id="MAT-关键组件回顾"><a href="#MAT-关键组件回顾" class="headerlink" title="MAT 关键组件回顾"></a>MAT 关键组件回顾</h3><p>除此之外，MAT 共有 <strong>5个关键组件</strong> 帮助我们去分析内存方面的问题，分别如下所示：</p>
<ul>
<li>1）、<strong>Dominator_tree</strong></li>
<li>2）、<strong>Histogram</strong></li>
<li>3）、<strong>thread_overview</strong></li>
<li>4）、<strong>Top Consumers</strong></li>
<li>5）、<strong>Leak Suspects</strong></li>
</ul>
<p>下面我们这里再简单地回顾一下它们。</p>
<h4 id="1、Dominator（支配者）："><a href="#1、Dominator（支配者）：" class="headerlink" title="1、Dominator（支配者）："></a>1、Dominator（支配者）：</h4><p>如果从GC Root到达对象A的路径上必须经过对象B，那么B就是A的支配者。</p>
<h4 id="2、Histogram和dominator-tree的区别："><a href="#2、Histogram和dominator-tree的区别：" class="headerlink" title="2、Histogram和dominator_tree的区别："></a>2、Histogram和dominator_tree的区别：</h4><ul>
<li>1）、Histogram 显示 Shallow Heap、Retained Heap、<strong>Objects</strong>，而 dominator_tree 显示的是 Shallow Heap、Retained Heap、<strong>Percentage</strong>。</li>
<li>2）、Histogram 基于 <strong>类</strong> 的角度，dominator_tree是基于 <strong>实例</strong> 的角度。<strong>Histogram 不会具体显示每一个泄漏的对象，而dominator_tree会</strong>。</li>
</ul>
<h4 id="3、thread-overview"><a href="#3、thread-overview" class="headerlink" title="3、thread_overview"></a>3、thread_overview</h4><p>查看 <strong>线程数量</strong> 和 <strong>线程的 Shallow Heap、Retained Heap、Context Class Loader 与 is Daemon</strong>。</p>
<h4 id="4、Top-Consumers"><a href="#4、Top-Consumers" class="headerlink" title="4、Top Consumers"></a>4、Top Consumers</h4><p>通过 <strong>图形</strong> 的形式列出 <strong>占用内存比较多的对象</strong>。</p>
<p>在下方的 <strong>Biggest Objects</strong> 还可以查看其 <strong>相对比较详细的信息</strong>，例如 <strong>Shallow Heap、Retained Heap</strong>。</p>
<h4 id="5、Leak-Suspects"><a href="#5、Leak-Suspects" class="headerlink" title="5、Leak Suspects"></a>5、Leak Suspects</h4><p><strong>列出有内存泄漏的地方，点击 Details 可以查看其产生内存泄漏的引用链</strong>。</p>
<h2 id="2、搭建体系化的图片优化-x2F-监控机制"><a href="#2、搭建体系化的图片优化-x2F-监控机制" class="headerlink" title="2、搭建体系化的图片优化 &#x2F; 监控机制"></a>2、搭建体系化的图片优化 &#x2F; 监控机制</h2><p>在介绍图片监控体系的搭建之前，首先我们来回顾下 <strong>Android Bitmap 内存分配的变化</strong>。</p>
<h3 id="Android-Bitmap-内存分配的变化"><a href="#Android-Bitmap-内存分配的变化" class="headerlink" title="Android Bitmap 内存分配的变化"></a>Android Bitmap 内存分配的变化</h3><h4 id="在Android-3-0之前"><a href="#在Android-3-0之前" class="headerlink" title="在Android 3.0之前"></a>在Android 3.0之前</h4><ul>
<li>1）、<strong>Bitmap 对象存放在 Java Heap，而像素数据是存放在 Native 内存中的</strong>。</li>
<li>2）、<strong>如果不手动调用 recycle，Bitmap Native 内存的回收完全依赖 finalize 函数回调，但是回调时机是不可控的</strong>。</li>
</ul>
<h4 id="Android-3-0-Android-7-0"><a href="#Android-3-0-Android-7-0" class="headerlink" title="Android 3.0 ~ Android 7.0"></a>Android 3.0 ~ Android 7.0</h4><p>将 <strong>Bitmap对象</strong> 和 <strong>像素数据</strong> 统一放到 <strong>Java Heap</strong> 中，即使不调用 recycle，Bitmap 像素数据也会随着对象一起被回收。</p>
<p>但是，Bitmap 全部放在 Java Heap 中的缺点很明显，大致有如下两点：</p>
<ul>
<li>1）、<strong>Bitmap是内存消耗的大户，而 Max Java Heap 一般限制为 256、512MB，Bitmap 过大过多容易导致 OOM</strong>。</li>
<li>2）、<strong>容易引起大量 GC，没有充分利用系统的可用内存</strong>。</li>
</ul>
<h4 id="Android-8-0及以后"><a href="#Android-8-0及以后" class="headerlink" title="Android 8.0及以后"></a>Android 8.0及以后</h4><ul>
<li>1）、<strong>使用了能够辅助回收 Native 内存的 <a href="https://link.juejin.cn/?target=https://www.androidos.net.cn/android/8.0.0_r4/xref/libcore/luni/src/main/java/libcore/util/NativeAllocationRegistry.java">NativeAllocationRegistry</a>，以实现将像素数据放到 Native 内存中，并且可以和 Bitmap 对象一起快速释放，最后，在 GC 的时候还可以考虑到这些 Bitmap 内存以防止被滥用</strong>。</li>
<li>2）、Android 8.0 为了 <strong>解决图片内存占用过多和图像绘制效率过慢</strong> 的问题新增了 **<a href="https://link.juejin.cn/?target=https://blog.csdn.net/weixin_34208185/article/details/88032954">硬件位图 Hardware Bitmap</a>**。</li>
</ul>
<h3 id="那么，我们如何将图片内存存放在-Native-中呢？"><a href="#那么，我们如何将图片内存存放在-Native-中呢？" class="headerlink" title="那么，我们如何将图片内存存放在 Native 中呢？"></a>那么，我们如何将图片内存存放在 Native 中呢？</h3><p>将图片内存存放在Native中的步骤有 <strong>四步</strong>，如下所示：</p>
<ul>
<li>1）、<strong>调用 libandroid_runtime.so 中的 Bitmap 构造函数，申请一张空的 Native Bitmap。对于不同 Android 版本而言，这里的获取过程都有一些差异需要适配</strong>。</li>
<li>2）、<strong>申请一张普通的 Java Bitmap</strong>。</li>
<li>3）、<strong>将 Java Bitmap 的内容绘制到 Native Bitmap 中</strong>。</li>
<li>4）、<strong>释放 Java Bitmap 内存</strong>。</li>
</ul>
<p>我们都知道的是，当 <strong>系统内存不足</strong> 的时候，<strong>LMK</strong> 会根据 <strong>OOM_adj</strong> 开始杀进程，从 <strong>后台、桌面、服务、前台，直到手机重启</strong>。并且，如果频繁申请释放 Java Bitmap 也很容易导致内存抖动。对于这种种问题，我们该 <strong>如何评估内存对应用性能的影响</strong> 呢？</p>
<p>对此，我们可以主要从以下 <strong>两个方面</strong> 进行评估，如下所示：</p>
<ul>
<li>1）、<strong>崩溃中异常退出和 OOM 的比例</strong>。</li>
<li>2）、<strong>低内存设备更容易出现内存不足和卡顿，需要查看应用中用户的手机内存在 2GB 以下所占的比例</strong>。</li>
</ul>
<p>对于具体的优化策略与手段，我们可以从以下 <strong>七个方面</strong> 来搭建一套 <strong>成体系化的图片优化 &#x2F; 监控机制</strong>。</p>
<h3 id="1、统一图片库"><a href="#1、统一图片库" class="headerlink" title="1、统一图片库"></a>1、统一图片库</h3><p>在项目中，我们需要 <strong>收拢图片的调用，避免使用 Bitmap.createBitmap、BitmapFactory 相关的接口创建 Bitmap，而应该使用自己的图片框架</strong>。</p>
<h3 id="2、设备分级优化策略"><a href="#2、设备分级优化策略" class="headerlink" title="2、设备分级优化策略"></a>2、设备分级优化策略</h3><p>内存优化首先需要根据 <strong>设备环境</strong> 来综合考虑，<strong>让高端设备使用更多的内存</strong>，做到 <strong>针对设备性能的好坏使用不同的内存分配和回收策略</strong>。</p>
<p>因此，我们可以使用类似 <a href="https://link.juejin.cn/?target=https://github.com/facebookarchive/device-year-class">device-year-class</a> 的策略对设备进行分级，<strong>对于低端机用户可以关闭复杂的动画或”重功能“，使用565格式的图片或更小的缓存内存</strong> 等等。</p>
<p>业务开发人员需要 <strong>考虑功能是否对低端机开启，在系统资源不够时主动去做降级处理</strong>。</p>
<h3 id="3、建立统一的缓存管理组件"><a href="#3、建立统一的缓存管理组件" class="headerlink" title="3、建立统一的缓存管理组件"></a>3、建立统一的缓存管理组件</h3><p><strong>建立统一的缓存管理组件（参考 <a href="https://link.juejin.cn/?target=https://github.com/yangfuhai/ASimpleCache">ACache</a>），并合理使用 OnTrimMemory &#x2F; LowMemory 回调，根据系统不同的状态去释放相应的缓存与内存</strong>。</p>
<p>在实现过程中，需要 <strong>解决使用 static LRUCache 来缓存大尺寸 Bitmap 的问题</strong>。</p>
<p>并且，在通过实际的测试后，发现 <strong>onTrimMemory 的 ComponetnCallbacks2.TRIM_MEMORY_COMPLETE 并不等价于 onLowMemory，因此建议仍然要去监听 onLowMemory 回调</strong>。</p>
<h3 id="4、低端机避免使用多进程"><a href="#4、低端机避免使用多进程" class="headerlink" title="4、低端机避免使用多进程"></a>4、低端机避免使用多进程</h3><p>一个 <strong>空进程</strong> 也会占用 <strong>10MB</strong> 内存，低端机应该尽可能减少使用多进程。</p>
<p>针对低端机用户可以推出 <strong>4MB 的轻量级版本</strong>，如今日头条极速版、Facebook Lite。</p>
<h3 id="5、线下大图片检测"><a href="#5、线下大图片检测" class="headerlink" title="5、线下大图片检测"></a>5、线下大图片检测</h3><p><strong>在开发过程中，如果检测到不合规的图片使用（如图片宽度超过View的宽度甚至屏幕宽度），应该立刻提示图片所在的Activity和堆栈，让开发人员更快发现并解决问题。在灰度和线上环境，可以将异常信息上报到后台，还可以计算超宽率（图片超过屏幕大小所占图片总数的比例）</strong>。</p>
<p>下面，我们介绍下如何实现对大图片的检测。</p>
<h4 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h4><p>继承 ImageView，重写实现计算图片大小。但是侵入性强，并且不通用。</p>
<p>因此，这里我们介绍一种更好的方案：ARTHook。</p>
<h4 id="ARTHook优雅检测大图"><a href="#ARTHook优雅检测大图" class="headerlink" title="ARTHook优雅检测大图"></a>ARTHook优雅检测大图</h4><p><strong>ARTHook</strong>，即 <strong>挂钩，用额外的代码勾住原有的方法，以修改执行逻辑</strong>，主要可以用于以下四个方面：</p>
<ul>
<li>1）、<strong>AOP编程</strong></li>
<li>2）、<strong>运行时插桩</strong></li>
<li>3）、<strong>性能分析</strong></li>
<li>4）、<strong>安全审计</strong></li>
</ul>
<p>具体我们是使用 <strong>Epic</strong> 来进行 Hook，Epic 是 <strong>一个虚拟机层面，以 Java 方法为粒度的运行时 Hook 框架</strong>。简单来说，它就是 <strong>ART 上的 Dexposed</strong>，并且它目前 <strong>支持 Android 4.0~10.0</strong>。</p>
<p><a href="https://link.juejin.cn/?target=https://github.com/tiann/epic/blob/master/README_cn.md">Epic github 地址</a></p>
<h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><p>Epic通常的使用步骤为如下三个步骤：</p>
<p>1、在项目 moudle 的 build.gradle 中添加</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">compile</span> &#x27;me.weishu:epic:<span class="number">0</span>.<span class="number">6</span>.<span class="number">0</span>&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、继承 XC_MethodHook，实现 Hook 方法前后的逻辑。如 <strong>监控Java线程的创建和销毁</strong>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethodHook</span> <span class="keyword">extends</span> <span class="title">XC_MethodHook</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void beforeHookedMethod(<span class="type">MethodHookParam</span> param) <span class="keyword">throws</span> <span class="type">Throwable</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeHookedMethod(param);</span><br><span class="line">        <span class="type">Thread</span> t = (<span class="type">Thread</span>) param.thisObject;</span><br><span class="line">        <span class="type">Log</span>.i(<span class="type">TAG</span>, <span class="string">&quot;thread:&quot;</span> + t + <span class="string">&quot;, started..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void afterHookedMethod(<span class="type">MethodHookParam</span> param) <span class="keyword">throws</span> <span class="type">Throwable</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">        <span class="type">Thread</span> t = (<span class="type">Thread</span>) param.thisObject;</span><br><span class="line">        <span class="type">Log</span>.i(<span class="type">TAG</span>, <span class="string">&quot;thread:&quot;</span> + t + <span class="string">&quot;, exit..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、注入 Hook 好的方法：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">DexposedBridge</span>.</span></span>find<span class="constructor">AndHookMethod(Thread.<span class="params">class</span>, <span class="string">&quot;run&quot;</span>, <span class="params">new</span> ThreadMethodHook()</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>知道了 Epic 的基本使用方法之后，我们便可以利用它来实现大图片的监控报警了。</p>
<h5 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h5><p>以 <a href="https://link.juejin.cn/?target=https://github.com/JsonChao/Awesome-WanAndroid">Awesome-WanAndroid</a> 项目为例，首先，在 WanAndroidApp 的 onCreate 方法中添加如下代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">DexposedBridge</span>.</span></span>hook<span class="constructor">AllConstructors(ImageView.<span class="params">class</span>, <span class="params">new</span> XC_MethodHook()</span> &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void after<span class="constructor">HookedMethod(MethodHookParam <span class="params">param</span>)</span> throws Throwable &#123;</span><br><span class="line">            super.after<span class="constructor">HookedMethod(<span class="params">param</span>)</span>;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">DexposedBridge</span>.</span></span>find<span class="constructor">AndHookMethod(ImageView.<span class="params">class</span>, <span class="string">&quot;setImageBitmap&quot;</span>, Bitmap.<span class="params">class</span>, <span class="params">new</span> ImageHook()</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在注释1处，我们 <strong>通过调用 DexposedBridge 的 findAndHookMethod 方法找到所有通过 ImageView 的 setImageBitmap 方法设置的切入点</strong>，其中最后一个参数 ImageHook 对象是继承了 XC_MethodHook 类，其目的是为了 <strong>重写 afterHookedMethod 方法拿到相应的参数进行监控逻辑的判断</strong>。</p>
<p>接下来，我们来实现我们的 ImageHook 类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageHook</span> <span class="keyword">extends</span> <span class="title class_">XC_MethodHook</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> (ImageView) param.thisObject;</span><br><span class="line">        checkBitmap(imageView,((ImageView) param.thisObject).getDrawable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkBitmap</span><span class="params">(Object thiz, Drawable drawable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> BitmapDrawable &amp;&amp; thiz <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> ((BitmapDrawable) drawable).getBitmap();</span><br><span class="line">            <span class="keyword">if</span> (bitmap != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> (View) thiz;</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> view.getWidth();</span><br><span class="line">                <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> view.getHeight();</span><br><span class="line">                <span class="keyword">if</span> (width &gt; <span class="number">0</span> &amp;&amp; height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2、图标宽高都大于view的2倍以上，则警告</span></span><br><span class="line">                    <span class="keyword">if</span> (bitmap.getWidth() &gt;= (width &lt;&lt; <span class="number">1</span>)</span><br><span class="line">                        &amp;&amp;  bitmap.getHeight() &gt;= (height &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                    warn(bitmap.getWidth(), bitmap.getHeight(), width, height, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Bitmap size too large&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3、当宽高度等于0时，说明ImageView还没有进行绘制，使用ViewTreeObserver进行大图检测的处理。</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Throwable</span> <span class="variable">stackTrace</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">                    view.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">new</span> <span class="title class_">ViewTreeObserver</span>.OnPreDrawListener() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onPreDraw</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> view.getWidth();</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> view.getHeight();</span><br><span class="line">                            <span class="keyword">if</span> (w &gt; <span class="number">0</span> &amp;&amp; h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (bitmap.getWidth() &gt;= (w &lt;&lt; <span class="number">1</span>)</span><br><span class="line">                                    &amp;&amp; bitmap.getHeight() &gt;= (h &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                                    warn(bitmap.getWidth(), bitmap.getHeight(), w, h, stackTrace);</span><br><span class="line">                                &#125;</span><br><span class="line">                                view.getViewTreeObserver().removeOnPreDrawListener(<span class="built_in">this</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(<span class="type">int</span> bitmapWidth, <span class="type">int</span> bitmapHeight, <span class="type">int</span> viewWidth, <span class="type">int</span> viewHeight, Throwable t)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">warnInfo</span> <span class="operator">=</span> <span class="string">&quot;Bitmap size too large: &quot;</span> +</span><br><span class="line">            <span class="string">&quot;\n real size: (&quot;</span> + bitmapWidth + <span class="string">&#x27;,&#x27;</span> + bitmapHeight + <span class="string">&#x27;)&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;\n desired size: (&quot;</span> + viewWidth + <span class="string">&#x27;,&#x27;</span> + viewHeight + <span class="string">&#x27;)&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;\n call stack trace: \n&quot;</span> + Log.getStackTraceString(t) + <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        LogHelper.i(warnInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，在注释1处，我们<strong>重写了 ImageHook 的 afterHookedMethod 方法，拿到了当前的 ImageView 和要设置的 Bitmap 对象</strong>。然后，在注释2处，<strong>如果当前 ImageView 的宽高大于0，我们便进行大图检测的处理：ImageView 的宽高都大于 View 的2倍以上，则警告</strong>。接着，在注释3处，<strong>如果当前 ImageView 的宽高等于0，则说明 ImageView 还没有进行绘制，则使用 ImageView 的 ViewTreeObserver 获取其宽高进行大图检测的处理</strong>。至此，我们的大图检测检测组件就已经实现了。如果有小伙伴对 <strong>epic</strong> 的实现原理感兴趣的，可以查看<a href="https://link.juejin.cn/?target=http://weishu.me/2017/11/23/dexposed-on-art/">这篇文章</a>。</p>
<h5 id="ARTHook方案实现小结"><a href="#ARTHook方案实现小结" class="headerlink" title="ARTHook方案实现小结"></a>ARTHook方案实现小结</h5><ul>
<li>1）、<strong>无侵入性</strong></li>
<li>2）、<strong>通用性强</strong></li>
<li>3）、<strong>兼容性问题大，开源方案不能带到线上环境</strong>。</li>
</ul>
<h3 id="6、线下重复图片检测"><a href="#6、线下重复图片检测" class="headerlink" title="6、线下重复图片检测"></a>6、线下重复图片检测</h3><p>首先我们来了解一下这里的 <strong>重复图片</strong> 所指的概念： 即 <strong>Bitmap 像素数据完全一致，但是有多个不同的对象存在</strong>。</p>
<p><strong>重复图片检测的原理其实就是 使用内存 Hprof 分析工具，自动将重复 Bitmap 的图片和引用堆栈输出</strong>。</p>
<p><a href="https://link.juejin.cn/?target=https://github.com/JsonChao/Chapter04">已完全配置好的项目请参见这里</a></p>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>使用非常简单，只需要修改 <strong>Main</strong> 类的 <strong>main</strong> 方法的第一行代码，如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/ 设置我们自己 App 中对应的 hprof 文件路径</span></span><br><span class="line"><span class="regexp">String dumpFilePath = &quot;/</span><span class="regexp">/Users/</span><span class="regexp">/quchao/</span><span class="regexp">/Documents/</span><span class="regexp">/heapdump/</span><span class="regexp">/memory-40.hprof&quot;;</span></span><br><span class="line"><span class="regexp"></span></span><br></pre></td></tr></table></figure>

<p>然后，我们执行 <strong>main</strong> 方法即可在 <strong>&#x2F;&#x2F;Users&#x2F;&#x2F;quchao&#x2F;&#x2F;Documents&#x2F;&#x2F;heapdump</strong> 这个路径下看到生成的 <strong>images</strong> 文件夹，里面保存了项目中检测出来的重复的图片。<strong>images</strong> 目录如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/474d3904c80846c9a4401a13b869dda7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<blockquote>
<p>注意：需要使用 8.0 以下的机器，因为 8.0 及以后 Bitmap 中的 buffer 已保存在 native 内存之中。</p>
</blockquote>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>具体的实现可以细分为如下三个步骤：</p>
<ul>
<li>1）、首先，<strong>获取 android.graphics.Bitmap 实例对象的 mBuffer 作为 ArrayInstance ，通过 getValues 获取的数据为 Object 类型</strong>。由于后面计算 md5 需要为 byte[] 类型，所以<strong>通过反射的方式调用 ArrayInstance#asRawByteArray 直接返回 byte[] 数据</strong>。</li>
<li>2）、然后，<strong>根据 mBuffer 的数据生成 png 图片文件</strong>，这里直接参考了 <a href="https://link.juejin.cn/?target=https://github.com/JetBrains/adt-tools-base/blob/master/ddmlib/src/main/java/com/android/ddmlib/BitmapDecoder.java">github.com&#x2F;JetBrains&#x2F;a…</a> 的实现方式。</li>
<li>3）、最后，<strong>获取堆栈信息</strong>，直接 <strong>使用LeakCanary 获取 stack 的方法，使用 leakcanary-analyzer-1.6.2.jar 和 leakcanary-watcher-1.6.2.jar 这两个库文件</strong>。并用 <strong>反射</strong> 的方式调用了 <strong>HeapAnalyzer#findLeakTrace</strong> 方法。</li>
</ul>
<p>其中，<strong>获取堆栈</strong> 的信息也可以直接使用 <strong>haha</strong> 库来进行获取。这里简单说一下 <strong>使用 haha 库获取堆栈的流程</strong>，其具体可以细分为八个步骤，如下所示：</p>
<ul>
<li>1）、首先，<strong>预备一个已经存在重复 bitmap 的 hprof 文件</strong>。</li>
<li>2）、**利用 haha 库上的 MemoryMappedFileBuffer 读取 hrpof 文件 [关键代码 new MemoryMappedFileBuffer(heapDumpFile) ]**。</li>
<li>3）、**解析生成 snapshot，获取 heap，这里我只获取了 app heap [关键代码 snapshot.getHeaps(); heap.getName().equals(“app”) ]**。</li>
<li>4）、**从 snapshot 中根据指定 class 查找出所有的 Bitmap Classes [关键代码snapshot.findClasses(Bitmap.class.getName()) ]**。</li>
<li>5）、**从 heap 中获得所有的 Bitmap 实例 instance [关键代码 clazz.getHeapInstances(heap.getId()) ]**。</li>
<li>6）、<strong>根据 instance 中获取所有的属性信息 Field[]，并从 Field[] 查找出我们需要的 “mWidth” “mHeight” “mBuffer” 信息</strong>。</li>
<li>7）、<strong>通过 “mBuffer” 属性即可获取到他们的 hashcode 来判断是否是重复图片</strong>。</li>
<li>8）、最后，<strong>通过 instance 中 mNextInstanceToGcRoot 获取整个引用链信息并打印</strong>。</li>
</ul>
<h3 id="7、建立全局的线上-Bitmap-监控"><a href="#7、建立全局的线上-Bitmap-监控" class="headerlink" title="7、建立全局的线上 Bitmap 监控"></a>7、建立全局的线上 Bitmap 监控</h3><p>为了建立全局的 Bitmap 监控，我们必须 <strong>对 Bitmap 的分配和回收 进行追踪</strong>。我们先来看看 Bitmap 有哪些特点：</p>
<ul>
<li>1）、<strong>创建场景比较单一</strong>：在 Java 层调用 Bitmap.create 或 BitmapFactory 等方法创建，可以封装一层对 Bitmap 创建的接口，注意要 <strong>包含调用第三方库产生的 Bitmap</strong>，这里我们具体可以使用 <strong>ASM 编译插桩 + Gradle Transform</strong> 的方式来高效地实现。</li>
<li>2）、<strong>创建频率比较低</strong>。</li>
<li>3）、<strong>和 Java 对象的生命周期一样服从 GC，可以使用 WeakReference 来追踪 Bitmap 的销毁</strong>。</li>
</ul>
<p>根据以上特点，我们可以<strong>建立一套 Bitmap 的高性价比监控组件</strong>：</p>
<ul>
<li>1）、首先，在接口层将所有创建出来的 Bitmap 放入一个 WeakHashMap 中，并记录创建 Bitmap 的数据、堆栈等信息。</li>
<li>2）、然后，每隔一定时间查看 WeakHashMap 中有哪些 Bitmap 仍然存活来判断是否出现 Bitmap 滥用或泄漏。</li>
<li>3）、最后，如果发生了 Bitmap 滥用或泄露，则将相关的数据与堆栈等信息打印出来或上报至 APM 后台。</li>
</ul>
<p>这个方案的 <strong>性能消耗很低</strong>，可以在 <strong>正式环境</strong> 中进行。但是，需要注意的一点是，正式与测试环境需要采用不同程度的监控。</p>
<h2 id="3、建立线上应用内存监控体系"><a href="#3、建立线上应用内存监控体系" class="headerlink" title="3、建立线上应用内存监控体系"></a>3、建立线上应用内存监控体系</h2><p>要建立线上应用的内存监控体系，我们需要 <strong>先获取 App 的 DalvikHeap 与 NativeHeap</strong>，它们的获取方式可归结为如下四个步骤：</p>
<ul>
<li>1、首先，<strong>通过 ActivityManager 的 getProcessMemoryInfo &#x3D;&gt; Debug.MemoryInfo 获取内存信息数据</strong>。</li>
<li>2、然后，通过 <strong>hook Debug.MemoryInfo 的 getMemoryStat 方法（os v23 及以上）可以获得 Memory Profiler 中的多项数据</strong>，进而获得 <strong>细分内存的使用情况</strong>。</li>
<li>3、接着，<strong>通过 Runtime 获取 DalvikHeap</strong>。</li>
<li>4、最后，<strong>通过 Debug.getNativeHeapAllocatedSize 获取 NativeHeap</strong>。</li>
</ul>
<p>对于监控场景，我们需要将其划分为两大类，如下所示：</p>
<ul>
<li>1）、<strong>常规内存监控</strong></li>
<li>2）、<strong>低内存监控</strong></li>
</ul>
<h3 id="1、常规内存监控"><a href="#1、常规内存监控" class="headerlink" title="1、常规内存监控"></a>1、常规内存监控</h3><p><strong>根据 斐波那契数列 每隔一段时间（max：30min）获取内存的使用情况</strong>。常规内存的监控方法有多种实现方式，下面，我们按照 <strong>项目早期 &#x3D;&gt; 壮大期 &#x3D;&gt; 成熟期</strong> 的常规内存监控方式进行 <strong>演进式</strong> 讲解。</p>
<h4 id="项目早期：针对场景进行线上-Dump-内存的方式"><a href="#项目早期：针对场景进行线上-Dump-内存的方式" class="headerlink" title="项目早期：针对场景进行线上 Dump 内存的方式"></a>项目早期：针对场景进行线上 Dump 内存的方式</h4><p>具体使用 <strong>Debug.dumpHprofData()</strong> 实现。</p>
<p>其实现的流程为如下四个步骤：</p>
<ul>
<li>1）、**超过最大内存的 80%**。</li>
<li>2）、<strong>内存 Dump</strong>。</li>
<li>3）、<strong>回传文件至服务器</strong>。</li>
<li>4）、<strong>MAT 手动分析</strong>。</li>
</ul>
<p>但是，这种方式有如下几个缺点：</p>
<ul>
<li>1）、<strong>Dump文件太大，和对象数正相关，可以进行裁剪</strong>。</li>
<li>2）、<strong>上传失败率高，分析困难</strong>。</li>
</ul>
<h4 id="壮大期：LeakCanary带到线上的方式"><a href="#壮大期：LeakCanary带到线上的方式" class="headerlink" title="壮大期：LeakCanary带到线上的方式"></a>壮大期：LeakCanary带到线上的方式</h4><p>在使用 LeakCanary 的时候我们需要 <strong>预设泄漏怀疑点，一旦发现泄漏进行回传</strong>。但这种实现方式缺点比较明显，如下所示：</p>
<ul>
<li>1）、<strong>不适合所有情况，需要预设怀疑点</strong>。</li>
<li>2）、<strong>分析比较耗时，容易导致 OOM</strong>。</li>
</ul>
<h4 id="成熟期：定制-LeakCanary-方式"><a href="#成熟期：定制-LeakCanary-方式" class="headerlink" title="成熟期：定制 LeakCanary 方式"></a>成熟期：定制 LeakCanary 方式</h4><h5 id="那么，如何定制线上的LeakCanary？"><a href="#那么，如何定制线上的LeakCanary？" class="headerlink" title="那么，如何定制线上的LeakCanary？"></a>那么，如何定制线上的LeakCanary？</h5><p>定制 LeakCanary 其实就是对 <strong>haha组件</strong> 来进行 <strong>定制</strong>。haha库是 <strong>square</strong> 出品的一款 <strong>自动分析Android堆栈的java库</strong>。这是haha库的 <a href="https://link.juejin.cn/?target=https://github.com/square/haha">链接地址</a>。</p>
<p>对于haha库，它的 <strong>基本用法</strong> 一般遵循为如下四个步骤：</p>
<h4 id="1、导出堆栈文件"><a href="#1、导出堆栈文件" class="headerlink" title="1、导出堆栈文件"></a>1、导出堆栈文件</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File heapDumpFile =<span class="operator"> ...</span></span><br><span class="line"><span class="operator"></span><span class="module-access"><span class="module"><span class="identifier">Debug</span>.</span></span>dump<span class="constructor">HprofData(<span class="params">heapDumpFile</span>.<span class="params">getAbsolutePath</span>()</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、根据堆栈文件创建出内存映射文件缓冲区"><a href="#2、根据堆栈文件创建出内存映射文件缓冲区" class="headerlink" title="2、根据堆栈文件创建出内存映射文件缓冲区"></a>2、根据堆栈文件创建出内存映射文件缓冲区</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataBuffer buffer = <span class="keyword">new</span> <span class="constructor">MemoryMappedFileBuffer(<span class="params">heapDumpFile</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、根据文件缓存区创建出对应的快照"><a href="#3、根据文件缓存区创建出对应的快照" class="headerlink" title="3、根据文件缓存区创建出对应的快照"></a>3、根据文件缓存区创建出对应的快照</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Snapshot</span> <span class="keyword">snapshot</span> = <span class="keyword">Snapshot</span>.createSnapshot(buffer);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4、从快照中获取指定的类"><a href="#4、从快照中获取指定的类" class="headerlink" title="4、从快照中获取指定的类"></a>4、从快照中获取指定的类</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassObj someClass <span class="operator">=</span> snapshot.findClass(<span class="string">&quot;com.example.SomeClass&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在实现线上版的LeakCanary的时候主要要解决的问题有三个，如下所示：</p>
<ul>
<li>1）、<strong>解决 预设怀疑点 时不准确的问题 &#x3D;&gt; 自动找怀疑点</strong>。</li>
<li>2）、<strong>解决掉将 hprof 文件映射到内存中的时候可能导致内存暴涨甚至发生 OOM 的问题 &#x3D;&gt; 对象裁剪，不全部加载到内存。即对生成的 Hprof 内存快照文件做一些优化：裁剪大部分图片对应的 byte 数据 以减少文件开销，最后，使用 7zip 压缩，一般可 节省 90% 大小</strong>。</li>
<li>3）、<strong>分析泄漏链路慢而导致分析时间过长 &#x3D;&gt; 分析 Retain size 大的对象</strong>。</li>
</ul>
<h4 id="成熟期：实现内存泄漏监控闭环"><a href="#成熟期：实现内存泄漏监控闭环" class="headerlink" title="成熟期：实现内存泄漏监控闭环"></a>成熟期：实现内存泄漏监控闭环</h4><p>在实现了线上版的 LeakCanary 之后，就需要 <strong>将线上版的 LeakCanary 与服务器和前端页面结合</strong> 起来。具体的 <strong>内存泄漏监控闭环流程</strong> 如下所示：</p>
<ul>
<li>1）、<strong>当在线上版 LeakCanary 上发现内存泄漏时，手机将上传内存快照至服务器</strong>。</li>
<li>2）、<strong>此时服务器分析 Hprof，如果不是系统原因导致误报则通过 git 得到该最近修改人</strong>。</li>
<li>3）、<strong>最后将内存泄漏 bug 单提交给负责人。该负责人通过前端实现的 bug 单系统即可看到自己新增的bug</strong>。</li>
</ul>
<p>此外,在实现 <strong>图片内存监控</strong> 的过程中，应注意 <strong>两个关键点</strong>，如下所示：</p>
<ul>
<li>1）、在线上可以按照 <strong>不同的系统、屏幕分辨率</strong> 等纬度去 <strong>分析图片内存的占用情况</strong>。</li>
<li>2）、在 OOM 崩溃时，可以将 <strong>图片总内存、Top N 图片占用内存</strong> 写入 <strong>崩溃日志</strong>。</li>
</ul>
<h3 id="2、低内存监控"><a href="#2、低内存监控" class="headerlink" title="2、低内存监控"></a>2、低内存监控</h3><p>对于低内存的监控，通常有两种方式，分别如下所示：</p>
<ul>
<li>1、<strong>利用 onTrimMemory &#x2F; onLowMemory 监听系统回调的物理内存警告</strong>。</li>
<li>2、<strong>在后台起一个服务定时监控系统的内存占用，只要超过虚拟内存大小最大限制的 90% 则直接触发内存警告</strong>。</li>
</ul>
<h3 id="3、内存监控指标"><a href="#3、内存监控指标" class="headerlink" title="3、内存监控指标"></a>3、内存监控指标</h3><p>为了准确衡量内存性能，我们需要引入一系列的内存监控指标，如下所示：</p>
<h4 id="1）、发生频率"><a href="#1）、发生频率" class="headerlink" title="1）、发生频率"></a>1）、发生频率</h4><h4 id="2）、发生时各项内存使用状况"><a href="#2）、发生时各项内存使用状况" class="headerlink" title="2）、发生时各项内存使用状况"></a>2）、发生时各项内存使用状况</h4><h4 id="3）、发生时App的当前场景"><a href="#3）、发生时App的当前场景" class="headerlink" title="3）、发生时App的当前场景"></a>3）、发生时App的当前场景</h4><h4 id="4）、内存异常率"><a href="#4）、内存异常率" class="headerlink" title="4）、内存异常率"></a>4）、内存异常率</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存 UV 异常率 <span class="operator">=</span> PSS 超过 <span class="number">400</span>MB 的 UV / 采集UV</span><br><span class="line">PSS 获取：调用 Debug.MemoryInfo 的 API 即可</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果出现 <strong>新的内存使用不当或内存泄漏</strong> 的场景，这个指标会有所 <strong>上涨</strong>。</p>
<h4 id="5）、触顶率"><a href="#5）、触顶率" class="headerlink" title="5）、触顶率"></a>5）、触顶率</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存 UV 触顶率 <span class="operator">=</span> Java 堆占用超过最大堆限制的 <span class="number">85</span>% 的 UV / 采集UV</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算触顶率的代码如下所示：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long javaMax <span class="operator">=</span> Runtime.maxMemory()<span class="comment">;</span></span><br><span class="line">long javaTotal <span class="operator">=</span> Runtime.totalMemory()<span class="comment">;</span></span><br><span class="line">long javaUsed <span class="operator">=</span> javaTotal - runtime.freeMemory()<span class="comment">;</span></span><br><span class="line">float proportion <span class="operator">=</span> (float) javaUsed / javaMax<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果超过 <strong>85% 最大堆</strong> 的限制，<strong>GC</strong> 会变得更加 <strong>频发</strong>，容易造成 <strong>OOM 和 卡顿</strong>。</p>
<h3 id="4、小结-1"><a href="#4、小结-1" class="headerlink" title="4、小结"></a>4、小结</h3><p>在具体实现的时候，<strong>客户端</strong> 尽量只负责 <strong>上报数据</strong>，而 <strong>指标值的计算</strong> 可以由 <strong>后台</strong> 来计算。这样便可以通过 <strong>版本对比</strong> 来<strong>监控</strong>是否有 <strong>新增内存问题</strong>。因此，<strong>建立线上内存监控的完整方案</strong> 至少需要包含以下<strong>四点</strong>：</p>
<ul>
<li>1）、<strong>待机内存、重点模块内存、OOM率</strong>。</li>
<li>2）、<strong>整体及重点模块 GC 次数、GC 时间</strong>。</li>
<li>3）、<strong>增强的 LeakCanry 自动化内存泄漏分析</strong>。</li>
<li>4）、<strong>低内存监控模块的设置</strong>。</li>
</ul>
<h2 id="4、建立全局的线程监控组件"><a href="#4、建立全局的线程监控组件" class="headerlink" title="4、建立全局的线程监控组件"></a>4、建立全局的线程监控组件</h2><p><strong>每个线程初始化都需要 mmap 一定的栈大小，在默认情况下初始化一个线程需要 mmap 1MB 左右的内存空间</strong>。</p>
<p>在 <strong>32bit</strong> 的应用中有 <strong>4g 的 vmsize</strong>，<strong>实际</strong>能使用的有 <strong>3g+<strong>，这样一个进程 <strong>最大能创建的线程数</strong> 可以达到 <strong>3000个</strong>，但是，</strong>linux 对每个进程可创建的线程数也有一定的限制（&#x2F;proc&#x2F;pid&#x2F;limits）</strong>，并且，<strong>不同厂商也能修改这个限制</strong>，超过该限制就会 OOM。</p>
<p>因此，对线程数量的限制，在一定程度上可以 <strong>有效地避免 OOM 的发生</strong>。那么，实现一套 <strong>全局的线程监控组件</strong> 便是 <strong>刻不容缓</strong> 的了。</p>
<h3 id="全局线程监控组件的实现原理"><a href="#全局线程监控组件的实现原理" class="headerlink" title="全局线程监控组件的实现原理"></a>全局线程监控组件的实现原理</h3><p><strong>在线下或灰度的环境下通过一个定时器每隔 10分钟 dump 出应用所有的线程相关信息，当线程数超过当前阈值时，则将当前的线程信息上报并预警</strong>。</p>
<h2 id="5、GC-监控组件搭建"><a href="#5、GC-监控组件搭建" class="headerlink" title="5、GC 监控组件搭建"></a>5、GC 监控组件搭建</h2><p>通过 <strong>Debug.startAllocCounting</strong> 来监控 <strong>GC</strong> 情况，注意有一定 <strong>性能影响</strong>。</p>
<p>在 <strong>Android 6.0 之前</strong> 可以拿到 <strong>内存分配次数和大小以及 GC 次数</strong>，其对应的代码如下所示：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long allocCount <span class="operator">=</span> Debug.getGlobalAllocCount()<span class="comment">;</span></span><br><span class="line">long allocSize <span class="operator">=</span> Debug.getGlobalAllocSize()<span class="comment">;</span></span><br><span class="line">long gcCount <span class="operator">=</span> Debug.getGlobalGcInvocationCount()<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并且，在 <strong>Android 6.0 及之后</strong> 可以拿到 <strong>更精准</strong> 的 <strong>GC</strong> 信息：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Debug</span>.</span></span>get<span class="constructor">RuntimeStat(<span class="string">&quot;art.gc.gc-count&quot;</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Debug</span>.</span></span>get<span class="constructor">RuntimeStat(<span class="string">&quot;art.gc.gc-time&quot;</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Debug</span>.</span></span>get<span class="constructor">RuntimeStat(<span class="string">&quot;art.gc.blocking-gc-count&quot;</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Debug</span>.</span></span>get<span class="constructor">RuntimeStat(<span class="string">&quot;art.gc.blocking-gc-time&quot;</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于 <strong>GC 信息的排查</strong>，我们一般关注 <strong>阻塞式GC的次数和耗时</strong>，因为它会 <strong>暂停线程</strong>，可能导致应用发生 <strong>卡顿</strong>。建议 <strong>仅对重度场景使用</strong>。</p>
<h2 id="6、建立线上-OOM-监控组件：Probe"><a href="#6、建立线上-OOM-监控组件：Probe" class="headerlink" title="6、建立线上 OOM 监控组件：Probe"></a>6、建立线上 OOM 监控组件：Probe</h2><p>美团的 Android <strong>内存泄漏自动化链路分析组件</strong> <strong>Probe</strong> 在 <strong>OOM</strong> 时会生成 <strong>Hprof 内存快照</strong>，然后，它会通过 <strong>单独进程</strong> 对这个 <strong>文件</strong> 做进一步 <strong>分析</strong>。</p>
<h3 id="Probe-组件的缺陷及解决方案"><a href="#Probe-组件的缺陷及解决方案" class="headerlink" title="Probe 组件的缺陷及解决方案"></a>Probe 组件的缺陷及解决方案</h3><p>它的缺点比较多，具体为如下几点：</p>
<ul>
<li>1、<strong>在崩溃的时候生成内存快照容易导致二次崩溃</strong>。</li>
<li>2、<strong>部分手机生成 Hprof 快照比较耗时</strong>。</li>
<li>3、<strong>部分 OOM 是由虚拟内存不足导致</strong>。</li>
</ul>
<p>在实现自动化链路分析组件 Probe 的过程中主要要解决两个问题，如下所示：</p>
<h4 id="1、链路分析时间过长"><a href="#1、链路分析时间过长" class="headerlink" title="1、链路分析时间过长"></a>1、链路分析时间过长</h4><ul>
<li>1）、使用<strong>链路归并</strong>：将具有 <strong>相同层级与结构</strong> 的链路进行 <strong>合并</strong>。</li>
<li>2）、使用 <strong>自适应扩容法</strong>：<strong>通过不断比较现有链路和新链路，结合扩容因子，逐渐完善为完整的泄漏链路</strong>。</li>
</ul>
<h4 id="2、分析进程占用内存过大"><a href="#2、分析进程占用内存过大" class="headerlink" title="2、分析进程占用内存过大"></a>2、分析进程占用内存过大</h4><p><strong>分析进程占用的内存</strong> 跟 <strong>内存快照文件的大小</strong> 不成正相关，而跟 <strong>内存快照文件的 Instance 数量</strong> 呈 <strong>正相关</strong>。所以在开发过程中我们应该 <strong>尽可能排除不需要的Instance实例</strong>。</p>
<h3 id="Prope-分析流程揭秘"><a href="#Prope-分析流程揭秘" class="headerlink" title="Prope 分析流程揭秘"></a>Prope 分析流程揭秘</h3><p>Prope 的 <strong>总体架构图</strong> 如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbb5e763b52642feabeaf2c53fe9ad2a~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<p>而它的整个分析流程具体可以细分为八个步骤，如下所示：</p>
<h4 id="1、hprof-映射到内存-x3D-gt-解析成-Snapshot-amp-计数压缩："><a href="#1、hprof-映射到内存-x3D-gt-解析成-Snapshot-amp-计数压缩：" class="headerlink" title="1、hprof 映射到内存 &#x3D;&gt; 解析成 Snapshot &amp; 计数压缩："></a>1、hprof 映射到内存 &#x3D;&gt; 解析成 Snapshot &amp; 计数压缩：</h4><p>解析后的 Snapshot 中的 Heap 有四种类型，具体为：</p>
<ul>
<li>1）、<strong>DefaultHeap</strong></li>
<li>2）、<strong>ImageHeap</strong></li>
<li>3）、<strong>App Heap</strong>：包括 <strong>ClassInstance、ClassObj、ArrayInstance、RootObj</strong>。</li>
<li>4）、<strong>System Heap</strong></li>
</ul>
<p><strong>解析完</strong> 后使用了 <strong>计数压缩策略</strong>，对 <strong>相同的 Instance</strong> 使用 <strong>计数</strong>，以 <strong>减少占用内存。超过计数阈值的需要计入计数桶（计数桶记录了 丢弃个数 和 每个 Instance 的大小）</strong>。</p>
<h4 id="2、生成-Dominator-Tree。"><a href="#2、生成-Dominator-Tree。" class="headerlink" title="2、生成 Dominator Tree。"></a>2、<strong>生成 Dominator Tree</strong>。</h4><h4 id="3、计算-RetainSize。"><a href="#3、计算-RetainSize。" class="headerlink" title="3、计算 RetainSize。"></a>3、<strong>计算 RetainSize</strong>。</h4><h4 id="4、生成-Reference-链-amp-amp-基础数据类型增强"><a href="#4、生成-Reference-链-amp-amp-基础数据类型增强" class="headerlink" title="4、生成 Reference 链 &amp;&amp; 基础数据类型增强:"></a>4、<strong>生成 Reference 链 &amp;&amp; 基础数据类型增强</strong>:</h4><p>如果对象是 <strong>基础数据类型</strong>，会将 <strong>自身的 RetainSize 累加到父节点</strong> 上，将 <strong>怀疑对象</strong> 替换为它的 <strong>父节点</strong>。</p>
<h4 id="5、链路归并。"><a href="#5、链路归并。" class="headerlink" title="5、链路归并。"></a>5、<strong>链路归并</strong>。</h4><h4 id="6、计数桶补偿-amp-基础数据类型和父节点融合："><a href="#6、计数桶补偿-amp-基础数据类型和父节点融合：" class="headerlink" title="6、计数桶补偿 &amp; 基础数据类型和父节点融合："></a>6、<strong>计数桶补偿 &amp; 基础数据类型和父节点融合</strong>：</h4><p><strong>使用计数补偿策略计算 RetainSize，主要是 判断对象是否在计数桶中，如果在的话则将 丢弃的个数和大小补偿到对象上，累积计算RetainSize，最后对 RetainSize 排序以查找可疑对象</strong>。</p>
<h4 id="7、排序扩容。"><a href="#7、排序扩容。" class="headerlink" title="7、排序扩容。"></a>7、<strong>排序扩容</strong>。</h4><h4 id="8、查找泄露链路。"><a href="#8、查找泄露链路。" class="headerlink" title="8、查找泄露链路。"></a>8、<strong>查找泄露链路</strong>。</h4><h2 id="7、实现-单机版-的-Profile-Memory-自动化内存分析"><a href="#7、实现-单机版-的-Profile-Memory-自动化内存分析" class="headerlink" title="7、实现 单机版 的 Profile Memory 自动化内存分析"></a>7、实现 单机版 的 Profile Memory 自动化内存分析</h2><p><a href="https://link.juejin.cn/?target=https://github.com/JsonChao/Chapter03">项目地址请点击此处</a></p>
<p>在配置的时候要注意两个问题：</p>
<ul>
<li><p>1、<strong>liballoc-lib.so在构建后工程的 build &#x3D;&gt; intermediates &#x3D;&gt; cmake 目录下。将对应的 cpu abi 目录拷贝到新建的 libs 目录下</strong>。</p>
</li>
<li><p>2、<strong>在 DumpPrinter Java 库的 build.gradle 中的 jar 闭包中需要加入以下代码以识别源码路径:</strong></p>
<p>sourceSets.main.java.srcDirs &#x3D; [‘src’]</p>
</li>
</ul>
<h3 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>具体的使用步骤如下所示：</p>
<h4 id="1、首先，点击-”开始记录“-按钮可以看到触发对象分配的记录，说明对象已经开始记录对象的分配，log如下所示："><a href="#1、首先，点击-”开始记录“-按钮可以看到触发对象分配的记录，说明对象已经开始记录对象的分配，log如下所示：" class="headerlink" title="1、首先，点击 ”开始记录“ 按钮可以看到触发对象分配的记录，说明对象已经开始记录对象的分配，log如下所示："></a>1、首先，点击 ”开始记录“ 按钮可以看到触发对象分配的记录，说明对象已经开始记录对象的分配，log如下所示：</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">12</span>-<span class="number">26</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">03</span>.<span class="number">963</span> <span class="number">30450</span>-<span class="number">30450</span>/com.dodola.alloctrack I/AllocTracker: ====current alloc count <span class="number">388</span>=====</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、然后，点击多次-”生成1000个对象“-按钮，当对象达到设置的最大数量的时候触发内存dump，会得到保存数据路径的日志。如下所示："><a href="#2、然后，点击多次-”生成1000个对象“-按钮，当对象达到设置的最大数量的时候触发内存dump，会得到保存数据路径的日志。如下所示：" class="headerlink" title="2、然后，点击多次 ”生成1000个对象“ 按钮，当对象达到设置的最大数量的时候触发内存dump，会得到保存数据路径的日志。如下所示："></a>2、然后，点击多次 ”生成1000个对象“ 按钮，当对象达到设置的最大数量的时候触发内存dump，会得到保存数据路径的日志。如下所示：</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">12</span>-<span class="number">26</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">03</span>.<span class="number">963</span> <span class="number">30450</span>-<span class="number">30450</span>/com.dodola.alloctrack I/AllocTracker: ====current alloc count <span class="number">388</span>=====</span><br><span class="line"><span class="attribute">12</span>-<span class="number">26</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">45</span>.<span class="number">103</span> <span class="number">30450</span>-<span class="number">30450</span>/com.dodola.alloctrack I/AllocTracker: saveARTAllocationData write file to /storage/emulated/<span class="number">0</span>/crashDump/<span class="number">1577329005</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、此时，可以看到数据保存在-sdk-下的-crashDump-目录下。"><a href="#3、此时，可以看到数据保存在-sdk-下的-crashDump-目录下。" class="headerlink" title="3、此时，可以看到数据保存在 sdk 下的 crashDump 目录下。"></a>3、此时，可以看到数据保存在 sdk 下的 crashDump 目录下。</h4><h4 id="4、接着，通过-gradle-task-buildAlloctracker-任务编译出存放在-tools-x2F-DumpPrinter-1-0-jar-的-dump-工具，然后采用如下命令来将数据解析-到dump-log-txt-文件中。"><a href="#4、接着，通过-gradle-task-buildAlloctracker-任务编译出存放在-tools-x2F-DumpPrinter-1-0-jar-的-dump-工具，然后采用如下命令来将数据解析-到dump-log-txt-文件中。" class="headerlink" title="4、接着，通过 gradle task :buildAlloctracker 任务编译出存放在 tools&#x2F;DumpPrinter-1.0.jar 的 dump 工具，然后采用如下命令来将数据解析 到dump_log.txt 文件中。"></a>4、接着，通过 gradle task :buildAlloctracker 任务编译出存放在 tools&#x2F;DumpPrinter-1.0.jar 的 dump 工具，然后采用如下命令来将数据解析 到dump_log.txt 文件中。</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java</span> -jar tools/DumpPrinter-<span class="number">1</span>.<span class="number">0</span>.jar dump文件路径 &gt; dump_log.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5、最后，就可以在-dump-log-txt-文件中看到解析出来的数据，如下所示："><a href="#5、最后，就可以在-dump-log-txt-文件中看到解析出来的数据，如下所示：" class="headerlink" title="5、最后，就可以在 dump_log.txt 文件中看到解析出来的数据，如下所示："></a>5、最后，就可以在 dump_log.txt 文件中看到解析出来的数据，如下所示：</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Found <span class="number">4949</span> records:</span><br><span class="line">tid=<span class="number">1</span> byte<span class="selector-attr">[]</span> (<span class="number">94208</span> bytes)</span><br><span class="line">    dalvik<span class="selector-class">.system</span><span class="selector-class">.VMRuntime</span><span class="selector-class">.newNonMovableArray</span> (Native method)</span><br><span class="line">    android<span class="selector-class">.graphics</span><span class="selector-class">.Bitmap</span><span class="selector-class">.nativeCreate</span> (Native method)</span><br><span class="line">    android<span class="selector-class">.graphics</span><span class="selector-class">.Bitmap</span><span class="selector-class">.createBitmap</span> (Bitmap<span class="selector-class">.java</span>:<span class="number">975</span>)</span><br><span class="line">    android<span class="selector-class">.graphics</span><span class="selector-class">.Bitmap</span><span class="selector-class">.createBitmap</span> (Bitmap<span class="selector-class">.java</span>:<span class="number">946</span>)</span><br><span class="line">    android<span class="selector-class">.graphics</span><span class="selector-class">.Bitmap</span><span class="selector-class">.createBitmap</span> (Bitmap<span class="selector-class">.java</span>:<span class="number">913</span>)</span><br><span class="line">    android<span class="selector-class">.graphics</span><span class="selector-class">.drawable</span><span class="selector-class">.RippleDrawable</span><span class="selector-class">.updateMaskShaderIfNeeded</span> (RippleDrawable<span class="selector-class">.java</span>:<span class="number">776</span>)</span><br><span class="line">    android<span class="selector-class">.graphics</span><span class="selector-class">.drawable</span><span class="selector-class">.RippleDrawable</span><span class="selector-class">.drawBackgroundAndRipples</span> (RippleDrawable<span class="selector-class">.java</span>:<span class="number">860</span>)</span><br><span class="line">    android<span class="selector-class">.graphics</span><span class="selector-class">.drawable</span><span class="selector-class">.RippleDrawable</span><span class="selector-class">.draw</span> (RippleDrawable<span class="selector-class">.java</span>:<span class="number">700</span>)</span><br><span class="line">    android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.getDrawableRenderNode</span> (View<span class="selector-class">.java</span>:<span class="number">17736</span>)</span><br><span class="line">    android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.drawBackground</span> (View<span class="selector-class">.java</span>:<span class="number">17660</span>)</span><br><span class="line">    android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.draw</span> (View<span class="selector-class">.java</span>:<span class="number">17467</span>)</span><br><span class="line">    android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.updateDisplayListIfDirty</span> (View<span class="selector-class">.java</span>:<span class="number">16469</span>)</span><br><span class="line">    android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.recreateChildDisplayList</span> (ViewGroup<span class="selector-class">.java</span>:<span class="number">3905</span>)</span><br><span class="line">    android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.dispatchGetDisplayList</span> (ViewGroup<span class="selector-class">.java</span>:<span class="number">3885</span>)</span><br><span class="line">    android<span class="selector-class">.view</span><span class="selector-class">.View</span><span class="selector-class">.updateDisplayListIfDirty</span> (View<span class="selector-class">.java</span>:<span class="number">16429</span>)</span><br><span class="line">    android<span class="selector-class">.view</span><span class="selector-class">.ViewGroup</span><span class="selector-class">.recreateChildDisplayList</span> (ViewGroup<span class="selector-class">.java</span>:<span class="number">3905</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8、搭建线下-Native-内存泄漏监控体系"><a href="#8、搭建线下-Native-内存泄漏监控体系" class="headerlink" title="8、搭建线下 Native 内存泄漏监控体系"></a>8、搭建线下 Native 内存泄漏监控体系</h2><p>在 <strong>Android 8.0 及之后</strong>，可以使用 <strong>Address Sanitizer、Malloc 调试和 Malloc 钩子</strong> 进行 <strong>native 内存分析</strong>，参见 <a href="https://link.juejin.cn/?target=https://source.android.com/devices/tech/debug/native-memory">native_memory</a></p>
<p>对于线下 Native 内存泄漏监控的建立，主要针对 <strong>是否能重编 so 的情况</strong> 来记录分配的内存信息。</p>
<h3 id="针对无法重编so的情况"><a href="#针对无法重编so的情况" class="headerlink" title="针对无法重编so的情况"></a>针对无法重编so的情况</h3><ul>
<li>1）、首先，使用 <strong>PLT Hook 拦截库的内存分配函数</strong>，然后，重定向到我们自己的实现后去 <strong>记录分配的 内存地址、大小、来源so库路径</strong> 等信息。</li>
<li>2）、最后，<strong>定期 扫描分配与释放 的配对内存块，对于 不配对的分配 输出上述记录的信息</strong>。</li>
</ul>
<h3 id="针对可重编的so情况"><a href="#针对可重编的so情况" class="headerlink" title="针对可重编的so情况"></a>针对可重编的so情况</h3><ul>
<li>1）、首先，通过 <strong>GCC</strong> 的 <strong>”-finstrument-functions“</strong> 参数给 <strong>所有函数插桩</strong>，然后，<strong>在桩中模拟调用栈的入栈与出栈操作</strong>。</li>
<li>2）、接着，通过 <strong>ld</strong> 的 <strong>”–warp“</strong> 参数 <strong>拦截内存分配和释放函数</strong>，重定向到我们自己的实现后<strong>记录分配的 内存地址、大小、来源so以及插桩调用栈此刻的内容</strong>。</li>
<li>3）、最后，<strong>定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息</strong>。</li>
</ul>
<h2 id="9、设置内存兜底策略"><a href="#9、设置内存兜底策略" class="headerlink" title="9、设置内存兜底策略"></a>9、设置内存兜底策略</h2><p>设置内存兜底策略的目的，是为了 <strong>在用户无感知的情况下，在接近触发系统异常前，选择合适的场景杀死进程并将其重启，从而使得应用内存占用回到正常情况</strong>。</p>
<p>通常执行内存兜底策略时至少需要满足六个条件，如下所示：</p>
<ul>
<li>1）、<strong>是否在主界面退到后台且位于后台时间超过 30min</strong>。</li>
<li>2）、<strong>当前时间为早上 2~5 点</strong>。</li>
<li>3）、<strong>不存在前台服务（通知栏、音乐播放栏等情况）</strong>。</li>
<li>4）、<strong>Java heap 必须大于当前进程最大可分配的85% || native内存大于800MB</strong>。</li>
<li>5）、**vmsize 超过了4G（32bit）的85%**。</li>
<li>6）、<strong>非大量的流量消耗（不超过1M&#x2F;min） &amp;&amp; 进程无大量CPU调度情况</strong>。</li>
</ul>
<p>只有在满足了以上条件之后，我们才会去<strong>杀死当前主进程并通过 push 进程重新拉起及初始化</strong>。</p>
<h2 id="10、更深入的内存优化策略"><a href="#10、更深入的内存优化策略" class="headerlink" title="10、更深入的内存优化策略"></a>10、更深入的内存优化策略</h2><p>除了在 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844904096541966350#heading-52">Android性能优化之内存优化 &#x3D;&gt; 优化内存空间</a> 中讲解过的一些常规的内存优化策略以外，在下面列举了一些更深入的内存优化策略。</p>
<h3 id="1、使-bitmap-资源在-native-中分配"><a href="#1、使-bitmap-资源在-native-中分配" class="headerlink" title="1、使 bitmap 资源在 native 中分配"></a>1、使 bitmap 资源在 native 中分配</h3><p><strong>对于 Android 2.x 系统，使用反射将 BitmapFactory.Options 里面隐藏的 inNativeAlloc 打开</strong>。</p>
<p><strong>对于 Android 4.x 系统，使用或借鉴 Fresco 将 bitmap 资源在 native 中分配的方式</strong>。</p>
<h3 id="2、图片加载时的降级处理"><a href="#2、图片加载时的降级处理" class="headerlink" title="2、图片加载时的降级处理"></a>2、图片加载时的降级处理</h3><p>使用 Glide、Fresco 等图片加载库，通过定制，在加载 bitmap 时，若发生 OOM，则使用 try catch 将其捕获，然后清除图片 cache，尝试降低 bitmap format（ARGB8888、RGB565、ARGB4444、ALPHA8）。</p>
<p>需要注意的是，OOM 是可以捕获的，只要 OOM 是由 try 语句中的对象声明所导致的，那么在 catch 语句中，是可以释放掉这些对象，解决 OOM 的问题的。</p>
<h3 id="3、前台每隔-3-分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80-）则主动释放应用-cache（Bitmap-为大头），并且显示地除去应用的-memory，以加速内存收集的过程。"><a href="#3、前台每隔-3-分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80-）则主动释放应用-cache（Bitmap-为大头），并且显示地除去应用的-memory，以加速内存收集的过程。" class="headerlink" title="3、前台每隔 3 分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80%）则主动释放应用 cache（Bitmap 为大头），并且显示地除去应用的 memory，以加速内存收集的过程。"></a>3、前台每隔 3 分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80%）则主动释放应用 cache（Bitmap 为大头），并且显示地除去应用的 memory，以加速内存收集的过程。</h3><p>计算当前应用内存占最大内存的比例的代码如下：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">max</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory()<span class="comment">;</span></span><br><span class="line"><span class="attribute">available</span> <span class="operator">=</span> Runtime.getRuntime.totalMemory() - Runtime.getFreeMemory()<span class="comment">;</span></span><br><span class="line"><span class="attribute">ratio</span> <span class="operator">=</span> available / max<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显示地除去应用的 memory，以加速内存收集过程的代码如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">WindowManagerGlobal</span>.</span></span>get<span class="constructor">Instance()</span>.start<span class="constructor">TrimMemory(TRIM_MEMORY_COMPLETE)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、由于-webview-存在内存系统泄漏，还有-图库占用内存过多-的问题，可以采用单独的进程。"><a href="#4、由于-webview-存在内存系统泄漏，还有-图库占用内存过多-的问题，可以采用单独的进程。" class="headerlink" title="4、由于 webview 存在内存系统泄漏，还有 图库占用内存过多 的问题，可以采用单独的进程。"></a>4、由于 webview 存在内存系统泄漏，还有 图库占用内存过多 的问题，可以采用单独的进程。</h3><h3 id="5、当UI隐藏时释放内存"><a href="#5、当UI隐藏时释放内存" class="headerlink" title="5、当UI隐藏时释放内存"></a>5、当UI隐藏时释放内存</h3><p>当用户切换到其它应用并且你的应用 UI 不再可见时，应该释放应用 UI 所占用的所有内存资源。这能够显著增加系统缓存进程的能力，能够提升用户体验。</p>
<p><strong>在所有 UI 组件都隐藏的时候会接收到 Activity 的 onTrimMemory() 回调并带有参数 TRIM_MEMORY_UI_HIDDEN</strong>。</p>
<h3 id="6、Activity-的兜底内存回收策略"><a href="#6、Activity-的兜底内存回收策略" class="headerlink" title="6、Activity 的兜底内存回收策略"></a>6、Activity 的兜底内存回收策略</h3><p>在 Activity 的 onDestory 中递归释放其引用到的 Bitmap、DrawingCache 等资源，以降低发生内存泄漏时对应用内存的压力。</p>
<h3 id="7、使用类似-Hack-的方式修复系统内存泄漏"><a href="#7、使用类似-Hack-的方式修复系统内存泄漏" class="headerlink" title="7、使用类似 Hack 的方式修复系统内存泄漏"></a>7、使用类似 Hack 的方式修复系统内存泄漏</h3><p>LeakCanary 的 AndroidExcludeRefs 列出了一些由于系统原因导致引用无法释放的例子，可使用类似 Hack 的方式去修复。具体的实现代码可以参考 <a href="https://link.juejin.cn/?target=https://github.com/didi/booster%23what-can-booster-be-used-for--booster-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88">Booster &#x3D;&gt; 系统问题修复</a>。</p>
<h3 id="8、当应用使用的Service不再使用时应该销毁它，建议使用-IntentServcie。"><a href="#8、当应用使用的Service不再使用时应该销毁它，建议使用-IntentServcie。" class="headerlink" title="8、当应用使用的Service不再使用时应该销毁它，建议使用 IntentServcie。"></a>8、当应用使用的Service不再使用时应该销毁它，建议使用 IntentServcie。</h3><h3 id="9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。"><a href="#9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。" class="headerlink" title="9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。"></a>9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。</h3><h1 id="六、内存优化演进"><a href="#六、内存优化演进" class="headerlink" title="六、内存优化演进"></a>六、内存优化演进</h1><h2 id="1、自动化测试阶段"><a href="#1、自动化测试阶段" class="headerlink" title="1、自动化测试阶段"></a>1、自动化测试阶段</h2><p>内存达到阈值后自动触发 Hprof Dump，将得到的 Hprof 存档后由人工通过 MAT 进行分析。</p>
<h2 id="2、LeakCanary"><a href="#2、LeakCanary" class="headerlink" title="2、LeakCanary"></a>2、LeakCanary</h2><p>检测和分析报告都在一起，批量自动化测试和事后分析都不太方便。</p>
<h2 id="3、使用基于-LeakCannary-的改进版-ResourceCanary"><a href="#3、使用基于-LeakCannary-的改进版-ResourceCanary" class="headerlink" title="3、使用基于 LeakCannary 的改进版 ResourceCanary"></a>3、使用基于 LeakCannary 的改进版 ResourceCanary</h2><p><a href="https://link.juejin.cn/?target=https://github.com/Tencent/matrix/wiki/Matrix-Android-ResourceCanary%23matrix-resourcecanary">Matrix &#x3D;&gt; ResourceCanary 实现原理</a></p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>目前，它的主要功能有 <strong>三个部分</strong>，如下所示：</p>
<h4 id="1、分离-检测和分析-两部分流程"><a href="#1、分离-检测和分析-两部分流程" class="headerlink" title="1、分离 检测和分析 两部分流程"></a>1、分离 检测和分析 两部分流程</h4><p>自动化测试由测试平台进行，分析则由监控平台的服务端离线完成，最后再通知相关开发解决问题。</p>
<h4 id="2、裁剪-Hprof文件，以降低-传输-Hprof-文件与后台存储-Hprof-文件的开销"><a href="#2、裁剪-Hprof文件，以降低-传输-Hprof-文件与后台存储-Hprof-文件的开销" class="headerlink" title="2、裁剪 Hprof文件，以降低 传输 Hprof 文件与后台存储 Hprof 文件的开销"></a>2、裁剪 Hprof文件，以降低 传输 Hprof 文件与后台存储 Hprof 文件的开销</h4><p>获取 <strong>需要的类和对象相关的字符串</strong> 信息即可，其它数据都可以<strong>在客户端裁剪</strong>，一般能 Hprof 大小会<strong>减小</strong>至原来的 <strong>1&#x2F;10</strong> 左右。</p>
<h4 id="3、增加重复-Bitmap-对象检测"><a href="#3、增加重复-Bitmap-对象检测" class="headerlink" title="3、增加重复 Bitmap 对象检测"></a>3、增加重复 Bitmap 对象检测</h4><p>方便通过减少冗余 Bitmap 的数量，以降低内存消耗。</p>
<h3 id="4、小结-2"><a href="#4、小结-2" class="headerlink" title="4、小结"></a>4、小结</h3><p>在研发阶段需要不断实现 <strong>更多的工具和组件</strong>，以此系统化地<strong>提升自动化程度</strong>，以最终 <strong>提升发现问题的效率</strong>。</p>
<h1 id="七、内存优化工具"><a href="#七、内存优化工具" class="headerlink" title="七、内存优化工具"></a>七、内存优化工具</h1><p>除了常用的内存分析工具 Memory Profiler、MAT、LeakCanary 之外，还有一些其它的内存分析工具，下面我将一一为大家进行介绍。</p>
<h2 id="1、top"><a href="#1、top" class="headerlink" title="1、top"></a>1、top</h2><p>top 命令是 Linux 下常用的性能分析工具，能够 <strong>实时显示系统中各个进程的资源占用状况</strong>，类似于 <strong>Windows 的任务管理器</strong>。top 命令提供了 实时的对系统处理器的状态监视。它将 <strong>显示系统中 CPU 最“敏感”的任务列表</strong>。该命令可以按 <strong>CPU使用、内存使用和执行时间 对任务进行排序</strong>。</p>
<p>接下来，我们输入以下命令查看top命令的用法：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">quchao@quchaodeMacBook-Pro ~ % adb shell top <span class="comment">--help</span></span><br><span class="line"><span class="keyword">usage</span>: top [-Hbq] [-k FIELD,] [-o FIELD,] [-s SORT] [-n NUMBER] [-d SECONDS] [-p PID,] [-u <span class="keyword">USER</span>,]</span><br><span class="line"></span><br><span class="line"><span class="keyword">Show</span> process activity <span class="keyword">in</span> <span class="type">real</span> <span class="type">time</span>.</span><br><span class="line"></span><br><span class="line">-H	<span class="keyword">Show</span> threads</span><br><span class="line">-k	Fallback sort FIELDS (<span class="keyword">default</span> -S,-%CPU,-ETIME,-PID)</span><br><span class="line">-o	<span class="keyword">Show</span> FIELDS (def PID,<span class="keyword">USER</span>,PR,NI,VIRT,RES,SHR,S,%CPU,%MEM,<span class="type">TIME</span>+,CMDLINE)</span><br><span class="line">-O	<span class="keyword">Add</span> FIELDS (replacing PR,NI,VIRT,RES,SHR,S <span class="keyword">from</span> <span class="keyword">default</span>)</span><br><span class="line">-s	Sort <span class="keyword">by</span> field number (<span class="number">1</span>-X, <span class="keyword">default</span> <span class="number">9</span>)</span><br><span class="line">-b	Batch mode (<span class="keyword">no</span> tty)</span><br><span class="line">-d	Delay SECONDS <span class="keyword">between</span> <span class="keyword">each</span> <span class="keyword">cycle</span> (<span class="keyword">default</span> <span class="number">3</span>)</span><br><span class="line">-n	<span class="keyword">Exit</span> <span class="keyword">after</span> NUMBER iterations</span><br><span class="line">-p	<span class="keyword">Show</span> these PIDs</span><br><span class="line">-u	<span class="keyword">Show</span> these USERs</span><br><span class="line">-q	Quiet (<span class="keyword">no</span> <span class="keyword">header</span> lines)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Cursor</span> LEFT/RIGHT <span class="keyword">to</span> change sort, UP/DOWN <span class="keyword">move</span> list, space <span class="keyword">to</span> force</span><br><span class="line"><span class="keyword">update</span>, R <span class="keyword">to</span> <span class="keyword">reverse</span> sort, Q <span class="keyword">to</span> <span class="keyword">exit</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用 top 仅显示一次进程信息，以便来讲解进程信息中各字段的含义。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/476f7ef262f94a269ff35f057f95e0dd~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<h3 id="整体的统计信息区"><a href="#整体的统计信息区" class="headerlink" title="整体的统计信息区"></a>整体的统计信息区</h3><p><strong>前四行</strong> 是当前系统情况 <strong>整体的统计信息区</strong>。下面我们看每一行信息的具体意义。</p>
<h4 id="第一行：Tasks-—-任务（进程）"><a href="#第一行：Tasks-—-任务（进程）" class="headerlink" title="第一行：Tasks — 任务（进程）"></a>第一行：Tasks — 任务（进程）</h4><p>具体信息说明如下所示：</p>
<p>系统现在共有 729 个进程，其中处于 <strong>运行中</strong> 的有 1 个，715 个在 <strong>休眠（sleep）</strong>，<strong>stoped</strong> 状态的有0个，<strong>zombie</strong> 状态（僵尸）的有 8 个。</p>
<h4 id="第二行：内存状态"><a href="#第二行：内存状态" class="headerlink" title="第二行：内存状态"></a>第二行：内存状态</h4><p>具体信息如下所示：</p>
<ul>
<li>1）、<strong>5847124k total：物理内存总量（5.8GB）</strong></li>
<li>2）、<strong>5758016k used：使用中的内存总量（5.7GB）</strong></li>
<li>3）、<strong>89108k free：空闲内存总量（89MB）</strong></li>
<li>4）、<strong>112428k buffers：缓存的内存量 （112M）</strong></li>
</ul>
<h4 id="第三行：swap交换分区信息"><a href="#第三行：swap交换分区信息" class="headerlink" title="第三行：swap交换分区信息"></a>第三行：swap交换分区信息</h4><p>具体信息说明如下所示：</p>
<ul>
<li>1）、<strong>2621436k total：交换区总量（2.6GB）</strong></li>
<li>2）、<strong>612572k used：使用的交换区总量（612MB）</strong></li>
<li>3）、<strong>2008864k free：空闲交换区总量（2GB）</strong></li>
<li>4）、<strong>2657696k cached：缓冲的交换区总量（2.6GB）</strong></li>
</ul>
<h4 id="第四行：cpu状态信息"><a href="#第四行：cpu状态信息" class="headerlink" title="第四行：cpu状态信息"></a>第四行：cpu状态信息</h4><p>具体属性说明如下所示：</p>
<ul>
<li>1）、<strong>800% cpu：8核 CPU</strong></li>
<li>2）、<strong>39% user：39% CPU被用户进程使用</strong></li>
<li>3）、<strong>0% nice：优先值为负的进程占 0%</strong></li>
<li>4）、<strong>42% sys — 内核空间占用 CPU 的百分比为 42%</strong></li>
<li>5）、<strong>712% idle：除 IO 等待时间以外的其它等待时间为 712%</strong></li>
<li>6）、<strong>0% iow：IO 等待时间占 0%</strong></li>
<li>7）、<strong>0% irq：硬中断时间占 0%</strong></li>
<li>8）、<strong>6% sirq - 软中断时间占 0%</strong></li>
</ul>
<p>对于内存监控，在 top 里我们要时刻监控 <strong>第三行 swap 交换分区的 used</strong>，如果这个数值在不断的<strong>变化</strong>，说明内核在不断<strong>进行内存和 swap 的数据交换</strong>，这是真正的内存不够用了。</p>
<h3 id="进程（任务）的状态监控"><a href="#进程（任务）的状态监控" class="headerlink" title="进程（任务）的状态监控"></a>进程（任务）的状态监控</h3><p>在 <strong>第五行及以下</strong>，就是各进程（任务）的状态监控，项目列信息说明如下所示：</p>
<ul>
<li>1）、<strong>PID：进程 id</strong></li>
<li>2）、<strong>USER：进程所有者</strong></li>
<li>3）、<strong>PR：进程优先级</strong></li>
<li>4）、<strong>NI：nice 值。负值表示高优先级，正值表示低优先级</strong></li>
<li>5）、<strong>VIRT：进程使用的虚拟内存总量。VIRT &#x3D; SWAP + RES</strong></li>
<li>6）、<strong>RES：进程使用的、未被换出的物理内存大小。RES &#x3D; CODE + DATA</strong></li>
<li>7）、<strong>SHR：共享内存大小</strong></li>
<li>8)、<strong>S：进程状态。D &#x3D; 不可中断的睡眠状态、R &#x3D; 运行、 S &#x3D; 睡眠、T &#x3D; 跟踪 &#x2F; 停止、Z &#x3D; 僵尸进程</strong></li>
<li>9）、**%CPU — 上次更新到现在的 CPU 时间占用百分比**</li>
<li>10）、**%MEM：进程使用的物理内存百分比**</li>
<li>11）、<strong>TIME+：进程使用的 CPU 时间总计，单位 1&#x2F;100秒</strong></li>
<li>12）、<strong>ARGS：进程名称（命令名 &#x2F; 命令行）</strong></li>
</ul>
<p>从上图中可以看到，第一行的就是 <a href="https://link.juejin.cn/?target=https://github.com/JsonChao/Awesome-WanAndroid">Awesome-WanAndroid</a> 这个应用的进程，它的进程名称为 json.chao.com.w+，PID 为 23104，进程所有者 USER 为 u0_a714，进程优先级 PR 为 10，nice 置 NI 为 -10。进程使用的虚拟内存总量 VIRT 为 4.3GB，进程使用的、未被换出的物理内存大小 RES 为138M，共享内存大小 SHR 为 66M，进程状态 S 是睡眠状态，上次更新到现在的 CPU 时间占用百分比 %CPU 为 21.2。进程使用的物理内存百分比 %MEM 为 2.4%，进程使用的 CPU 时间 TIME+ 为 1:47.58 &#x2F; 100小时。</p>
<h2 id="2、dumpsys-meminfo"><a href="#2、dumpsys-meminfo" class="headerlink" title="2、dumpsys meminfo"></a>2、dumpsys meminfo</h2><h3 id="四大内存指标"><a href="#四大内存指标" class="headerlink" title="四大内存指标"></a>四大内存指标</h3><p>在讲解 dumpsys meminfo 命令之前，我们必须先了解下 Android 中最重要的 <strong>四大内存指标</strong> 的概念，如下表所示：</p>
<table>
<thead>
<tr>
<th>内存指标</th>
<th>英文全称</th>
<th>含义</th>
<th>等价</th>
</tr>
</thead>
<tbody><tr>
<td>USS</td>
<td>Unique Set Size</td>
<td>物理内存</td>
<td>进程独占的内存</td>
</tr>
<tr>
<td>PSS</td>
<td>Proportional Set Size</td>
<td>物理内存</td>
<td>PSS &#x3D; USS + 按比例包含共享库</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size</td>
<td>物理内存</td>
<td>RSS&#x3D; USS+ 包含共享库</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size</td>
<td>虚拟内存</td>
<td>VSS&#x3D; RSS+ 未分配实际物理内存</td>
</tr>
</tbody></table>
<p>从上可知，它们之间内存的大小关系为 <strong>VSS &gt;&#x3D; RSS &gt;&#x3D; PSS &gt;&#x3D; USS</strong>。</p>
<p>RSS 与 PSS 相似，也包含进程共享内存，但比较麻烦的是 <strong>RSS 并没有把共享内存大小全都平分到使用共享的进程头上，以至于所有进程的 RSS 相加会超过物理内存很多</strong>。而 <strong>VSS</strong> 是虚拟地址，它的<strong>上限与进程的可访问地址空间有关，和当前进程的内存使用关系并不大</strong>。比如有很多的 map 内存也被算在其中，我们都知道，file 的 map 内存对应的可能是一个文件或硬盘，或者某个奇怪的设备，它与进程使用内存并没有多少关系。</p>
<p>而 <strong>PSS、USS 最大的不同在于 “共享内存“（比如两个 App 使用 MMAP 方式打开同一个文件，那么打开文件而使用的这部分内存就是共享的），USS不包含进程间共享的内存，而PSS包含</strong>。这也造成了USS因为缺少共享内存，所有进程的USS相加要小于物理内存大小的原因。</p>
<p>最早的时候官方就推荐使用 PSS 曲线图来衡量 App 的物理内存占用，而 Android 4.4 之后才加入 USS。但是 <strong>PSS</strong>，有个很大的<strong>问题</strong>，就是 <strong>”共享内存“</strong>，考虑一种情况，<strong>如果 A 进程与 B 进程都会使用一个共享 SO 库，那么 So 库中初始化所用掉的那部分内存就会平分到 A 与 B 的头上。但是 A 是在 B 之后启动的，那么对于 B 的 PSS 曲线而言，在 A 启动的那一刻，即使 B 没有做任何事情，也会出现一个比较大的阶梯状下滑，这会给用曲线图分析软件内存的行为造成致命的麻烦</strong>。</p>
<p>USS 虽然没有这个问题，但是由于 <strong>Dalvik 虚拟机申请内存牵扯到 GC 时延和多种 GC 策略</strong>，这些都会<strong>影响到曲线的异常波动</strong>。例如<strong>异步 GC</strong> 是 Android 4.0 以上系统很重要的特性，但是 GC <strong>什么时候结束？曲线什么时候”降低“</strong>？就 <strong>无法预计</strong> 了。还有 <strong>GC 策略</strong>，什么时候开始增加 Dalvik 虚拟机的预申请内存大小（Dalvik 启动时是有一个标称的 start 内存大小，它是为 Java 代码运行时预留的，避免 Java 运行时再申请而造成卡顿），但是这个 <strong>预申请大小是动态变化的</strong>，这一点也会 <strong>造成 USS 忽大忽小</strong>。</p>
<h3 id="dumpsys-meminfo-命令解析"><a href="#dumpsys-meminfo-命令解析" class="headerlink" title="dumpsys meminfo 命令解析"></a>dumpsys meminfo 命令解析</h3><p>了解完 Android 内存的性能指标之后，下面我们便来说说 dumpsys meminfo 这个命令的用法，首先我们输入 adb shell dumpsys meminfo -h 查看它的帮助文档：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">quchao@quchaodeMacBook-Pro ~ % adb <span class="built_in">shell</span> dumpsys meminfo -h</span><br><span class="line">meminfo dump options: [-<span class="keyword">a</span>] [-d] [-c] [-s] [<span class="comment">--oom] [process]</span></span><br><span class="line">-<span class="keyword">a</span>: <span class="built_in">include</span> all available information <span class="keyword">for</span> <span class="keyword">each</span> <span class="built_in">process</span>.</span><br><span class="line">-d: <span class="built_in">include</span> dalvik details.</span><br><span class="line">-c: dump <span class="keyword">in</span> <span class="keyword">a</span> compact machine-parseable representation.</span><br><span class="line">-s: dump only summary <span class="keyword">of</span> application memory usage.</span><br><span class="line">-S: dump also SwapPss.</span><br><span class="line"><span class="comment">--oom: only show processes organized by oom adj.</span></span><br><span class="line"><span class="comment">--local: only collect details locally, don&#x27;t call process.</span></span><br><span class="line"><span class="comment">--package: interpret process arg as package, dumping all</span></span><br><span class="line">            processes that have loaded that package.</span><br><span class="line"><span class="comment">--checkin: dump data for a checkin</span></span><br><span class="line">If [<span class="built_in">process</span>] is specified <span class="keyword">it</span> can be <span class="keyword">the</span> name <span class="keyword">or</span></span><br><span class="line">pid <span class="keyword">of</span> <span class="keyword">a</span> specific <span class="built_in">process</span> <span class="built_in">to</span> dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着，我们之间输入adb shell dumpsys meminfo命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">quchao<span class="keyword">@quchaodeMacBook-Pro</span> ~ % adb shell dumpsys meminfo</span><br><span class="line">Applications Memory Usage (in Kilobytes):</span><br><span class="line"><span class="attribute">Uptime</span>: <span class="number">257501238</span> <span class="attribute">Realtime</span>: <span class="number">257501238</span></span><br><span class="line"></span><br><span class="line">// 根据进程PSS占用值从大到小排序</span><br><span class="line">Total PSS by <span class="attribute">process</span>:</span><br><span class="line">    <span class="number">308</span>,<span class="number">049</span><span class="attribute">K</span>: com.tencent.mm (pid <span class="number">3760</span> / activities)</span><br><span class="line">    <span class="number">225</span>,<span class="number">081</span><span class="attribute">K</span>: system (pid <span class="number">2088</span>)</span><br><span class="line">    <span class="number">189</span>,<span class="number">038</span><span class="attribute">K</span>: com.android.systemui (pid <span class="number">2297</span> / activities)</span><br><span class="line">    <span class="number">188</span>,<span class="number">877</span><span class="attribute">K</span>: com.miui.home (pid <span class="number">2672</span> / activities)</span><br><span class="line">    <span class="number">176</span>,<span class="number">665</span><span class="attribute">K</span>: com.plan.kot32.tomatotime (pid <span class="number">22744</span> / activities)</span><br><span class="line">    <span class="number">175</span>,<span class="number">231</span><span class="attribute">K</span>: json.chao.com.wanandroid (pid <span class="number">23104</span> / activities)</span><br><span class="line">    <span class="number">126</span>,<span class="number">918</span><span class="attribute">K</span>: com.tencent.mobileqq (pid <span class="number">23741</span>)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">// 以oom来划分，会详细列举所有的类别的进程</span><br><span class="line">Total PSS by OOM <span class="attribute">adjustment</span>:</span><br><span class="line">    <span class="number">432</span>,<span class="number">013</span><span class="attribute">K</span>: Native</span><br><span class="line">        <span class="number">76</span>,<span class="number">700</span><span class="attribute">K</span>: surfaceflinger (pid <span class="number">784</span>)</span><br><span class="line">        <span class="number">59</span>,<span class="number">084</span><span class="attribute">K</span>: android.hardware.camera.provider@<span class="number">2.4</span>-service (pid <span class="number">743</span>)</span><br><span class="line">        <span class="number">26</span>,<span class="number">524</span><span class="attribute">K</span>: transport (pid <span class="number">23418</span>)</span><br><span class="line">        <span class="number">25</span>,<span class="number">249</span><span class="attribute">K</span>: logd (pid <span class="number">597</span>)</span><br><span class="line">        <span class="number">11</span>,<span class="number">413</span><span class="attribute">K</span>: media.codec (pid <span class="number">1303</span>)</span><br><span class="line">        <span class="number">10</span>,<span class="number">648</span><span class="attribute">K</span>: rild (pid <span class="number">1304</span>)</span><br><span class="line">        <span class="number">9</span>,<span class="number">283</span><span class="attribute">K</span>: media.extractor (pid <span class="number">1297</span>)</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="number">661</span>,<span class="number">294</span><span class="attribute">K</span>: Persistent</span><br><span class="line">        <span class="number">225</span>,<span class="number">081</span><span class="attribute">K</span>: system (pid <span class="number">2088</span>)</span><br><span class="line">        <span class="number">189</span>,<span class="number">038</span><span class="attribute">K</span>: com.android.systemui (pid <span class="number">2297</span> / activities)</span><br><span class="line">        <span class="number">103</span>,<span class="number">050</span><span class="attribute">K</span>: com.xiaomi.finddevice (pid <span class="number">3134</span>)</span><br><span class="line">        <span class="number">39</span>,<span class="number">098</span><span class="attribute">K</span>: com.android.phone (pid <span class="number">2656</span>)</span><br><span class="line">        <span class="number">25</span>,<span class="number">583</span><span class="attribute">K</span>: com.miui.daemon (pid <span class="number">3078</span>)</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="number">219</span>,<span class="number">795</span><span class="attribute">K</span>: Foreground</span><br><span class="line">        <span class="number">175</span>,<span class="number">231</span><span class="attribute">K</span>: json.chao.com.wanandroid (pid <span class="number">23104</span> / activities)</span><br><span class="line">        <span class="number">44</span>,<span class="number">564</span><span class="attribute">K</span>: com.miui.securitycenter.remote (pid <span class="number">2986</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="number">246</span>,<span class="number">529</span><span class="attribute">K</span>: Visible</span><br><span class="line">        <span class="number">71</span>,<span class="number">002</span><span class="attribute">K</span>: com.sohu.inputmethod.sogou.xiaomi (pid <span class="number">4820</span>)</span><br><span class="line">        <span class="number">52</span>,<span class="number">305</span><span class="attribute">K</span>: com.miui.miwallpaper (pid <span class="number">2579</span>)</span><br><span class="line">        <span class="number">40</span>,<span class="number">982</span><span class="attribute">K</span>: com.miui.powerkeeper (pid <span class="number">3218</span>)</span><br><span class="line">        <span class="number">24</span>,<span class="number">604</span><span class="attribute">K</span>: com.miui.systemAdSolution (pid <span class="number">7986</span>)</span><br><span class="line">        <span class="number">14</span>,<span class="number">198</span><span class="attribute">K</span>: com.xiaomi.metoknlp (pid <span class="number">3506</span>)</span><br><span class="line">        <span class="number">13</span>,<span class="number">820</span><span class="attribute">K</span>: com.miui.<span class="attribute">voiceassist</span>:core (pid <span class="number">8722</span>)</span><br><span class="line">        <span class="number">13</span>,<span class="number">222</span><span class="attribute">K</span>: com.miui.analytics (pid <span class="number">8037</span>)</span><br><span class="line">        <span class="number">7</span>,<span class="number">046</span><span class="attribute">K</span>: com.miui.<span class="attribute">hybrid</span>:entrance (pid <span class="number">7922</span>)</span><br><span class="line">        <span class="number">5</span>,<span class="number">104</span><span class="attribute">K</span>: com.miui.wmsvc (pid <span class="number">7887</span>)</span><br><span class="line">        <span class="number">4</span>,<span class="number">246</span><span class="attribute">K</span>: com.android.smspush (pid <span class="number">8126</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="number">213</span>,<span class="number">027</span><span class="attribute">K</span>: Perceptible</span><br><span class="line">        <span class="number">89</span>,<span class="number">780</span><span class="attribute">K</span>: com.eg.android.AlipayGphone (pid <span class="number">8238</span>)</span><br><span class="line">        <span class="number">49</span>,<span class="number">033</span><span class="attribute">K</span>: com.eg.android.<span class="attribute">AlipayGphone</span>:push (pid <span class="number">8204</span>)</span><br><span class="line">        <span class="number">23</span>,<span class="number">181</span><span class="attribute">K</span>: com.android.thememanager (pid <span class="number">11057</span>)</span><br><span class="line">        <span class="number">13</span>,<span class="number">253</span><span class="attribute">K</span>: com.xiaomi.joyose (pid <span class="number">5558</span>)</span><br><span class="line">        <span class="number">10</span>,<span class="number">292</span><span class="attribute">K</span>: com.android.updater (pid <span class="number">3488</span>)</span><br><span class="line">        <span class="number">9</span>,<span class="number">807</span><span class="attribute">K</span>: com.lbe.security.miui (pid <span class="number">23060</span>)</span><br><span class="line">        <span class="number">9</span>,<span class="number">734</span><span class="attribute">K</span>: com.google.android.<span class="attribute">webview</span>:sandboxed_process0 (pid <span class="number">11150</span>)</span><br><span class="line">        <span class="number">7</span>,<span class="number">947</span><span class="attribute">K</span>: com.xiaomi.location.fused (pid <span class="number">3524</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="number">308</span>,<span class="number">049</span><span class="attribute">K</span>: Backup</span><br><span class="line">        <span class="number">308</span>,<span class="number">049</span><span class="attribute">K</span>: com.tencent.mm (pid <span class="number">3760</span> / activities)</span><br><span class="line">        </span><br><span class="line">    <span class="number">74</span>,<span class="number">250</span><span class="attribute">K</span>: A Services</span><br><span class="line">        <span class="number">59</span>,<span class="number">701</span><span class="attribute">K</span>: com.tencent.<span class="attribute">mm</span>:push (pid <span class="number">7234</span>)</span><br><span class="line">        <span class="number">9</span>,<span class="number">247</span><span class="attribute">K</span>: com.android.<span class="attribute">settings</span>:remote (pid <span class="number">27053</span>)</span><br><span class="line">        <span class="number">5</span>,<span class="number">302</span><span class="attribute">K</span>: com.xiaomi.drivemode (pid <span class="number">27009</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="number">199</span>,<span class="number">638</span><span class="attribute">K</span>: Home</span><br><span class="line">        <span class="number">188</span>,<span class="number">877</span><span class="attribute">K</span>: com.miui.home (pid <span class="number">2672</span> / activities)</span><br><span class="line">        <span class="number">10</span>,<span class="number">761</span><span class="attribute">K</span>: com.miui.hybrid (pid <span class="number">7945</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="number">53</span>,<span class="number">934</span><span class="attribute">K</span>: B Services</span><br><span class="line">        <span class="number">35</span>,<span class="number">583</span><span class="attribute">K</span>: com.tencent.<span class="attribute">mobileqq</span>:MSF (pid <span class="number">14119</span>)</span><br><span class="line">        <span class="number">6</span>,<span class="number">753</span><span class="attribute">K</span>: com.qualcomm.qti.autoregistration (pid <span class="number">8786</span>)</span><br><span class="line">        <span class="number">4</span>,<span class="number">086</span><span class="attribute">K</span>: com.qualcomm.qti.callenhancement (pid <span class="number">26958</span>)</span><br><span class="line">        <span class="number">3</span>,<span class="number">809</span><span class="attribute">K</span>: com.qualcomm.qti.StatsPollManager (pid <span class="number">26993</span>)</span><br><span class="line">        <span class="number">3</span>,<span class="number">703</span><span class="attribute">K</span>: com.qualcomm.qti.smcinvokepkgmgr (pid <span class="number">26976</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="number">692</span>,<span class="number">588</span><span class="attribute">K</span>: Cached</span><br><span class="line">        <span class="number">176</span>,<span class="number">665</span><span class="attribute">K</span>: com.plan.kot32.tomatotime (pid <span class="number">22744</span> / activities)</span><br><span class="line">        <span class="number">126</span>,<span class="number">918</span><span class="attribute">K</span>: com.tencent.mobileqq (pid <span class="number">23741</span>)</span><br><span class="line">        <span class="number">72</span>,<span class="number">928</span><span class="attribute">K</span>: com.tencent.<span class="attribute">mm</span>:tools (pid <span class="number">18598</span>)</span><br><span class="line">        <span class="number">68</span>,<span class="number">208</span><span class="attribute">K</span>: com.tencent.<span class="attribute">mm</span>:sandbox (pid <span class="number">27333</span>)</span><br><span class="line">        <span class="number">55</span>,<span class="number">270</span><span class="attribute">K</span>: com.tencent.<span class="attribute">mm</span>:toolsmp (pid <span class="number">18842</span>)</span><br><span class="line">        <span class="number">24</span>,<span class="number">477</span><span class="attribute">K</span>: com.android.mms (pid <span class="number">27192</span>)</span><br><span class="line">        <span class="number">23</span>,<span class="number">865</span><span class="attribute">K</span>: com.xiaomi.market (pid <span class="number">27825</span>)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">// 按内存的类别来进行划分</span><br><span class="line">Total PSS by <span class="attribute">category</span>:</span><br><span class="line">    <span class="number">957</span>,<span class="number">931</span><span class="attribute">K</span>: Native</span><br><span class="line">    <span class="number">284</span>,<span class="number">006</span><span class="attribute">K</span>: Dalvik</span><br><span class="line">    <span class="number">199</span>,<span class="number">750</span><span class="attribute">K</span>: Unknown</span><br><span class="line">    <span class="number">193</span>,<span class="number">236</span><span class="attribute">K</span>: .dex mmap</span><br><span class="line">    <span class="number">191</span>,<span class="number">521</span><span class="attribute">K</span>: .art mmap</span><br><span class="line">    <span class="number">110</span>,<span class="number">581</span><span class="attribute">K</span>: .oat mmap</span><br><span class="line">    <span class="number">101</span>,<span class="number">472</span><span class="attribute">K</span>: .so mmap</span><br><span class="line">    <span class="number">94</span>,<span class="number">984</span><span class="attribute">K</span>: EGL mtrack</span><br><span class="line">    <span class="number">87</span>,<span class="number">321</span><span class="attribute">K</span>: Dalvik Other</span><br><span class="line">    <span class="number">84</span>,<span class="number">924</span><span class="attribute">K</span>: Gfx dev</span><br><span class="line">    <span class="number">77</span>,<span class="number">300</span><span class="attribute">K</span>: GL mtrack</span><br><span class="line">    <span class="number">64</span>,<span class="number">963</span><span class="attribute">K</span>: .apk mmap</span><br><span class="line">    <span class="number">17</span>,<span class="number">112</span><span class="attribute">K</span>: Other mmap</span><br><span class="line">    <span class="number">12</span>,<span class="number">935</span><span class="attribute">K</span>: Ashmem</span><br><span class="line">     <span class="number">3</span>,<span class="number">364</span><span class="attribute">K</span>: Stack</span><br><span class="line">     <span class="number">2</span>,<span class="number">343</span><span class="attribute">K</span>: .ttf mmap</span><br><span class="line">     <span class="number">1</span>,<span class="number">375</span><span class="attribute">K</span>: Other dev</span><br><span class="line">     <span class="number">1</span>,<span class="number">071</span><span class="attribute">K</span>: .jar mmap</span><br><span class="line">        <span class="number">20</span><span class="attribute">K</span>: Cursor</span><br><span class="line">         <span class="number">0</span><span class="attribute">K</span>: Other mtrack</span><br><span class="line"></span><br><span class="line">// 手机整体内存使用情况</span><br><span class="line">Total <span class="attribute">RAM</span>: <span class="number">5</span>,<span class="number">847</span>,<span class="number">124</span>K (status normal)</span><br><span class="line">Free <span class="attribute">RAM</span>: <span class="number">3</span>,<span class="number">711</span>,<span class="number">324</span>K (  <span class="number">692</span>,<span class="number">588</span>K cached pss + <span class="number">2</span>,<span class="number">428</span>,<span class="number">616</span>K cached kernel +   <span class="number">117</span>,<span class="number">492</span>K cached ion +   <span class="number">472</span>,<span class="number">628</span>K free)</span><br><span class="line">Used <span class="attribute">RAM</span>: <span class="number">2</span>,<span class="number">864</span>,<span class="number">761</span>K (<span class="number">2</span>,<span class="number">408</span>,<span class="number">529</span>K used pss +   <span class="number">456</span>,<span class="number">232</span>K kernel)</span><br><span class="line">Lost <span class="attribute">RAM</span>:   <span class="number">184</span>,<span class="number">330</span>K</span><br><span class="line">    <span class="attribute">ZRAM</span>:   <span class="number">174</span>,<span class="number">628</span>K physical used for   <span class="number">625</span>,<span class="number">388</span>K in swap (<span class="number">2</span>,<span class="number">621</span>,<span class="number">436</span>K total swap)</span><br><span class="line"><span class="attribute">Tuning</span>: <span class="number">256</span> (large <span class="number">512</span>), oom   <span class="number">322</span>,<span class="number">560</span>K, restore limit   <span class="number">107</span>,<span class="number">520</span>K (high-end-gfx)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据 dumpsys meminfo 的输出结果，可归结为如下表格：</p>
<table>
<thead>
<tr>
<th>划分类型</th>
<th>排序指标</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>process</td>
<td>PSS</td>
<td>以进程的PSS从大到小依次排序显示，每行显示一个进程，一般用来做初步的竞品分析</td>
</tr>
<tr>
<td>OOM adj</td>
<td>PSS</td>
<td>展示当前系统内部运行的所有Android进程的内存状态和被杀顺序，越靠近下方的进程越容易被杀，排序按照一套复杂的算法，算法涵盖了前后台、服务或节目、可见与否、老化等</td>
</tr>
<tr>
<td>category</td>
<td>PSS</td>
<td>以Dalvik&#x2F;Native&#x2F;.art mmap&#x2F;.dex map等划分并按降序列出各类进程的总PSS分布情况</td>
</tr>
<tr>
<td>total</td>
<td>-</td>
<td>总内存、剩余内存、可用内存、其他内存</td>
</tr>
</tbody></table>
<p>此外，为了 <strong>查看单个 App 进程的内存信息</strong>，我们可以输入如下命令：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dumpsys meminfo &lt;pid&gt; <span class="regexp">//</span> 输出指定pid的某一进程</span><br><span class="line">dumpsys meminfo --package &lt;packagename&gt; <span class="regexp">//</span> 输出指定包名的进程，可能包含多个进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们输入 adb shell dumpsys meminfo 23104 这条命令，其中 23104 为 Awesome-WanAndroid App 的 pid，结果如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">quchao@quchaodeMacBook-Pro</span> <span class="string">~</span> <span class="string">%</span> <span class="string">adb</span> <span class="string">shell</span> <span class="string">dumpsys</span> <span class="string">meminfo</span> <span class="number">23104</span></span><br><span class="line"><span class="string">Applications</span> <span class="string">Memory</span> <span class="string">Usage</span> <span class="string">(in</span> <span class="string">Kilobytes):</span></span><br><span class="line"><span class="attr">Uptime: 258375231 Realtime:</span> <span class="number">258375231</span></span><br><span class="line"></span><br><span class="line"><span class="string">**</span> <span class="string">MEMINFO</span> <span class="string">in</span> <span class="string">pid</span> <span class="number">23104</span> [<span class="string">json.chao.com.wanandroid</span>] <span class="string">**</span></span><br><span class="line">                <span class="string">Pss</span>  <span class="string">Private</span>  <span class="string">Private</span>  <span class="string">SwapPss</span>     <span class="string">Heap</span>     <span class="string">Heap</span>     <span class="string">Heap</span></span><br><span class="line">                <span class="string">Total</span>    <span class="string">Dirty</span>    <span class="string">Clean</span>    <span class="string">Dirty</span>     <span class="string">Size</span>    <span class="string">Alloc</span>     <span class="string">Free</span></span><br><span class="line">                <span class="string">------</span>   <span class="string">------</span>   <span class="string">------</span>   <span class="string">------</span>   <span class="string">------</span>   <span class="string">------</span>   <span class="string">------</span></span><br><span class="line"><span class="string">Native</span> <span class="string">Heap</span>    <span class="number">46674</span>    <span class="number">46620</span>        <span class="number">0</span>      <span class="number">164</span>    <span class="number">80384</span>    <span class="number">60559</span>    <span class="number">19824</span></span><br><span class="line"><span class="string">Dalvik</span> <span class="string">Heap</span>     <span class="number">6949     </span><span class="number">6912       </span><span class="number">16</span>       <span class="number">23</span>    <span class="number">12064</span>     <span class="number">6032     </span><span class="number">6032</span></span><br><span class="line"><span class="string">Dalvik</span> <span class="string">Other</span>     <span class="number">7672     </span><span class="number">7672        </span><span class="number">0</span>        <span class="number">0</span></span><br><span class="line">       <span class="string">Stack</span>      <span class="number">108</span>      <span class="number">108</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">      <span class="string">Ashmem</span>      <span class="number">134</span>      <span class="number">132</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">     <span class="string">Gfx</span> <span class="string">dev</span>    <span class="number">16036</span>    <span class="number">16036</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">   <span class="string">Other</span> <span class="string">dev</span>       <span class="number">12</span>        <span class="number">0</span>       <span class="number">12</span>        <span class="number">0</span></span><br><span class="line">   <span class="string">.so</span> <span class="string">mmap</span>     <span class="number">3360      </span><span class="number">228</span>     <span class="number">1084       </span><span class="number">27</span></span><br><span class="line">  <span class="string">.jar</span> <span class="string">mmap</span>        <span class="number">8</span>        <span class="number">8</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">  <span class="string">.apk</span> <span class="string">mmap</span>    <span class="number">28279</span>    <span class="number">11328</span>    <span class="number">11584</span>        <span class="number">0</span></span><br><span class="line">  <span class="string">.ttf</span> <span class="string">mmap</span>      <span class="number">295</span>        <span class="number">0</span>       <span class="number">80</span>        <span class="number">0</span></span><br><span class="line">  <span class="string">.dex</span> <span class="string">mmap</span>     <span class="number">7780       </span><span class="number">20</span>     <span class="number">4908        </span><span class="number">0</span></span><br><span class="line">  <span class="string">.oat</span> <span class="string">mmap</span>      <span class="number">660</span>        <span class="number">0</span>       <span class="number">92</span>        <span class="number">0</span></span><br><span class="line">  <span class="string">.art</span> <span class="string">mmap</span>     <span class="number">8509     </span><span class="number">8028      </span><span class="number">104</span>       <span class="number">69</span></span><br><span class="line"> <span class="string">Other</span> <span class="string">mmap</span>      <span class="number">982</span>        <span class="number">8</span>      <span class="number">848</span>        <span class="number">0</span></span><br><span class="line"> <span class="string">EGL</span> <span class="string">mtrack</span>    <span class="number">29388</span>    <span class="number">29388</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">  <span class="string">GL</span> <span class="string">mtrack</span>    <span class="number">14864</span>    <span class="number">14864</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    <span class="string">Unknown</span>     <span class="number">2532     </span><span class="number">2500        </span><span class="number">8</span>       <span class="number">20</span></span><br><span class="line">      <span class="string">TOTAL</span>   <span class="number">174545</span>   <span class="number">143852</span>    <span class="number">18736</span>      <span class="number">303</span>    <span class="number">92448</span>    <span class="number">66591</span>    <span class="number">25856</span></span><br><span class="line"></span><br><span class="line"><span class="string">App</span> <span class="string">Summary</span></span><br><span class="line">                   <span class="string">Pss(KB)</span></span><br><span class="line">                    <span class="string">------</span></span><br><span class="line">       <span class="attr">Java Heap:</span>    <span class="number">15044</span></span><br><span class="line">     <span class="attr">Native Heap:</span>    <span class="number">46620</span></span><br><span class="line">            <span class="attr">Code:</span>    <span class="number">29332</span></span><br><span class="line">           <span class="attr">Stack:</span>      <span class="number">108</span></span><br><span class="line">        <span class="attr">Graphics:</span>    <span class="number">60288</span></span><br><span class="line">   <span class="attr">Private Other:</span>    <span class="number">11196</span></span><br><span class="line">          <span class="attr">System:</span>    <span class="number">11957</span></span><br><span class="line"></span><br><span class="line">           <span class="attr">TOTAL:   174545       TOTAL SWAP PSS:</span>      <span class="number">303</span></span><br><span class="line"></span><br><span class="line"><span class="string">Objects</span></span><br><span class="line">           <span class="attr">Views:      171         ViewRootImpl:</span>        <span class="number">1</span></span><br><span class="line">     <span class="attr">AppContexts:        3           Activities:</span>        <span class="number">1</span></span><br><span class="line">          <span class="attr">Assets:       18        AssetManagers:</span>        <span class="number">6</span></span><br><span class="line">   <span class="attr">Local Binders:       32        Proxy Binders:</span>       <span class="number">27</span></span><br><span class="line">   <span class="attr">Parcel memory:       11         Parcel count:</span>       <span class="number">45</span></span><br><span class="line"><span class="attr">Death Recipients:        1      OpenSSL Sockets:</span>        <span class="number">0</span></span><br><span class="line">        <span class="attr">WebViews:</span>        <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="string">SQL</span></span><br><span class="line">        <span class="attr">MEMORY_USED:</span>      <span class="number">371</span></span><br><span class="line"> <span class="attr">PAGECACHE_OVERFLOW:       72          MALLOC_SIZE:</span>      <span class="number">117</span></span><br><span class="line"></span><br><span class="line"><span class="string">DATABASES</span></span><br><span class="line">    <span class="string">pgsz</span>     <span class="string">dbsz</span>   <span class="string">Lookaside(b)</span>          <span class="string">cache</span>  <span class="string">Dbname</span></span><br><span class="line">        <span class="number">4</span>       <span class="number">60</span>            <span class="number">109</span>      <span class="number">151</span><span class="string">/32/18</span>  <span class="string">/data/user/0/json.chao.com.wanandroid/databases/bugly_db_</span></span><br><span class="line">        <span class="number">4</span>       <span class="number">20</span>             <span class="number">19</span>         <span class="number">0</span><span class="string">/15/1</span>  <span class="string">/data/user/0/json.chao.com.wanandroid/databases/aws_wan_android.db</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该命令输出了 <strong>进程的内存概要</strong>，我们应该着重关注 <strong>四个要点</strong>，下面我将一一进行讲解。</p>
<h4 id="1、查看-Native-Heap-的-Heap-Alloc-与-Dalvik-Heap-的-Heap-Alloc"><a href="#1、查看-Native-Heap-的-Heap-Alloc-与-Dalvik-Heap-的-Heap-Alloc" class="headerlink" title="1、查看 Native Heap 的 Heap Alloc 与 Dalvik Heap 的 Heap Alloc"></a>1、查看 Native Heap 的 Heap Alloc 与 Dalvik Heap 的 Heap Alloc</h4><ul>
<li>1）、<strong>Heap Alloc：表示 native 的内存占用，如果持续上升，则可能有泄漏</strong>。</li>
<li>2）、<strong>Heap Alloc：表示 Java 层的内存占用</strong>。</li>
</ul>
<h4 id="2、查看-Views、Activities、AppContexts-数量变化情况"><a href="#2、查看-Views、Activities、AppContexts-数量变化情况" class="headerlink" title="2、查看 Views、Activities、AppContexts 数量变化情况"></a>2、查看 Views、Activities、AppContexts 数量变化情况</h4><p><strong>如果 Views 与 Activities、AppContexts 持续上升，则表明有内存泄漏的风险</strong>。</p>
<h4 id="3、SQL-的-MEMORY-USED-与-PAGECACHE-OVERFLOW"><a href="#3、SQL-的-MEMORY-USED-与-PAGECACHE-OVERFLOW" class="headerlink" title="3、SQL 的 MEMORY_USED 与 PAGECACHE_OVERFLOW"></a>3、SQL 的 MEMORY_USED 与 PAGECACHE_OVERFLOW</h4><ul>
<li>1）<strong>、MEMOERY_USED：表示数据库使用的内存</strong>。</li>
<li>2）、<strong>PAGECACHE_OVERFLOW：表示溢出也使用的缓存，这个数值越小越好</strong>。</li>
</ul>
<h4 id="4、查看-DATABASES-信息"><a href="#4、查看-DATABASES-信息" class="headerlink" title="4、查看 DATABASES 信息"></a>4、查看 DATABASES 信息</h4><ul>
<li>1）、<strong>pgsz：表示数据库分页大小，这里全是 4KB</strong>。</li>
<li>2）、<strong>Lookaside(b)：表示使用了多少个 Lookaside 的 slots，可理解为内存占用的大小</strong>。</li>
<li>3）、<strong>cache：一栏中的 151&#x2F;32&#x2F;18  则分别表示 分页缓存命中次数&#x2F;未命中次数&#x2F;分页缓存个数，这里的未命中次数不应该大于命中次数</strong>。</li>
</ul>
<h2 id="3、LeakInspector"><a href="#3、LeakInspector" class="headerlink" title="3、LeakInspector"></a>3、LeakInspector</h2><p>LeakInspector 是腾讯内部的使用的 <strong>一站式内存泄漏解决方案</strong>，它是 Android 手机经过长期积累和提炼、<strong>集内存泄漏检测、自动修复系统Bug、自动回收已泄露Activity内资源、自动分析GC链、白名单过滤</strong> 等功能于一体，并 <strong>深度对接研发流程、自动分析责任人并提缺陷单的全链路体系</strong>。</p>
<h3 id="那么，LeakInspector-与-LeakCanary-又有什么不同之处呢？"><a href="#那么，LeakInspector-与-LeakCanary-又有什么不同之处呢？" class="headerlink" title="那么，LeakInspector 与 LeakCanary 又有什么不同之处呢？"></a>那么，LeakInspector 与 LeakCanary 又有什么不同之处呢？</h3><p>它们之间主要有 <strong>四个方面</strong> 的不同，如下所示：</p>
<h4 id="一、检测能力与原理方面不同"><a href="#一、检测能力与原理方面不同" class="headerlink" title="一、检测能力与原理方面不同"></a>一、检测能力与原理方面不同</h4><h5 id="1、检测能力"><a href="#1、检测能力" class="headerlink" title="1、检测能力"></a>1、检测能力</h5><p>它们都支持对 Activity、Fragment 及其它自定义类的泄漏检测，但是，LeakInspector 还 <strong>增加了 Btiamp 的检测能力</strong>，如下所示：</p>
<ul>
<li>1）、检测有没有在 View 上 decode 超过该 View 尺寸的图片，若有则上报出现问题的 Activity 及与其对应的 View id，并记录它的个数与平均占用内存的大小。</li>
<li>2）、检测图片尺寸是否超过所有手机屏幕大小，违规则报警。</li>
</ul>
<p>这一个部分的实现原理，我们可以采用 ARTHook 的方式来实现，还不清楚的朋友请再仔细看看大图检测的部分。</p>
<h5 id="2、检测原理"><a href="#2、检测原理" class="headerlink" title="2、检测原理"></a>2、检测原理</h5><p>两个工具的泄漏检测原理都是在 onDestroy 时检查弱引用，<strong>不同之处在于 LeakInspector 直接使用 WeakReference 来检测对象是否已经被释放</strong>，而 LeakCanary 则使用 ReferenceQueue，两者效果是一样的。</p>
<p>并且针对 Activity，我们通常都会使用 Application的 registerActivityLifecycleCallbacks 来注册 Activity 的生命周期，以重写 onActivityDestroyed 方法实现。但是在 <strong>Android 4.0 以下</strong>，系统并没有提供这个方法，为了避免手动在每一个 Activity 的 onDestroy 中去添加这份代码，我们可以使用 <strong>反射 Instrumentation 来截获 onDestory</strong>，以降低接入成本。代码如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;android.app.ActivityThread&quot;</span>)</span>;</span><br><span class="line">Method <span class="keyword">method</span> = clazz.get<span class="constructor">DeclaredMethod(<span class="string">&quot;currentActivityThread&quot;</span>, <span class="params">null</span>)</span>;</span><br><span class="line"><span class="keyword">method</span>.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line">sCurrentActivityThread = <span class="keyword">method</span>.invoke(null, null);</span><br><span class="line">Field field = sCurrentActivityThread.get<span class="constructor">Class()</span>.get<span class="constructor">DeclaredField(<span class="string">&quot;mInstumentation&quot;</span>)</span>;</span><br><span class="line">field.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line">field.set(sCurrentActivityThread, <span class="keyword">new</span> <span class="constructor">MonitorInstumentation()</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二、泄漏现场处理方面不同"><a href="#二、泄漏现场处理方面不同" class="headerlink" title="二、泄漏现场处理方面不同"></a>二、泄漏现场处理方面不同</h4><h5 id="1、dump-采集"><a href="#1、dump-采集" class="headerlink" title="1、dump 采集"></a>1、dump 采集</h5><p>两者都能采集 dump，但是 LeakInspector 提供了<strong>回调方法</strong>，我们可以<strong>增加更多的自定义信息</strong>，如运行时 Log、trace、dumpsys meminfo 等信息，以辅助分析定位问题。</p>
<h5 id="2、白名单定义"><a href="#2、白名单定义" class="headerlink" title="2、白名单定义"></a>2、白名单定义</h5><p>这里的白名单是为了处理一些系统引起的泄漏问题，以及一些因为 <strong>业务逻辑要开后门的情形而设置</strong> 的。分析时如果碰到白名单上标识的类，则不对这个泄漏做后续的处理。二者的配置差异有如下两点：</p>
<ul>
<li>1）、LeakInspector 的白名单以 XML 配置的形式存放在服务器上。<ul>
<li>优点：跟产品甚至不同版本的应用绑定，我们可以很方便地修改相应的配置。</li>
<li>缺点：白名单里的类不区分系统版本一刀切。</li>
</ul>
</li>
<li>1）、而LeakCanary的白名单是直接写死在其源码的AndroidExcludedRefs类里。<ul>
<li>优点：定义非常详细，并区分系统版本。</li>
<li>缺点：每次修改必定得重新编译。</li>
</ul>
</li>
<li>2）、LeakCanary 的系统白名单里定义的类比 LeakInspector 中定义的多很多，因为它没有自动修复系统泄漏功能。</li>
</ul>
<h5 id="3、自动修复系统泄漏"><a href="#3、自动修复系统泄漏" class="headerlink" title="3、自动修复系统泄漏"></a>3、自动修复系统泄漏</h5><p>针对系统泄漏，LeakInspector 通过 <strong>反射自动修复</strong> 了目前碰到的一些系统泄漏，只要在 <strong>onDestory</strong> 里面 <strong>调用</strong> 一个修复系统泄漏的方法即可。而 LeakCanary 虽然能识别系统泄漏，但是它仅仅对该类问题给出了分析，没有提供实际可用的解决方案。</p>
<h5 id="4、回收资源（Activity内存泄漏兜底处理）"><a href="#4、回收资源（Activity内存泄漏兜底处理）" class="headerlink" title="4、回收资源（Activity内存泄漏兜底处理）"></a>4、回收资源（Activity内存泄漏兜底处理）</h5><p>如果检测到发生了内存泄漏，LeakInspector 会对整个 Activity 的 View 进行遍历，把图片资源等一些占内存的数据释放掉，保证此次泄漏只会泄漏一个Activity的空壳，尽量减少对内存的影响。代码大致如下所示：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (View instanceof ImageView) &#123;</span><br><span class="line">    <span class="comment">// ImageView ImageButton处理</span></span><br><span class="line">    <span class="built_in">recycleImageView</span>(app, (ImageView) view);</span><br><span class="line">&#125; else if (view instanceof TextView) &#123;</span><br><span class="line">    <span class="comment">// 释放TextView、Button周边图片资源</span></span><br><span class="line">    <span class="built_in">recycleTextView</span>((TextView) view);</span><br><span class="line">&#125; else if (View instanceof ProgressBar) &#123;</span><br><span class="line">    <span class="built_in">recycleProgressBar</span>((ProgressBar) view);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (view instancof android.widget.ListView) &#123;</span><br><span class="line">        <span class="built_in">recycleListView</span>((android.widget.ListView) view);</span><br><span class="line">    &#125; else if (view instanceof android.support.v7.widget.RecyclerView) &#123;</span><br><span class="line">        <span class="built_in">recycleRecyclerView</span>((android.support.v7.widget.RecyclerView) view);</span><br><span class="line">    &#125; else if (view instanceof FrameLayout) &#123;</span><br><span class="line">        <span class="built_in">recycleFrameLayout</span>((FrameLayout) view);</span><br><span class="line">    &#125; else if (view instanceof LinearLayout) &#123;</span><br><span class="line">        <span class="built_in">recycleLinearLayout</span>((LinearLayout) view);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (view instanceof ViewGroup) &#123;</span><br><span class="line">        <span class="built_in">recycleViewGroup</span>(app, (ViewGroup) view);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里以 recycleTextView 为例，它回收资源的方式如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static void recycle<span class="constructor">TextView(TextView <span class="params">tv</span>)</span> &#123;</span><br><span class="line">    Drawable<span class="literal">[]</span> ds = tv.get<span class="constructor">CompoundDrawables()</span>;</span><br><span class="line">    <span class="keyword">for</span> (Drawable d : ds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d != null) &#123;</span><br><span class="line">            d.set<span class="constructor">Callback(<span class="params">null</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tv.set<span class="constructor">CompoundDrawables(<span class="params">null</span>, <span class="params">null</span>, <span class="params">null</span>, <span class="params">null</span>)</span>;</span><br><span class="line">    <span class="comment">// 取消焦点，让Editor$Blink这个Runnable不再被post，解决内存泄漏。</span></span><br><span class="line">    tv.set<span class="constructor">CursorVisible(<span class="params">false</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="三、后期处理不同"><a href="#三、后期处理不同" class="headerlink" title="三、后期处理不同"></a>三、后期处理不同</h4><h5 id="1、分析与展示"><a href="#1、分析与展示" class="headerlink" title="1、分析与展示"></a>1、分析与展示</h5><p>采集 dump 之后，LeakInspector 会上传 dump 文件，并* *调用 MAT 命令行来进行分析**，得到这次泄漏的 GC 链。而 LeakCanary 则用开源组件 HAHA 来分析得到一个 GC 链。但是 LeakCanary 得到的 GC 链包含被 hold 住的类对象，一般都不需要用 MAT 打开 Hporf 即可解决问题。而 LeakInpsector 得到的 GC 链只有类名，还需要 MAT 打开 Hprof 才能具体去定位问题，不是很方便。</p>
<h5 id="2、后续跟进闭环"><a href="#2、后续跟进闭环" class="headerlink" title="2、后续跟进闭环"></a>2、后续跟进闭环</h5><p>LeakInspector <strong>在 dump 分析结束之后，会提交缺陷单，并且把缺陷单分配给对应类的负责人。如果发现重复的问题则更新旧单，同时具备重新打开单等状态转换逻辑</strong>。而 LeakCanary 仅会在通知栏提醒用户，需要用户自己记录该问题并做后续处理。</p>
<h4 id="四、配合自动化测试方面不同"><a href="#四、配合自动化测试方面不同" class="headerlink" title="四、配合自动化测试方面不同"></a>四、配合自动化测试方面不同</h4><p>LeakInspector 跟自动化测试可以无缝结合，当自动化脚本执行中发现内存泄漏，可以由它采集 dump 并发送到服务进行分析，最后提单，整个流程是不需要人力介入的。而 LeakCanary 则把分析结果通过通知栏告知用户，需要人工介入才能进入下一个流程。</p>
<h2 id="4、JHat"><a href="#4、JHat" class="headerlink" title="4、JHat"></a>4、JHat</h2><p>JHat 是 Oracle 推出的一款 Hprof 分析软件，它和 MAT 并称为 Java 内存静态分析利器。不同于 MAT 的单人界面式分析，jHat <strong>使用多人界面式分析</strong>。它被 <strong>内置在 JDK 中</strong>，在命令行中输入 jhat 命令可查看有没有相应的命令。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">quchao@quchaodeMacBook-Pro ~ % jhat</span><br><span class="line">ERROR: <span class="keyword">No</span> arguments supplied</span><br><span class="line"><span class="keyword">Usage</span>:  jhat [-stack &lt;<span class="type">bool</span>&gt;] [-refs &lt;<span class="type">bool</span>&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-<span class="keyword">debug</span> &lt;<span class="type">int</span>&gt;] [-<span class="keyword">version</span>] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    -J&lt;flag&gt;          Pass &lt;flag&gt; directly <span class="keyword">to</span> the runtime <span class="keyword">system</span>. <span class="keyword">For</span></span><br><span class="line">		    example, -J-mx512m <span class="keyword">to</span> use a maximum heap size <span class="keyword">of</span> <span class="number">512</span>MB</span><br><span class="line">    -stack <span class="keyword">false</span>:     Turn <span class="keyword">off</span> tracking <span class="keyword">object</span> allocation <span class="keyword">call</span> stack.</span><br><span class="line">    -refs <span class="keyword">false</span>:      Turn <span class="keyword">off</span> tracking <span class="keyword">of</span> <span class="keyword">references</span> <span class="keyword">to</span> objects</span><br><span class="line">    -port &lt;port&gt;:     <span class="keyword">Set</span> the port <span class="keyword">for</span> the HTTP <span class="keyword">server</span>.  Defaults <span class="keyword">to</span> <span class="number">7000</span></span><br><span class="line">    -<span class="keyword">exclude</span> &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">		    be excluded <span class="keyword">from</span> the reachableFrom query.</span><br><span class="line">    -baseline &lt;file&gt;: Specify a baseline <span class="keyword">object</span> dump.  Objects <span class="keyword">in</span></span><br><span class="line">		    <span class="keyword">both</span> heap dumps <span class="keyword">with</span> the same ID <span class="keyword">and</span> same <span class="keyword">class</span> will</span><br><span class="line">		    be marked <span class="keyword">as</span> <span class="keyword">not</span> being &quot;new&quot;.</span><br><span class="line">    -<span class="keyword">debug</span> &lt;<span class="type">int</span>&gt;:     <span class="keyword">Set</span> <span class="keyword">debug</span> <span class="keyword">level</span>.</span><br><span class="line">		        <span class="number">0</span>:  <span class="keyword">No</span> <span class="keyword">debug</span> output</span><br><span class="line">		        <span class="number">1</span>:  <span class="keyword">Debug</span> hprof file parsing</span><br><span class="line">		        <span class="number">2</span>:  <span class="keyword">Debug</span> hprof file parsing, <span class="keyword">no</span> <span class="keyword">server</span></span><br><span class="line">    -<span class="keyword">version</span>          Report <span class="keyword">version</span> number</span><br><span class="line">    -h|-help          Print this help <span class="keyword">and</span> <span class="keyword">exit</span></span><br><span class="line">    &lt;file&gt;            The file <span class="keyword">to</span> <span class="keyword">read</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> a dump file that contains multiple heap dumps,</span><br><span class="line">you may specify which dump <span class="keyword">in</span> the file</span><br><span class="line"><span class="keyword">by</span> appending &quot;#&lt;number&gt;&quot; <span class="keyword">to</span> the file <span class="type">name</span>, i.e. &quot;foo.hprof#3&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>出现如上输出，则表明存在 jhat 命令。它的使用很简单，直在命令行输入 jhat xxx.hprof 即可，如下所示：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">quchao@quchaodeMacBook<span class="params">-Pro</span> ~ % jhat Documents/heapdump/<span class="literal">new</span><span class="number">-33.</span>hprof</span><br><span class="line">Snapshot read, resolving<span class="params">...</span></span><br><span class="line">Resolving <span class="number">408200</span> objects<span class="params">...</span></span><br><span class="line">Chasing references, expect <span class="number">81</span> dots<span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span></span><br><span class="line">Eliminating duplicate references<span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span></span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server <span class="keyword">on</span> port <span class="number">7000</span></span><br><span class="line">Server is ready.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>jHat 的执行过程是解析 Hprof 文件，然后启动 httpsrv 服务，默认是在 7000 端口监听 Web 客户端链接，维护 Hprof 解析后的数据，以持续供给 Web 客户端进行查询操作</strong>。</p>
<p>启动服务器后，我们打开 <strong>入口地址 127.0.0.1:7000</strong> 即可查看 <strong>All Classes</strong> 界面，如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11b50f4998d34df6a3412e09891d00a7~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<p>jHat 还有两个比较重要的功能，分别如下所示：</p>
<h3 id="1、统计表"><a href="#1、统计表" class="headerlink" title="1、统计表"></a>1、统计表</h3><p>打开 127.0.0.1:7000&#x2F;histo&#x2F;，统计表界面如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c0743df8f634d3ab5904e60bf8979a2~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<p>可以到，按 Total Size 降序 排列了所有的 Class，并且，我们还可以查看到每一个 Class 与之对应的实例数量。</p>
<h3 id="2、OQL-查询"><a href="#2、OQL-查询" class="headerlink" title="2、OQL 查询"></a>2、OQL 查询</h3><p>OQL 是一种模仿 SQL 语句的查询语句，通常用来查询某个类的实例数量，打开 <strong>127.0.0.1:7000&#x2F;oql&#x2F;</strong> 并输入 java.lang.String 查询 String 实例的数量，结果如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0da6b1b086bd4b5d81ad87b6795cbc27~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<p><strong>JHat 比 MAT 更加灵活，且符合大型团队安装简单、团队协作的需求</strong>。但是，并不适合中小型高效沟通型团队使用。</p>
<h2 id="5、ART-GC-Log"><a href="#5、ART-GC-Log" class="headerlink" title="5、ART GC Log"></a>5、ART GC Log</h2><p>GC Log 分为 Dalvik 和 ART 的 GC 日志，关于 Dalvik 的 GC 日志，我们在前篇 <a href="https://link.juejin.cn/?target=https://jsonchao.github.io/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">Android性能优化之内存优化</a> 中已经详细讲解过了，接下来我们说说 <strong>ART 的 GC 日志</strong>。</p>
<p>ART 的日志与 Dalvik 的日志差距非常大，除了格式不同之外，打印的时间也不同，而且，它只有在慢 GC 时才会打印出来。下面我们看看这条 ART GC Log：</p>
<table>
<thead>
<tr>
<th>Explicit</th>
<th>（full）</th>
<th>concurrent mark sweep GC</th>
<th>freed 104710 （7MB） AllocSpace objects,</th>
<th>21（416KB） LOS objects，</th>
<th>33% free,25MB&#x2F;38MB</th>
<th>paused 1.230ms total 67.216ms</th>
</tr>
</thead>
<tbody><tr>
<td>GC产生的原因</td>
<td>GC类型</td>
<td>采集方法</td>
<td>释放的数量和占用的空间</td>
<td>释放的大对象数量和所占用的空间</td>
<td>堆中空闲空间的百分比和（对象的个数）&#x2F;（堆的总空间）</td>
<td>暂停耗时</td>
</tr>
</tbody></table>
<h3 id="GC-产生的原因"><a href="#GC-产生的原因" class="headerlink" title="GC 产生的原因"></a>GC 产生的原因</h3><p>GC 产生的原因有如下九种：</p>
<ul>
<li>1）、<strong>Concurrent、Alloc、Explicit</strong> 跟 Dalvik 的基本一样，这里就不重复介绍了。</li>
<li>2）、<strong>NativeAlloc：Native 内存分配时，比如为 Bitmaps 或者 RenderScript 分配对象， 这会导致Native内存压力，从而触发GC</strong>。</li>
<li>3）、<strong>Background：后台 GC，触发是为了给后面的内存申请预留更多空间</strong>。</li>
<li>4）、<strong>CollectorTransition：由堆转换引起的回收，这是运行时切换 GC 而引起的。收集器转换包括将所有对象从空闲列表空间复制到碰撞指针空间（反之亦然）。当前，收集器转换仅在以下情况下出现：在内存较小的设备上，App 将进程状态从可察觉的暂停状态变更为可察觉的非暂停状态（反之亦然）</strong>。</li>
<li>5）、<strong>HomogeneousSpaceCompact：齐性空间压缩是指空闲列表到压缩的空闲列表空间，通常发生在当 App 已经移动到可察觉的暂停进程状态。这样做的主要原因是减少了内存使用并对堆内存进行碎片整理</strong>。</li>
<li>6）、<strong>DisableMovingGc：不是真正的触发 GC 原因，发生并发堆压缩时，由于使用了 GetPrimitiveArrayCritical，收集会被阻塞。一般情况下，强烈建议不要使用 GetPrimitiveArrayCritical</strong>。</li>
<li>7）、<strong>HeapTrim：不是触发GC原因，但是请注意，收集会一直被阻塞，直到堆内存整理完毕</strong>。</li>
</ul>
<h3 id="GC-类型"><a href="#GC-类型" class="headerlink" title="GC 类型"></a>GC 类型</h3><p>GC 类型有如下三种：</p>
<ul>
<li>1）、<strong>Full：与Dalvik的 FULL GC 差不多</strong>。</li>
<li>2）、<strong>Partial：跟 Dalvik 的局部 GC 差不多，策略时不包含 Zygote Heap</strong>。</li>
<li>3）、<strong>Sticky：另外一种局部中的局部 GC，选择局部的策略是上次垃圾回收后新分配的对象</strong>。</li>
</ul>
<h3 id="GC采集的方法"><a href="#GC采集的方法" class="headerlink" title="GC采集的方法"></a>GC采集的方法</h3><p>GC 采集的方法有如下四种：</p>
<ul>
<li>1）、<strong>mark sweep：先记录全部对象，然后从 GC ROOT 开始找出间接和直接的对象并标注。利用之前记录的全部对象和标注的对象对比，其余的对象就应该需要垃圾回收了</strong>。</li>
<li>2）、<strong>concurrent mark sweep：使用 mark sweep 采集器的并发 GC</strong>。</li>
<li>3）、<strong>mark compact：在标记存活对象的时候，所有的存活对象压缩到内存的一端，而另一端可以更加高效地被回收</strong>。</li>
<li>4）、<strong>semispace：在做垃圾扫描的时候，把所有引用的对象从一个空间移到另外一个空间，然后直接 GC 剩余在旧空间中的对象即可</strong>。</li>
</ul>
<p>通过 GC 日志，我们可以知道 <strong>GC 的量和 它对卡顿的影响</strong>，也可以 <strong>初步定位一些如主动调用GC、可分配的内存不足、过多使用Weak Reference</strong> 等问题。</p>
<h2 id="6、Chrome-Devtool"><a href="#6、Chrome-Devtool" class="headerlink" title="6、Chrome Devtool"></a>6、Chrome Devtool</h2><p>对于 HTML5 页面而言，抓取 JavaScript 的内存需要使用 Chrome Devtools 来进行远程调试。方式有如下两种：</p>
<ul>
<li>1）、直接把 URL 抓取出来放到 Chrome 里访问。</li>
<li>2）、用 Android H5 远程调试。</li>
</ul>
<h3 id="纯H5"><a href="#纯H5" class="headerlink" title="纯H5"></a>纯H5</h3><h4 id="1、手机安装-Chrome，打开-USB-调试模式，通过-USB-连上电脑，在-Chrome-里打开一个页面，比如百度页面。然后在-PC-Chrome-地址栏里访问-Chrome-x2F-x2F-inspect，如下图所示："><a href="#1、手机安装-Chrome，打开-USB-调试模式，通过-USB-连上电脑，在-Chrome-里打开一个页面，比如百度页面。然后在-PC-Chrome-地址栏里访问-Chrome-x2F-x2F-inspect，如下图所示：" class="headerlink" title="1、手机安装 Chrome，打开 USB 调试模式，通过 USB 连上电脑，在 Chrome 里打开一个页面，比如百度页面。然后在 PC Chrome 地址栏里访问 Chrome:&#x2F;&#x2F;inspect，如下图所示："></a>1、手机安装 Chrome，打开 USB 调试模式，通过 USB 连上电脑，在 Chrome 里打开一个页面，比如百度页面。然后在 PC Chrome 地址栏里访问 Chrome:&#x2F;&#x2F;inspect，如下图所示：</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f410fd1ebeee4843b086e67ed770b408~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<h4 id="2、最后，直接点击-Chrome-下面的-inspect-选项即可弹出开发者工具界面。如下图所示："><a href="#2、最后，直接点击-Chrome-下面的-inspect-选项即可弹出开发者工具界面。如下图所示：" class="headerlink" title="2、最后，直接点击 Chrome 下面的 inspect 选项即可弹出开发者工具界面。如下图所示："></a>2、最后，直接点击 Chrome 下面的 inspect 选项即可弹出开发者工具界面。如下图所示：</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56a1a83e428047c5b080a4202bbb7d30~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<h4 id="默认-Hybrid-H5-调试"><a href="#默认-Hybrid-H5-调试" class="headerlink" title="默认 Hybrid H5 调试"></a>默认 Hybrid H5 调试</h4><p>Android 4.4 及以上系统的原生浏览器就是 Chrome 浏览器，可以使用 Chrome Devtool 远程调试 WebView，前提是需要在 App 的代码里把调试开关打开，如下代码所示：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="keyword">Build.VERSION_SDK_INT </span>&gt;= <span class="keyword">Build.VERSION_CODES.KITKAT </span>&amp;&amp; 是<span class="built_in">debug</span>模式) &#123;</span><br><span class="line">    WebView.setWebContentsDebuggingEnabled(ture);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开后的调试方法跟纯 H5 页面调试方法一样，直接在 App 中打开 H5 页面，再到 PC Chrome 的 inpsector 页面就可以看到调试目标页面。</p>
<p>这里总结一下 <strong>JS 中几种常见的内存问题点</strong>：</p>
<ul>
<li>1）、<strong>closure 闭包函数</strong>。</li>
<li>2）、<strong>事件监听</strong>。</li>
<li>3）、<strong>变量作用域使用不当，全局变量的引用导致无法释放</strong>。</li>
<li>4）、<strong>DOM 节点的泄漏</strong>。</li>
</ul>
<p>若想更深入地学习 Chrome 开发者工具的使用方法，请查看 <a href="https://link.juejin.cn/?target=https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools">《Chrome开发者工具中文手册》</a>。</p>
<h1 id="八、内存问题总结"><a href="#八、内存问题总结" class="headerlink" title="八、内存问题总结"></a>八、内存问题总结</h1><p>在我们进行内存优化的过程中，<strong>有许多内存问题都可以归结为一类问题，为了便于以后快速地解决类似的内存问题，我将它们归结成了以下的多个要点</strong>：</p>
<h2 id="1、内类是有危险的编码方式"><a href="#1、内类是有危险的编码方式" class="headerlink" title="1、内类是有危险的编码方式"></a>1、内类是有危险的编码方式</h2><p>说道内类就不得不提到 ”<strong>this0“∗∗，它是一种奇特的内类成员，每个类实例都具有一个this0“</strong>，它是一种奇特的内类成员，每个类实例都具有一个 this0“∗∗，它是一种奇特的内类成员，每个类实例都具有一个this0，当它的内类需要访问它的成员时，内类就会持有外类的 this0，通过this0，通过 this0，通过this0 就可以访问外部类所有的成员。</p>
<p>解决方案是在 Activity 关闭，即触发 onDestory 时解除内类和外部的引用关系。</p>
<h2 id="2、普通-Hanlder-内部类的问题"><a href="#2、普通-Hanlder-内部类的问题" class="headerlink" title="2、普通 Hanlder 内部类的问题"></a>2、普通 Hanlder 内部类的问题</h2><p>这也是一个 this$0 间接引用的问题，对于 Handler 的解决方案一般可以归结为如下三个步骤：</p>
<ul>
<li>1）、<strong>把内类声明成 static：用来断绝 this$0 的引用。因为 static 描述的内类从 Java 编译原理的角度看，”内类“与”外类“相互独立，互相都没有访问对方成员变量的能力</strong>。</li>
<li>2、<strong>使用 WeakReference 来引用外部类的实例</strong>。</li>
<li>3、<strong>在外部类（如 Activity）销毁的时候使用 removeCallbackAndMessages 来移除回调和消息</strong>。</li>
</ul>
<p>这里需要在使用过程中<strong>注意对 WeakReference 进行判空</strong>。</p>
<h2 id="3、登录界面的内存问题"><a href="#3、登录界面的内存问题" class="headerlink" title="3、登录界面的内存问题"></a>3、登录界面的内存问题</h2><p>如果在闪屏页跳转到登录界面时没有调用 finish()，则会造成闪屏页的内存泄漏，在<strong>碰到这种”过渡界面“的情况时，需要注意不要产生这样的内存 Bug</strong>。</p>
<h2 id="4、使用系统服务时产生的内存问题"><a href="#4、使用系统服务时产生的内存问题" class="headerlink" title="4、使用系统服务时产生的内存问题"></a>4、使用系统服务时产生的内存问题</h2><p>我们通常都会使用 getSystemService 方法来获取系统服务，但是当在 Activity 中调用时，会默认把 Activity 的 Context 传给系统服务，在某些不确定的情况下，某些系统服务内部会产生异常，从而 hold 住外界传入的 Context。</p>
<p>解决方案是 <strong>直接使用 Applicaiton 的 Context 去获取系统服务</strong>。</p>
<h2 id="5、把-WebView-类型的泄漏装进垃圾桶进程"><a href="#5、把-WebView-类型的泄漏装进垃圾桶进程" class="headerlink" title="5、把 WebView 类型的泄漏装进垃圾桶进程"></a>5、把 WebView 类型的泄漏装进垃圾桶进程</h2><p>我们都知道，对应 WebView 来说，其 <strong>网络延时、引擎 Session 管理、Cookies 管理、引擎内核线程、HTML5 调用系统声音、视频播放组件等产生的引用链条无法及时打断</strong>，造成的内存问题基本上可以用”无解“来形容。</p>
<p>解决方案是我们可以 <strong>把 WebView 装入另一个进程</strong>。 具体为<strong>在 AndroidManifes 中对当前的 Activity 设置 android:process 属性即可，最后，在 Activity 的 onDestory 中退出进程，这样即可基本上终结 WebView 造成的泄漏</strong>。</p>
<h2 id="6、在适当的时候对组件进行注销"><a href="#6、在适当的时候对组件进行注销" class="headerlink" title="6、在适当的时候对组件进行注销"></a>6、在适当的时候对组件进行注销</h2><p>我们在平常开发过程中经常需要在Activity创建的时候去注册一些组件，如广播、定时器、事件总线等等。这个时候我们应该在适当的时候对组件进行注销，如 <strong>onPause 或 onDestory 方法中</strong>。</p>
<h2 id="7、Handler-x2F-FrameLayout-的-postDelyed-方法触发的内存问题"><a href="#7、Handler-x2F-FrameLayout-的-postDelyed-方法触发的内存问题" class="headerlink" title="7、Handler &#x2F; FrameLayout 的 postDelyed 方法触发的内存问题"></a>7、Handler &#x2F; FrameLayout 的 postDelyed 方法触发的内存问题</h2><p>不仅在使用 Handler 的 sendMessage 方法时，我们需要在 onDestory 中使用 removeCallbackAndMessage 移除回调和消息，在使用到 Handler &#x2F; FrameLayout 的 postDelyed 方法时，我们需要<strong>调用 removeCallbacks 去移除实现控件内部的延时器对 Runnable 内类的持有</strong>。</p>
<h2 id="8、图片放错资源目录也会有内存问题"><a href="#8、图片放错资源目录也会有内存问题" class="headerlink" title="8、图片放错资源目录也会有内存问题"></a>8、图片放错资源目录也会有内存问题</h2><p>在做资源适配的时候，因为需要考虑到 APK 的瘦身问题，无法为每张图片在每个 drawable &#x2F; mipmap 目录下安置一张适配图片的副本。很多同学不知道图片应该放哪个目录，如果放到分辨率低的目录如 hdpi 目录，则可能会造成内存问题，这个时候<strong>建议尽量问设计人员要高品质图片然后往高密度目录下方，如 xxhdpi 目录</strong>，这样 <strong>在低密屏上”放大倍数“是小于1的</strong>，在保证画质的前提下，内存也是可控的。<strong>也可以使用 Drawable.createFromSream 替换 getResources().getDrawable 来加载，这样便可以绕过 Android 的默认适配规则</strong>。</p>
<p>对于已经被用户使用物理“返回键”退回到后台的进程，如果包含了以下 <strong>两点</strong>，则 <strong>不会被轻易杀死</strong>。</p>
<ul>
<li>1）、<strong>进程包含了服务 startService，而服务本身调用了 startForeground（低版本需通过反射调用）</strong>。</li>
<li>2）、<strong>主 Activity 没有实现 onSaveInstanceState 接口</strong>。</li>
</ul>
<p>但建议 <strong>在运行一段时间（如3小时）后主动保存界面进程（位于后台），然后重启它，这样可以有效地降低内存负载</strong>。</p>
<h2 id="9、列表-item-被回收时注意释放图片的引用"><a href="#9、列表-item-被回收时注意释放图片的引用" class="headerlink" title="9、列表 item 被回收时注意释放图片的引用"></a>9、列表 item 被回收时注意释放图片的引用</h2><p>我们应该在 item 被回收不可见时去释放掉对图片的引用。如果你使用的是 <strong>ListView</strong>，由于每次 item 被回收后被再次利用都会去重新绑定数据，所以只需<strong>在 ImageView 回调其 onDetchFromWindow 方法的时候区释放掉图片的引用即可</strong>。如果你使用的是 <strong>RecyclerView</strong>，因为被回收不可见时第一次选择是放进 mCacheView中，但是这里面的 item 被复用时并不会去执行 bindViewHolder 来重新绑定数据，只有被回收进 mRecyclePool 后拿出来复用才会重新绑定数据。所以此时我们应该<strong>在 item 被回收进 RecyclePool 的时候去释放图片的引用</strong>，这里我们只要去 <strong>重写 Adapter 中的 onViewRecycled 方法</strong> 就可以了，代码如下所示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void onViewRecycled(<span class="variable">@Nullable</span> VH holder) &#123;</span><br><span class="line">    <span class="selector-tag">super</span><span class="selector-class">.onViewRecycled</span>(holder);</span><br><span class="line">    <span class="selector-tag">if</span> (holder != null) &#123;</span><br><span class="line">        <span class="comment">//做释放图片引用的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="10、使用-ViewStub-进行占位"><a href="#10、使用-ViewStub-进行占位" class="headerlink" title="10、使用 ViewStub 进行占位"></a>10、使用 ViewStub 进行占位</h2><p>我们应该使用 ViewStub  <strong>对那些没有马上用到的资源去做延迟加载</strong>，并且还有<strong>很多大概率不会出现的 View 更要去做懒加载</strong>，这样可以等到要使用时再去为它们分配相应的内存。</p>
<h2 id="11、注意定时清理-App-过时的埋点数据"><a href="#11、注意定时清理-App-过时的埋点数据" class="headerlink" title="11、注意定时清理 App 过时的埋点数据"></a>11、注意定时清理 App 过时的埋点数据</h2><p>产品或者运营为了统计数据会在每个版本中不断地增加新的埋点。所以我们需要定期地去清理一些过时的埋点，以此来 <strong>适当地优化内存以及CPU的压力</strong>。</p>
<h2 id="12、针对匿名内部类-Runnable-造成内存泄漏的处理"><a href="#12、针对匿名内部类-Runnable-造成内存泄漏的处理" class="headerlink" title="12、针对匿名内部类 Runnable 造成内存泄漏的处理"></a>12、针对匿名内部类 Runnable 造成内存泄漏的处理</h2><p>我们在做子线程操作的时候，喜欢使用匿名内部类 Runnable 来操作。但是，如果某个 Activity 放在线程池中的任务不能及时执行完毕，在 Activity 销毁时很容易导致内存泄漏。因为这个<strong>匿名内部类 Runnable 类持有一个指向 Outer 类的引用，这样一来如果 Activity 里面的 Runnable 不能及时执行，就会使它外围的 Activity 无法释放，产生内存泄漏</strong>。从上面的分析可知，<strong>只要在 Activity 退出时没有这个引用即可</strong>，那我们就<strong>通过反射，在 Runnable 进入线程池前先干掉它</strong>，代码如下所示：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field f = job.getClass().getDeclaredField(<span class="string">&quot;this<span class="variable">$0</span>&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">f.<span class="built_in">set</span>(job, <span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个任务就是我们的 Runnable 对象，而 ”this$0“ 就是上面所指的外部类的引用了。这里注意使用 WeakReference 装起来，要执行了先 get 一下，如果是 null 则说明 Activity 已经回收，任务就放弃执行。</p>
<h1 id="九、内存优化常见问题"><a href="#九、内存优化常见问题" class="headerlink" title="九、内存优化常见问题"></a>九、内存优化常见问题</h1><h2 id="1、你们内存优化项目的过程是怎么做的？"><a href="#1、你们内存优化项目的过程是怎么做的？" class="headerlink" title="1、你们内存优化项目的过程是怎么做的？"></a>1、你们内存优化项目的过程是怎么做的？</h2><h3 id="1、分析现状、确认问题"><a href="#1、分析现状、确认问题" class="headerlink" title="1、分析现状、确认问题"></a>1、分析现状、确认问题</h3><p>我们发现我们的 APP 在内存方面可能存在很大的问题，第一方面的原因是我们的线上的 OOM 率比较高。</p>
<p>第二点呢，我们经常会看到在我们的 Android Studio 的 Profiler 工具中内存的抖动比较频繁。</p>
<p>这是我们一个初步的现状，然后在我们知道了这个初步的现状之后，进行了问题的确认，我们经过一系列的调研以及深入研究，我们最终发现我们的项目中存在以下几点大问题，比如说：<strong>内存抖动、内存溢出、内存泄漏，还有我们的Bitmap 使用非常粗犷</strong>。</p>
<h3 id="2、针对性优化"><a href="#2、针对性优化" class="headerlink" title="2、针对性优化"></a>2、针对性优化</h3><p>比如 <strong>内存抖动的解决 &#x3D;&gt; Memory Profiler 工具的使用（呈现了锯齿张图形） &#x3D;&gt; 分析到具体代码存在的问题（频繁被调用的方法中出现了日志字符串的拼接）</strong>，也可以说说 <strong>内存泄漏或内存溢出的解决</strong>。</p>
<h3 id="3、效率提升"><a href="#3、效率提升" class="headerlink" title="3、效率提升"></a>3、效率提升</h3><p>为了不增加业务同学的工作量，我们使用了一些工具类或 <strong>ARTHook</strong> 这样的 <strong>大图检测方案，没有任何的侵入性</strong>。同时，我们将这些技术教给了大家，然后让大家一起进行 <strong>工作效率上的提升</strong>。</p>
<p>我们对内存优化工具Profiler Memory、MAT 的使用比较熟悉，因此 <strong>针对一系列不同问题的情况</strong>，我们写了 <strong>一系列解决方案的文档</strong>，分享给大家。这样，我们 <strong>整个团队成员的内存优化意识就变强</strong> 了。</p>
<h2 id="2、你做了内存优化最大的感受是什么？"><a href="#2、你做了内存优化最大的感受是什么？" class="headerlink" title="2、你做了内存优化最大的感受是什么？"></a>2、你做了内存优化最大的感受是什么？</h2><h3 id="1、磨刀不误砍柴工"><a href="#1、磨刀不误砍柴工" class="headerlink" title="1、磨刀不误砍柴工"></a>1、磨刀不误砍柴工</h3><p>我们一开始并没有直接去分析项目中代码哪些地方存在内存问题，而是先去学习了 Google 官方的一些文档，比如说学习了 Memory Profiler 工具的使用、学习了 MAT 工具的使用，在我们将这些工具学习熟练之后，当在我们的项目中遇到内存问题时，我们就能够很快地进行排查定位问题进行解决。</p>
<h3 id="2、技术优化必须结合业务代码"><a href="#2、技术优化必须结合业务代码" class="headerlink" title="2、技术优化必须结合业务代码"></a>2、技术优化必须结合业务代码</h3><p>一开始，我们做了整体 APP 运行阶段的一个内存上报，然后，我们在一些重点的内存消耗模块进行了一些监控，但是，后面发现这些监控并没有紧密地结合我们的业务代码，比如说在梳理完项目之后，发现我们项目中存在使用多个图片库的情况，<strong>多个图片库的内存缓存肯定是不公用的</strong>，所以 <strong>导致我们整个项目的内存使用量非常高</strong>。所以进行技术优化时必须结合我们的业务代码。</p>
<h3 id="3、系统化完善解决方案"><a href="#3、系统化完善解决方案" class="headerlink" title="3、系统化完善解决方案"></a>3、系统化完善解决方案</h3><p>我们在做内存优化的过程中，不仅做了 Android 端的优化工作，还将我们 Android 端一些数据的采集上报到了我们的服务器，然后传到我们的 APM 后台，这样，方便我们的无论是 Bug 跟踪人员或者是 Crash 跟踪人员进行一系列问题的解决。</p>
<h2 id="3、如何检测所有不合理的地方？"><a href="#3、如何检测所有不合理的地方？" class="headerlink" title="3、如何检测所有不合理的地方？"></a>3、如何检测所有不合理的地方？</h2><p>比如说 <strong>大图片的检测</strong>，我们最初的一个方案是通过<strong>继承 ImageView</strong>，<strong>重写</strong> 它的 <strong>onDraw</strong> 方法来实现。但是，我们在推广它的过程中，发现很多开发人员并不接受，因为很多 ImageView 之前已经写过了，你现在让他去替换，工作成本是比较高的。所以说，后来我们就想，有没有一种方案可以 <strong>免替换</strong>，最终我们就找到了 <strong>ARTHook</strong> 这样一个 Hook 的方案。</p>
<h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>对于 <strong>内存优化的专项优化</strong> 而言，我们要着重注意两点，即 <strong>优化大方向 和 优化细节</strong>。</p>
<h2 id="1、优化大方向"><a href="#1、优化大方向" class="headerlink" title="1、优化大方向"></a>1、优化大方向</h2><p>对于 <strong>优化的大方向</strong>，我们应该 <strong>优先去做见效快的地方</strong>，主要有以下三部分：</p>
<ul>
<li>1）、<strong>内存泄漏</strong></li>
<li>2）、<strong>内存抖动</strong></li>
<li>3）、<strong>Bitmap</strong></li>
</ul>
<h2 id="2、优化细节"><a href="#2、优化细节" class="headerlink" title="2、优化细节"></a>2、优化细节</h2><p>对于 <strong>优化细节</strong>，我们应该 <strong>注意一些系统属性或内存回调的使用</strong> 等等，主要可以细分为如下六部分：</p>
<ul>
<li>1）、<strong>LargeHeap 属性</strong></li>
<li>2）、<strong>onTrimMemory &#x2F; onLowMemory</strong></li>
<li>3）、<strong>使用优化过后的集合：如 SparseArray 类簇</strong></li>
<li>4）、<strong>谨慎使用 SharedPreference</strong></li>
<li>5）、<strong>谨慎使用外部库</strong></li>
<li>6）、<strong>业务架构设计合理</strong></li>
</ul>
<h2 id="3、内存优化体系化建设总结"><a href="#3、内存优化体系化建设总结" class="headerlink" title="3、内存优化体系化建设总结"></a>3、内存优化体系化建设总结</h2><p>在这篇文章中，我们除了建立了 <strong>内存的监控闭环</strong> 这一核心体系之外，还实现了以下 <strong>十大组件 &#x2F; 策略</strong>：</p>
<ul>
<li>1）、<strong>根据设备分级来使用不同的内存和分配回收策略</strong>。</li>
<li>2）、<strong>针对低端机做了功能或图片加载格式的降级处理</strong>。</li>
<li>3）、<strong>针对缓存滥用的问题实现了统一的缓存管理组件</strong>。</li>
<li>4）、<strong>实现了大图监控和重复图片的监控</strong>。</li>
<li>5）、<strong>在前台每隔一定时间去获取当前应用内存占最大内存的比例，当超过设定阈值时则主动释放应用 cache</strong>。</li>
<li>6）、<strong>当 UI 隐藏时释放内存以增加系统缓存应用进程的能力</strong>。</li>
<li>7）、<strong>高效实现了应用全局内的 Bitmap 监控</strong>。</li>
<li>8）、<strong>实现了全局的线程监控</strong>。</li>
<li>9）、<strong>针对内存使用的重度场景实现了 GC 监控</strong>。</li>
<li>10）、<strong>实现了线下的 native 内存泄漏监控</strong>。</li>
</ul>
<p>最后，当监控到 <strong>应用内存超过阈值时</strong>，还定制了 <strong>完善的兜底策略</strong> 来 <strong>重启应用进程</strong>。</p>
<p>总的来看，要建立一套 <strong>全面且成体系的内存优化及监控</strong> 是非常重要也是极具挑战性的一项工作。并且，目前各大公司的 <strong>内存优化体系</strong> 也正处于 <strong>不断演进的历程</strong> 之中，其目的不外乎：<strong>实现更健全的功能、更深层次的定位问题、快速准确地发现线上问题</strong>。</p>
<!-- flag of hidden posts -->
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt=" WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/private/" rel="tag"># private</a>
          
            <a href="/tags/%E5%AE%89%E5%8D%93%E4%BC%98%E5%8C%96/" rel="tag"># 安卓优化</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:shenbh@189.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/ptwenzi?spm=1010.2135.3001.5113" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-clone"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/shenbh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://gitee.com/shen_bh" target="_blank" title="Gitee">
                      
                        <i class="fa fa-fw fa-git"></i>Gitee</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2-Android-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-text">深入探索 Android 内存优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%87%8D%E8%AF%86%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-text">一、重识内存优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%89%8B%E6%9C%BARAM"><span class="nav-text">1、手机RAM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%98%AF%E5%90%A6%E8%B6%8A%E5%B0%91%E8%B6%8A%E5%A5%BD%EF%BC%9F"><span class="nav-text">那么内存占用是否越少越好？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E7%9A%84%E7%BA%AC%E5%BA%A6"><span class="nav-text">2、内存优化的纬度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81RAM%E4%BC%98%E5%8C%96"><span class="nav-text">1、RAM优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81ROM%E4%BC%98%E5%8C%96"><span class="nav-text">2、ROM优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-text">3、内存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8"><span class="nav-text">1、内存抖动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">2、内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">3、内存溢出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9"><span class="nav-text">二、常见工具选择</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Memory-Profiler"><span class="nav-text">1、Memory Profiler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Memory-Analyzer"><span class="nav-text">2、Memory Analyzer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81LeakCanary"><span class="nav-text">3、LeakCanary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E5%9B%9E%E9%A1%BE"><span class="nav-text">三、Android内存管理机制回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Java-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">1、Java 内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Java-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-text">2、Java 内存回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-text">1、标记-清除算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-text">2、复制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-2"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-text">3、标记-整理算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-3"><span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text">4、分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Android-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">3、Android 内存管理机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-text">4、小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8"><span class="nav-text">四、内存抖动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E9%82%A3%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E4%BC%9A%E5%AF%BC%E8%87%B4-OOM%EF%BC%9F"><span class="nav-text">1、那么，为什么内存抖动会导致 OOM？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E8%A7%A3%E5%86%B3%E5%AE%9E%E6%88%98"><span class="nav-text">2、内存抖动解决实战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B"><span class="nav-text">3、内存抖动常见案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%8F%B7%E6%8B%BC%E6%8E%A5"><span class="nav-text">1、字符串使用加号拼接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%B5%84%E6%BA%90%E5%A4%8D%E7%94%A8"><span class="nav-text">2、资源复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%87%8F%E5%B0%91%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="nav-text">3、减少不合理的对象创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E5%90%88%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">4、使用合理的数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%BD%93%E7%B3%BB%E5%8C%96%E6%90%AD%E5%BB%BA"><span class="nav-text">五、内存优化体系化搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81MAT%E5%9B%9E%E9%A1%BE"><span class="nav-text">1、MAT回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MAT%E6%9F%A5%E6%89%BE%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">MAT查找内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MAT%E7%9A%84%E5%85%B3%E9%94%AE%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="nav-text">MAT的关键使用细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MAT-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6%E5%9B%9E%E9%A1%BE"><span class="nav-text">MAT 关键组件回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Dominator%EF%BC%88%E6%94%AF%E9%85%8D%E8%80%85%EF%BC%89%EF%BC%9A"><span class="nav-text">1、Dominator（支配者）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Histogram%E5%92%8Cdominator-tree%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-text">2、Histogram和dominator_tree的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81thread-overview"><span class="nav-text">3、thread_overview</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Top-Consumers"><span class="nav-text">4、Top Consumers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Leak-Suspects"><span class="nav-text">5、Leak Suspects</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%90%AD%E5%BB%BA%E4%BD%93%E7%B3%BB%E5%8C%96%E7%9A%84%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96-x2F-%E7%9B%91%E6%8E%A7%E6%9C%BA%E5%88%B6"><span class="nav-text">2、搭建体系化的图片优化 &#x2F; 监控机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-Bitmap-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-text">Android Bitmap 内存分配的变化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Android-3-0%E4%B9%8B%E5%89%8D"><span class="nav-text">在Android 3.0之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android-3-0-Android-7-0"><span class="nav-text">Android 3.0 ~ Android 7.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android-8-0%E5%8F%8A%E4%BB%A5%E5%90%8E"><span class="nav-text">Android 8.0及以后</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%EF%BC%8C%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E5%B0%86%E5%9B%BE%E7%89%87%E5%86%85%E5%AD%98%E5%AD%98%E6%94%BE%E5%9C%A8-Native-%E4%B8%AD%E5%91%A2%EF%BC%9F"><span class="nav-text">那么，我们如何将图片内存存放在 Native 中呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%BB%9F%E4%B8%80%E5%9B%BE%E7%89%87%E5%BA%93"><span class="nav-text">1、统一图片库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%AE%BE%E5%A4%87%E5%88%86%E7%BA%A7%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-text">2、设备分级优化策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%BB%BA%E7%AB%8B%E7%BB%9F%E4%B8%80%E7%9A%84%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6"><span class="nav-text">3、建立统一的缓存管理组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BD%8E%E7%AB%AF%E6%9C%BA%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-text">4、低端机避免使用多进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E7%BA%BF%E4%B8%8B%E5%A4%A7%E5%9B%BE%E7%89%87%E6%A3%80%E6%B5%8B"><span class="nav-text">5、线下大图片检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">常规实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARTHook%E4%BC%98%E9%9B%85%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%9B%BE"><span class="nav-text">ARTHook优雅检测大图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-text">使用步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="nav-text">项目实战</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARTHook%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93"><span class="nav-text">ARTHook方案实现小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E7%BA%BF%E4%B8%8B%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87%E6%A3%80%E6%B5%8B"><span class="nav-text">6、线下重复图片检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-text">使用说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-text">实现步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E5%BB%BA%E7%AB%8B%E5%85%A8%E5%B1%80%E7%9A%84%E7%BA%BF%E4%B8%8A-Bitmap-%E7%9B%91%E6%8E%A7"><span class="nav-text">7、建立全局的线上 Bitmap 监控</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%BB%BA%E7%AB%8B%E7%BA%BF%E4%B8%8A%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB"><span class="nav-text">3、建立线上应用内存监控体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%B8%B8%E8%A7%84%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7"><span class="nav-text">1、常规内存监控</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%97%A9%E6%9C%9F%EF%BC%9A%E9%92%88%E5%AF%B9%E5%9C%BA%E6%99%AF%E8%BF%9B%E8%A1%8C%E7%BA%BF%E4%B8%8A-Dump-%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">项目早期：针对场景进行线上 Dump 内存的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%AE%E5%A4%A7%E6%9C%9F%EF%BC%9ALeakCanary%E5%B8%A6%E5%88%B0%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">壮大期：LeakCanary带到线上的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E7%86%9F%E6%9C%9F%EF%BC%9A%E5%AE%9A%E5%88%B6-LeakCanary-%E6%96%B9%E5%BC%8F"><span class="nav-text">成熟期：定制 LeakCanary 方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E5%88%B6%E7%BA%BF%E4%B8%8A%E7%9A%84LeakCanary%EF%BC%9F"><span class="nav-text">那么，如何定制线上的LeakCanary？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AF%BC%E5%87%BA%E5%A0%86%E6%A0%88%E6%96%87%E4%BB%B6"><span class="nav-text">1、导出堆栈文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%A0%B9%E6%8D%AE%E5%A0%86%E6%A0%88%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%87%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">2、根据堆栈文件创建出内存映射文件缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E7%BC%93%E5%AD%98%E5%8C%BA%E5%88%9B%E5%BB%BA%E5%87%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BF%AB%E7%85%A7"><span class="nav-text">3、根据文件缓存区创建出对应的快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E4%BB%8E%E5%BF%AB%E7%85%A7%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB"><span class="nav-text">4、从快照中获取指定的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E7%86%9F%E6%9C%9F%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9B%91%E6%8E%A7%E9%97%AD%E7%8E%AF"><span class="nav-text">成熟期：实现内存泄漏监控闭环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BD%8E%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7"><span class="nav-text">2、低内存监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="nav-text">3、内存监控指标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E3%80%81%E5%8F%91%E7%94%9F%E9%A2%91%E7%8E%87"><span class="nav-text">1）、发生频率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E3%80%81%E5%8F%91%E7%94%9F%E6%97%B6%E5%90%84%E9%A1%B9%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8A%B6%E5%86%B5"><span class="nav-text">2）、发生时各项内存使用状况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E3%80%81%E5%8F%91%E7%94%9F%E6%97%B6App%E7%9A%84%E5%BD%93%E5%89%8D%E5%9C%BA%E6%99%AF"><span class="nav-text">3）、发生时App的当前场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E3%80%81%E5%86%85%E5%AD%98%E5%BC%82%E5%B8%B8%E7%8E%87"><span class="nav-text">4）、内存异常率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%EF%BC%89%E3%80%81%E8%A7%A6%E9%A1%B6%E7%8E%87"><span class="nav-text">5）、触顶率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%B0%8F%E7%BB%93-1"><span class="nav-text">4、小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%BB%BA%E7%AB%8B%E5%85%A8%E5%B1%80%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="nav-text">4、建立全局的线程监控组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">全局线程监控组件的实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81GC-%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA"><span class="nav-text">5、GC 监控组件搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%BB%BA%E7%AB%8B%E7%BA%BF%E4%B8%8A-OOM-%E7%9B%91%E6%8E%A7%E7%BB%84%E4%BB%B6%EF%BC%9AProbe"><span class="nav-text">6、建立线上 OOM 监控组件：Probe</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Probe-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%BC%BA%E9%99%B7%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">Probe 组件的缺陷及解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%93%BE%E8%B7%AF%E5%88%86%E6%9E%90%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF"><span class="nav-text">1、链路分析时间过长</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%88%86%E6%9E%90%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E8%BF%87%E5%A4%A7"><span class="nav-text">2、分析进程占用内存过大</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prope-%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E6%8F%AD%E7%A7%98"><span class="nav-text">Prope 分析流程揭秘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81hprof-%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98-x3D-gt-%E8%A7%A3%E6%9E%90%E6%88%90-Snapshot-amp-%E8%AE%A1%E6%95%B0%E5%8E%8B%E7%BC%A9%EF%BC%9A"><span class="nav-text">1、hprof 映射到内存 &#x3D;&gt; 解析成 Snapshot &amp; 计数压缩：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%94%9F%E6%88%90-Dominator-Tree%E3%80%82"><span class="nav-text">2、生成 Dominator Tree。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%AE%A1%E7%AE%97-RetainSize%E3%80%82"><span class="nav-text">3、计算 RetainSize。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%94%9F%E6%88%90-Reference-%E9%93%BE-amp-amp-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A2%9E%E5%BC%BA"><span class="nav-text">4、生成 Reference 链 &amp;&amp; 基础数据类型增强:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E9%93%BE%E8%B7%AF%E5%BD%92%E5%B9%B6%E3%80%82"><span class="nav-text">5、链路归并。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E8%AE%A1%E6%95%B0%E6%A1%B6%E8%A1%A5%E5%81%BF-amp-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%88%B6%E8%8A%82%E7%82%B9%E8%9E%8D%E5%90%88%EF%BC%9A"><span class="nav-text">6、计数桶补偿 &amp; 基础数据类型和父节点融合：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81%E6%8E%92%E5%BA%8F%E6%89%A9%E5%AE%B9%E3%80%82"><span class="nav-text">7、排序扩容。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8%E3%80%81%E6%9F%A5%E6%89%BE%E6%B3%84%E9%9C%B2%E9%93%BE%E8%B7%AF%E3%80%82"><span class="nav-text">8、查找泄露链路。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E7%89%88-%E7%9A%84-Profile-Memory-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="nav-text">7、实现 单机版 的 Profile Memory 自动化内存分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4-1"><span class="nav-text">使用步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%A6%96%E5%85%88%EF%BC%8C%E7%82%B9%E5%87%BB-%E2%80%9D%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E2%80%9C-%E6%8C%89%E9%92%AE%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%A7%A6%E5%8F%91%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E8%AE%B0%E5%BD%95%EF%BC%8C%E8%AF%B4%E6%98%8E%E5%AF%B9%E8%B1%A1%E5%B7%B2%E7%BB%8F%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%EF%BC%8Clog%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A"><span class="nav-text">1、首先，点击 ”开始记录“ 按钮可以看到触发对象分配的记录，说明对象已经开始记录对象的分配，log如下所示：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%84%B6%E5%90%8E%EF%BC%8C%E7%82%B9%E5%87%BB%E5%A4%9A%E6%AC%A1-%E2%80%9D%E7%94%9F%E6%88%901000%E4%B8%AA%E5%AF%B9%E8%B1%A1%E2%80%9C-%E6%8C%89%E9%92%AE%EF%BC%8C%E5%BD%93%E5%AF%B9%E8%B1%A1%E8%BE%BE%E5%88%B0%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%E7%9A%84%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%E5%86%85%E5%AD%98dump%EF%BC%8C%E4%BC%9A%E5%BE%97%E5%88%B0%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E6%97%A5%E5%BF%97%E3%80%82%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A"><span class="nav-text">2、然后，点击多次 ”生成1000个对象“ 按钮，当对象达到设置的最大数量的时候触发内存dump，会得到保存数据路径的日志。如下所示：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%AD%A4%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%9C%A8-sdk-%E4%B8%8B%E7%9A%84-crashDump-%E7%9B%AE%E5%BD%95%E4%B8%8B%E3%80%82"><span class="nav-text">3、此时，可以看到数据保存在 sdk 下的 crashDump 目录下。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%8E%A5%E7%9D%80%EF%BC%8C%E9%80%9A%E8%BF%87-gradle-task-buildAlloctracker-%E4%BB%BB%E5%8A%A1%E7%BC%96%E8%AF%91%E5%87%BA%E5%AD%98%E6%94%BE%E5%9C%A8-tools-x2F-DumpPrinter-1-0-jar-%E7%9A%84-dump-%E5%B7%A5%E5%85%B7%EF%BC%8C%E7%84%B6%E5%90%8E%E9%87%87%E7%94%A8%E5%A6%82%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%9D%A5%E5%B0%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90-%E5%88%B0dump-log-txt-%E6%96%87%E4%BB%B6%E4%B8%AD%E3%80%82"><span class="nav-text">4、接着，通过 gradle task :buildAlloctracker 任务编译出存放在 tools&#x2F;DumpPrinter-1.0.jar 的 dump 工具，然后采用如下命令来将数据解析 到dump_log.txt 文件中。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E6%9C%80%E5%90%8E%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8-dump-log-txt-%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9C%8B%E5%88%B0%E8%A7%A3%E6%9E%90%E5%87%BA%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%EF%BC%9A"><span class="nav-text">5、最后，就可以在 dump_log.txt 文件中看到解析出来的数据，如下所示：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E6%90%AD%E5%BB%BA%E7%BA%BF%E4%B8%8B-Native-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB"><span class="nav-text">8、搭建线下 Native 内存泄漏监控体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E6%97%A0%E6%B3%95%E9%87%8D%E7%BC%96so%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">针对无法重编so的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E5%8F%AF%E9%87%8D%E7%BC%96%E7%9A%84so%E6%83%85%E5%86%B5"><span class="nav-text">针对可重编的so情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E8%AE%BE%E7%BD%AE%E5%86%85%E5%AD%98%E5%85%9C%E5%BA%95%E7%AD%96%E7%95%A5"><span class="nav-text">9、设置内存兜底策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-text">10、更深入的内存优化策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF-bitmap-%E8%B5%84%E6%BA%90%E5%9C%A8-native-%E4%B8%AD%E5%88%86%E9%85%8D"><span class="nav-text">1、使 bitmap 资源在 native 中分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E9%99%8D%E7%BA%A7%E5%A4%84%E7%90%86"><span class="nav-text">2、图片加载时的降级处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%89%8D%E5%8F%B0%E6%AF%8F%E9%9A%94-3-%E5%88%86%E9%92%9F%E5%8E%BB%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E5%8D%A0%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98%E7%9A%84%E6%AF%94%E4%BE%8B%EF%BC%8C%E8%B6%85%E8%BF%87%E8%AE%BE%E5%AE%9A%E7%9A%84%E5%8D%B1%E9%99%A9%E9%98%88%E5%80%BC%EF%BC%88%E5%A6%8280-%EF%BC%89%E5%88%99%E4%B8%BB%E5%8A%A8%E9%87%8A%E6%94%BE%E5%BA%94%E7%94%A8-cache%EF%BC%88Bitmap-%E4%B8%BA%E5%A4%A7%E5%A4%B4%EF%BC%89%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%BE%E7%A4%BA%E5%9C%B0%E9%99%A4%E5%8E%BB%E5%BA%94%E7%94%A8%E7%9A%84-memory%EF%BC%8C%E4%BB%A5%E5%8A%A0%E9%80%9F%E5%86%85%E5%AD%98%E6%94%B6%E9%9B%86%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82"><span class="nav-text">3、前台每隔 3 分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80%）则主动释放应用 cache（Bitmap 为大头），并且显示地除去应用的 memory，以加速内存收集的过程。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%94%B1%E4%BA%8E-webview-%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E6%B3%84%E6%BC%8F%EF%BC%8C%E8%BF%98%E6%9C%89-%E5%9B%BE%E5%BA%93%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E8%BF%87%E5%A4%9A-%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%E5%8D%95%E7%8B%AC%E7%9A%84%E8%BF%9B%E7%A8%8B%E3%80%82"><span class="nav-text">4、由于 webview 存在内存系统泄漏，还有 图库占用内存过多 的问题，可以采用单独的进程。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%BD%93UI%E9%9A%90%E8%97%8F%E6%97%B6%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="nav-text">5、当UI隐藏时释放内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81Activity-%E7%9A%84%E5%85%9C%E5%BA%95%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-text">6、Activity 的兜底内存回收策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E4%BD%BF%E7%94%A8%E7%B1%BB%E4%BC%BC-Hack-%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BF%AE%E5%A4%8D%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text">7、使用类似 Hack 的方式修复系统内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E5%BD%93%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8%E7%9A%84Service%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8%E6%97%B6%E5%BA%94%E8%AF%A5%E9%94%80%E6%AF%81%E5%AE%83%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8-IntentServcie%E3%80%82"><span class="nav-text">8、当应用使用的Service不再使用时应该销毁它，建议使用 IntentServcie。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%EF%BC%8C%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BA%86%E4%BD%BF%E7%94%A8%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%A4%E4%B8%AA%E5%8A%9F%E8%83%BD%E8%80%8C%E5%AF%BC%E5%85%A5%E4%B8%80%E4%B8%AA%E5%A4%A7%E8%80%8C%E5%85%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82"><span class="nav-text">9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%BC%94%E8%BF%9B"><span class="nav-text">六、内存优化演进</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5"><span class="nav-text">1、自动化测试阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81LeakCanary"><span class="nav-text">2、LeakCanary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E-LeakCannary-%E7%9A%84%E6%94%B9%E8%BF%9B%E7%89%88-ResourceCanary"><span class="nav-text">3、使用基于 LeakCannary 的改进版 ResourceCanary</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-text">主要功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%88%86%E7%A6%BB-%E6%A3%80%E6%B5%8B%E5%92%8C%E5%88%86%E6%9E%90-%E4%B8%A4%E9%83%A8%E5%88%86%E6%B5%81%E7%A8%8B"><span class="nav-text">1、分离 检测和分析 两部分流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%A3%81%E5%89%AA-Hprof%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BB%A5%E9%99%8D%E4%BD%8E-%E4%BC%A0%E8%BE%93-Hprof-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%90%8E%E5%8F%B0%E5%AD%98%E5%82%A8-Hprof-%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%80%E9%94%80"><span class="nav-text">2、裁剪 Hprof文件，以降低 传输 Hprof 文件与后台存储 Hprof 文件的开销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%A2%9E%E5%8A%A0%E9%87%8D%E5%A4%8D-Bitmap-%E5%AF%B9%E8%B1%A1%E6%A3%80%E6%B5%8B"><span class="nav-text">3、增加重复 Bitmap 对象检测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%B0%8F%E7%BB%93-2"><span class="nav-text">4、小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="nav-text">七、内存优化工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81top"><span class="nav-text">1、top</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E5%8C%BA"><span class="nav-text">整体的统计信息区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%A1%8C%EF%BC%9ATasks-%E2%80%94-%E4%BB%BB%E5%8A%A1%EF%BC%88%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="nav-text">第一行：Tasks — 任务（进程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%A1%8C%EF%BC%9A%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81"><span class="nav-text">第二行：内存状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%A1%8C%EF%BC%9Aswap%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA%E4%BF%A1%E6%81%AF"><span class="nav-text">第三行：swap交换分区信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%A1%8C%EF%BC%9Acpu%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF"><span class="nav-text">第四行：cpu状态信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BB%BB%E5%8A%A1%EF%BC%89%E7%9A%84%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="nav-text">进程（任务）的状态监控</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81dumpsys-meminfo"><span class="nav-text">2、dumpsys meminfo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E5%86%85%E5%AD%98%E6%8C%87%E6%A0%87"><span class="nav-text">四大内存指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dumpsys-meminfo-%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90"><span class="nav-text">dumpsys meminfo 命令解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8B-Native-Heap-%E7%9A%84-Heap-Alloc-%E4%B8%8E-Dalvik-Heap-%E7%9A%84-Heap-Alloc"><span class="nav-text">1、查看 Native Heap 的 Heap Alloc 与 Dalvik Heap 的 Heap Alloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%9F%A5%E7%9C%8B-Views%E3%80%81Activities%E3%80%81AppContexts-%E6%95%B0%E9%87%8F%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5"><span class="nav-text">2、查看 Views、Activities、AppContexts 数量变化情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81SQL-%E7%9A%84-MEMORY-USED-%E4%B8%8E-PAGECACHE-OVERFLOW"><span class="nav-text">3、SQL 的 MEMORY_USED 与 PAGECACHE_OVERFLOW</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%9F%A5%E7%9C%8B-DATABASES-%E4%BF%A1%E6%81%AF"><span class="nav-text">4、查看 DATABASES 信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81LeakInspector"><span class="nav-text">3、LeakInspector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%EF%BC%8CLeakInspector-%E4%B8%8E-LeakCanary-%E5%8F%88%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%E5%91%A2%EF%BC%9F"><span class="nav-text">那么，LeakInspector 与 LeakCanary 又有什么不同之处呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A3%80%E6%B5%8B%E8%83%BD%E5%8A%9B%E4%B8%8E%E5%8E%9F%E7%90%86%E6%96%B9%E9%9D%A2%E4%B8%8D%E5%90%8C"><span class="nav-text">一、检测能力与原理方面不同</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%A3%80%E6%B5%8B%E8%83%BD%E5%8A%9B"><span class="nav-text">1、检测能力</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86"><span class="nav-text">2、检测原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%B3%84%E6%BC%8F%E7%8E%B0%E5%9C%BA%E5%A4%84%E7%90%86%E6%96%B9%E9%9D%A2%E4%B8%8D%E5%90%8C"><span class="nav-text">二、泄漏现场处理方面不同</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81dump-%E9%87%87%E9%9B%86"><span class="nav-text">1、dump 采集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E7%99%BD%E5%90%8D%E5%8D%95%E5%AE%9A%E4%B9%89"><span class="nav-text">2、白名单定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8D%E7%B3%BB%E7%BB%9F%E6%B3%84%E6%BC%8F"><span class="nav-text">3、自动修复系统泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E5%9B%9E%E6%94%B6%E8%B5%84%E6%BA%90%EF%BC%88Activity%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%85%9C%E5%BA%95%E5%A4%84%E7%90%86%EF%BC%89"><span class="nav-text">4、回收资源（Activity内存泄漏兜底处理）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C"><span class="nav-text">三、后期处理不同</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA"><span class="nav-text">1、分析与展示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%90%8E%E7%BB%AD%E8%B7%9F%E8%BF%9B%E9%97%AD%E7%8E%AF"><span class="nav-text">2、后续跟进闭环</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%85%8D%E5%90%88%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E9%9D%A2%E4%B8%8D%E5%90%8C"><span class="nav-text">四、配合自动化测试方面不同</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81JHat"><span class="nav-text">4、JHat</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%BB%9F%E8%AE%A1%E8%A1%A8"><span class="nav-text">1、统计表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81OQL-%E6%9F%A5%E8%AF%A2"><span class="nav-text">2、OQL 查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81ART-GC-Log"><span class="nav-text">5、ART GC Log</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">GC 产生的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E7%B1%BB%E5%9E%8B"><span class="nav-text">GC 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E9%87%87%E9%9B%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">GC采集的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81Chrome-Devtool"><span class="nav-text">6、Chrome Devtool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AFH5"><span class="nav-text">纯H5</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85-Chrome%EF%BC%8C%E6%89%93%E5%BC%80-USB-%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%80%9A%E8%BF%87-USB-%E8%BF%9E%E4%B8%8A%E7%94%B5%E8%84%91%EF%BC%8C%E5%9C%A8-Chrome-%E9%87%8C%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%AF%94%E5%A6%82%E7%99%BE%E5%BA%A6%E9%A1%B5%E9%9D%A2%E3%80%82%E7%84%B6%E5%90%8E%E5%9C%A8-PC-Chrome-%E5%9C%B0%E5%9D%80%E6%A0%8F%E9%87%8C%E8%AE%BF%E9%97%AE-Chrome-x2F-x2F-inspect%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A"><span class="nav-text">1、手机安装 Chrome，打开 USB 调试模式，通过 USB 连上电脑，在 Chrome 里打开一个页面，比如百度页面。然后在 PC Chrome 地址栏里访问 Chrome:&#x2F;&#x2F;inspect，如下图所示：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%9C%80%E5%90%8E%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%82%B9%E5%87%BB-Chrome-%E4%B8%8B%E9%9D%A2%E7%9A%84-inspect-%E9%80%89%E9%A1%B9%E5%8D%B3%E5%8F%AF%E5%BC%B9%E5%87%BA%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E7%95%8C%E9%9D%A2%E3%80%82%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A"><span class="nav-text">2、最后，直接点击 Chrome 下面的 inspect 选项即可弹出开发者工具界面。如下图所示：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4-Hybrid-H5-%E8%B0%83%E8%AF%95"><span class="nav-text">默认 Hybrid H5 调试</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="nav-text">八、内存问题总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E7%B1%BB%E6%98%AF%E6%9C%89%E5%8D%B1%E9%99%A9%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="nav-text">1、内类是有危险的编码方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%99%AE%E9%80%9A-Hanlder-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">2、普通 Hanlder 内部类的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-text">3、登录界面的内存问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BA%A7%E7%94%9F%E7%9A%84%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-text">4、使用系统服务时产生的内存问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E6%8A%8A-WebView-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%84%E6%BC%8F%E8%A3%85%E8%BF%9B%E5%9E%83%E5%9C%BE%E6%A1%B6%E8%BF%9B%E7%A8%8B"><span class="nav-text">5、把 WebView 类型的泄漏装进垃圾桶进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%9C%A8%E9%80%82%E5%BD%93%E7%9A%84%E6%97%B6%E5%80%99%E5%AF%B9%E7%BB%84%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%B3%A8%E9%94%80"><span class="nav-text">6、在适当的时候对组件进行注销</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81Handler-x2F-FrameLayout-%E7%9A%84-postDelyed-%E6%96%B9%E6%B3%95%E8%A7%A6%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-text">7、Handler &#x2F; FrameLayout 的 postDelyed 方法触发的内存问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E5%9B%BE%E7%89%87%E6%94%BE%E9%94%99%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95%E4%B9%9F%E4%BC%9A%E6%9C%89%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-text">8、图片放错资源目录也会有内存问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E5%88%97%E8%A1%A8-item-%E8%A2%AB%E5%9B%9E%E6%94%B6%E6%97%B6%E6%B3%A8%E6%84%8F%E9%87%8A%E6%94%BE%E5%9B%BE%E7%89%87%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-text">9、列表 item 被回收时注意释放图片的引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E4%BD%BF%E7%94%A8-ViewStub-%E8%BF%9B%E8%A1%8C%E5%8D%A0%E4%BD%8D"><span class="nav-text">10、使用 ViewStub 进行占位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81%E6%B3%A8%E6%84%8F%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86-App-%E8%BF%87%E6%97%B6%E7%9A%84%E5%9F%8B%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="nav-text">11、注意定时清理 App 过时的埋点数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81%E9%92%88%E5%AF%B9%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-Runnable-%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">12、针对匿名内部类 Runnable 造成内存泄漏的处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text">九、内存优化常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BD%A0%E4%BB%AC%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="nav-text">1、你们内存优化项目的过程是怎么做的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%88%86%E6%9E%90%E7%8E%B0%E7%8A%B6%E3%80%81%E7%A1%AE%E8%AE%A4%E9%97%AE%E9%A2%98"><span class="nav-text">1、分析现状、确认问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%92%88%E5%AF%B9%E6%80%A7%E4%BC%98%E5%8C%96"><span class="nav-text">2、针对性优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87"><span class="nav-text">3、效率提升</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%BD%A0%E5%81%9A%E4%BA%86%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%9C%80%E5%A4%A7%E7%9A%84%E6%84%9F%E5%8F%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">2、你做了内存优化最大的感受是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5"><span class="nav-text">1、磨刀不误砍柴工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E5%BF%85%E9%A1%BB%E7%BB%93%E5%90%88%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81"><span class="nav-text">2、技术优化必须结合业务代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AE%8C%E5%96%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">3、系统化完善解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%89%80%E6%9C%89%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="nav-text">3、如何检测所有不合理的地方？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-text">十、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BC%98%E5%8C%96%E5%A4%A7%E6%96%B9%E5%90%91"><span class="nav-text">1、优化大方向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82"><span class="nav-text">2、优化细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%BD%93%E7%B3%BB%E5%8C%96%E5%BB%BA%E8%AE%BE%E6%80%BB%E7%BB%93"><span class="nav-text">3、内存优化体系化建设总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿炳</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('Copied')
          else $(this).text('Copy failed')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>