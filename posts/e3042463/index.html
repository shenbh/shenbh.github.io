<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="private,网络," />










<meta name="description" content="OSI、TCP&#x2F;IP 学习计算机网络时我们一半采用折中的办法，也就是中和OSI核TCP&#x2F;IP的优点，采用一种只有五层协议的体系结构。 应用层应⽤层(application-layer）的任务是通过应⽤进程间的交互来完成特定⽹络应⽤。应⽤层协议定义的是应⽤进程（进程：主机中正在运⾏的程序）间的通信和交互的规则。对于不同的⽹络应⽤需要不同的应⽤层协议。在互联⽹中应⽤层协议很多，如域">
<meta property="og:type" content="article">
<meta property="og:title" content="题目-网络相关">
<meta property="og:url" content="http://shenbh.github.io/posts/e3042463/index.html">
<meta property="og:site_name" content="积跬步">
<meta property="og:description" content="OSI、TCP&#x2F;IP 学习计算机网络时我们一半采用折中的办法，也就是中和OSI核TCP&#x2F;IP的优点，采用一种只有五层协议的体系结构。 应用层应⽤层(application-layer）的任务是通过应⽤进程间的交互来完成特定⽹络应⽤。应⽤层协议定义的是应⽤进程（进程：主机中正在运⾏的程序）间的通信和交互的规则。对于不同的⽹络应⽤需要不同的应⽤层协议。在互联⽹中应⽤层协议很多，如域">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/image-20231227165332748.png">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3.gif">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/Http%E4%B8%8EHttps%E7%9A%84%E5%8C%BA%E5%88%AB.png">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/SPDY%E6%9E%84%E6%88%90%E5%9B%BE.png">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/Request%E7%BB%84%E6%88%90.png">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/Response%E7%BB%84%E6%88%90.png">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="http://shenbh.github.io/posts/e3042463/IP%E6%8A%A5%E6%96%87%E5%86%85%E5%AE%B9.png">
<meta property="article:published_time" content="2022-02-22T08:32:19.000Z">
<meta property="article:modified_time" content="2025-05-15T01:02:34.548Z">
<meta property="article:author" content="阿炳">
<meta property="article:tag" content="private">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://shenbh.github.io/posts/e3042463/image-20231227165332748.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://shenbh.github.io/posts/e3042463/"/>





  <title>题目-网络相关 | 积跬步</title><meta name="robots" content="noindex">
  








<meta name="generator" content="Hexo 6.1.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">积跬步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Just do IT Now.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shenbh.github.io/posts/e3042463/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积跬步">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">题目-网络相关</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-22T16:32:19+08:00">
                2022-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="OSI、TCP-x2F-IP"><a href="#OSI、TCP-x2F-IP" class="headerlink" title="OSI、TCP&#x2F;IP"></a>OSI、TCP&#x2F;IP</h1><p><img src="/posts/e3042463/image-20231227165332748.png" alt="image-20231227165332748"></p>
<p>学习计算机网络时我们一半采用折中的办法，也就是中和OSI核TCP&#x2F;IP的优点，采用一种只有五层协议的体系结构。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应⽤层(application-layer）的任务是通过应⽤进程间的交互来完成特定⽹络应⽤。</strong>应⽤层协议定义的是应⽤进程（进程：主机中正在运⾏的程序）间的通信和交互的规则。对于不同的⽹络应⽤需要不同的应⽤层协议。在互联⽹中应⽤层协议很多，如<strong>域名系统DNS</strong>，⽀持万维⽹应⽤的 <strong>HTTP协议</strong>，⽀持电⼦邮件的 <strong>SMTP协议</strong>等等。我们把应⽤层交互的数据单元称为报⽂。</p>
<p><strong>域名系统</strong></p>
<blockquote>
<p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特⽹的⼀项核⼼服务，它作为可以将域名和IP地址相互映射的⼀个分布式数据库，能够使⼈更⽅便的访问互联⽹，⽽不⽤去记住能够被机器直接读取的IP数串。（百度百科）例如：⼀个公司的 Web ⽹站可看作是它在⽹上的⻔户，⽽域名就相当于其⻔牌地址，通常域名都使⽤该公司的名称或简称。例如上⾯提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a target="_blank" rel="noopener" href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a target="_blank" rel="noopener" href="http://www.oracle.com、cisco公司的域名是/">www.oracle.com、Cisco公司的域名是</a> <a target="_blank" rel="noopener" href="http://www.cisco.com/">www.cisco.com</a> 等。</p>
</blockquote>
<p><strong>HTTP协议</strong></p>
<blockquote>
<p>超⽂本传输协议（HTTP，HyperText Transfer Protocol)是互联⽹上应⽤最为⼴泛的⼀种⽹络协议。所有的 WWW（万维⽹） ⽂件都必须遵守这个标准。设计 HTTP 最初的⽬的是为了提供⼀种发布和接收 HTML ⻚⾯的⽅法。（百度百科）</p>
</blockquote>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通⽤的数据传输服务</strong>。</p>
<p>应⽤进程利⽤该服务传送应⽤层报⽂。“通⽤的”是指并不针对某⼀个特定的⽹络应⽤，⽽是多种应⽤可以使⽤同⼀个运输层服务。由于⼀台主机可同时运⾏多个线程，因此运输层有复⽤和分⽤的功能。所谓复⽤就是指多个应⽤层进程可同时使⽤下⾯运输层的服务，分⽤和复⽤相反，是运输层把收到的信息分别交付上⾯应⽤层中的相应进程。</p>
<p><strong>运输层主要使⽤以下两种协议:</strong></p>
<ol>
<li><p><strong>传输控制协议</strong> <strong>TCP</strong>（Transmission Control Protocol）–提供<strong>⾯向连接</strong>的，<strong>可靠的</strong>数据传输服务。</p>
</li>
<li><p><strong>⽤户数据协议</strong> <strong>UDP</strong>（User Datagram Protocol）–提供<strong>⽆连接</strong>的，尽最⼤努⼒的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</p>
</li>
</ol>
<h3 id="TCP-与-UDP-的对⽐⻅问题三。"><a href="#TCP-与-UDP-的对⽐⻅问题三。" class="headerlink" title="TCP 与 UDP 的对⽐⻅问题三。"></a>TCP 与 UDP 的对⽐⻅问题三。</h3><h2 id="⽹络层"><a href="#⽹络层" class="headerlink" title="⽹络层"></a>⽹络层</h2><p><strong>在 计算机⽹络中进⾏通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信⼦⽹。⽹络层的任务就是选择合适的⽹间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，⽹络层把运输层产⽣的报⽂段或⽤户数据报封装成分组和包进⾏传送。在 TCP&#x2F;IP 体系结构中，由于⽹络层使⽤ <strong>IP</strong> <strong>协议</strong>，因此分组也叫 <strong>IP</strong> <strong>数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p>这⾥要注意：<strong>不要把运输层的“⽤户数据报 UDP ”和⽹络层的“ IP 数据报”弄混</strong>。另外，⽆论是哪⼀层的数据单元，都可笼统地⽤“分组”来表示。</p>
<p>这⾥强调指出，⽹络层中的“⽹络”⼆字已经不是我们通常谈到的具体⽹络，⽽是指计算机⽹络体系结构模型中第三层的名称.</p>
<p>互联⽹是由⼤量的异构（heterogeneous）⽹络通过路由器（router）相互连接起来的。互联⽹使⽤的⽹络层协议是⽆连接的⽹际协议（Intert Protocol）和许多路由选择协议，因此互联⽹的⽹络层也叫做<strong>⽹际层</strong>或<strong>IP层</strong>。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在⼀段⼀段的链路上传送的，这就需要使⽤专⻔的链路层的协议</strong>。 在两个相邻节点之间传送数据时，<strong>数据链路层将⽹络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每⼀帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道⼀个帧从哪个⽐特开始和到哪个⽐特结束。这样，数据链路层在收到⼀个帧后，就可从中提出数据部分，上交给⽹络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在⽹络中传送下去⽩⽩浪费⽹络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，⽽且还要纠错），那么就要采⽤可靠性传输协议来纠正出现的差错。这种⽅法会使链路层的协议复杂些。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>在物理层上所传送的数据单位是⽐特。 <strong>物理层(physical layer)的作⽤是实现相邻计算机节点之间⽐特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上⾯的数据链路层不必考虑⽹络的具体传输介质是什么。“透明传送⽐特流”表示经实际电路传送后的⽐特流没有发⽣变化，对传送的⽐特流来说，这个电路好像是看不⻅的。</p>
<p>在互联⽹使⽤的各种协中最重要和最著名的就是 TCP&#x2F;IP 两个协议。现在⼈们经常提到的TCP&#x2F;IP并不⼀定单指TCP和IP这两个具体的协议，⽽往往表示互联⽹所使⽤的整个TCP&#x2F;IP协议族。</p>
<h2 id="总结⼀下"><a href="#总结⼀下" class="headerlink" title="总结⼀下"></a>总结⼀下</h2><p>上⾯我们对计算机⽹络的五层体系结构有了初步的了解，下⾯附送⼀张七层体系结构图总结⼀下。图⽚</p>
<p>来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yaopeng_2005/article/details/7064869">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a></p>
<p><img src="/posts/e3042463/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3.gif" alt="OSI七层模型详解"></p>
<h1 id="HTTP-x2F-HTTPS（⭐⭐⭐）"><a href="#HTTP-x2F-HTTPS（⭐⭐⭐）" class="headerlink" title="HTTP&#x2F;HTTPS（⭐⭐⭐）"></a><code>HTTP</code>&#x2F;<code>HTTPS</code>（⭐⭐⭐）</h1><h2 id="HTTP与HTTPS有什么区别"><a href="#HTTP与HTTPS有什么区别" class="headerlink" title="HTTP与HTTPS有什么区别"></a><code>HTTP</code>与<code>HTTPS</code>有什么区别</h2><p><code>HTTPS</code> 是一种通过计算机网络进行安全通信的<strong>传输协议</strong>。<code>HTTPS</code> 经由 <code>HTTP</code> 进行通信，但利用 <code>SSL/TLS</code> 来加密数据包。<code>HTTPS</code> 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 </p>
<h3 id="HTPPS-和-HTTP-的概念："><a href="#HTPPS-和-HTTP-的概念：" class="headerlink" title="HTPPS 和 HTTP 的概念："></a><code>HTPPS</code> 和 <code>HTTP</code> 的概念：</h3><ul>
<li><p><code>HTTPS</code>（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的 <code>HTTP</code> 通道，简单讲是 <code>HTTP</code> 的安全版。即 <code>HTTP</code> 下加入 <code>SSL</code> 层，<code>HTTPS</code> 的安全基础是 <code>SSL</code>， 因此加密的详细内容就需要 <code>SSL</code>。它是一个 &#96;&#96;URI scheme<code>（抽象标识符体系），句法类同 </code>http:<code>体系。用于安全的 </code>HTTP<code> 数据传输。</code>https:URL<code>表明它使用了</code>HTTP<code>，但 </code>HTTPS<code>存在不同于</code>HTTP<code>的默认端口及一个**加密/身份验证层**（在</code>HTTP<code>与</code>TCP&#96; 之间）。这个系统的最初研发由 网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 </p>
</li>
<li><p><code>HTTP</code>超文本传输协议 (Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 </p>
</li>
<li><p><code>Https</code> 协议需要到 <code>ca</code> 申请证书，一般免费证书很少，需要交费。<code>http</code> 是超文本传输协议，信息是明文传输，<code>https</code> 则是具有安全性的 <code>ssl</code> 加密传输协议 <code>http</code> 和 <code>https</code> 使用的是完全不同的连接方式用的端口也不一样,前者是 <code>80</code>,后者是 <code>443</code>。<code>http</code> 的连接很简单,是<strong>无状态</strong>的 </p>
</li>
<li><p><code>HTTPS</code> 协议是由 <code>SSL+HTTP</code> 协议构建的可进行加密传输、身份认证的网络协议 要比 <code>http</code> 协议安全</p>
</li>
<li><p><code>HTTPS</code> 解决的问题：</p>
<ol>
<li><p>信任主机的问题. 采用 <code>https</code> 的 <code>server</code> 必须从 <code>CA</code> 申请一个用于证明服务器用途类型的证书. 该证书只有用于对应的 <code>server</code> 的时候,客户端才信任此主机 </p>
</li>
<li><p>防止通讯过程中的数据的泄密和被窜改</p>
<p>如下图所示，可以很明显的看出两个的区别： </p>
<p><img src="/posts/e3042463/Http%E4%B8%8EHttps%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="网络/Http与Https的区别"></p>
<blockquote>
<p>注意：<code>TLS</code>是<code>SSL</code>的升级替代版，具体发展历史可以参考传输层安全性协议。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><code>HTTP</code> 与 <code>HTTPS</code> 在写法上的区别也是前缀的不同，客户端处理的方式也不同，具体说来：</p>
<p>如果 <code>URL</code> 的协议是 <code>HTTP</code>，则客户端会打开一条到服务端端口 <code>80</code>（默认）的连接，并向其发送老的 <code>HTTP</code> 请求。 如果 <code>URL</code> 的协议是 <code>HTTPS</code>，则客户端会打开一条到服务端端口 <code>443</code> （默认）的连接，然后与服务器握手，以<strong>二进制格式</strong>与服务器交换一些 <code>SSL</code> 的安全参数，附上加密的 <code>HTTP</code> 请求。 所以你可以看到，<code>HTTPS</code> 比 <code>HTTP</code> 多了一层与 <code>SSL</code> 的连接，这也就是客户端与服务端 <code>SSL</code> 握手的过程，整个过程主要完成以下工作： </p>
<ul>
<li><p>交换协议版本号 选择一个两端都了解的密码 对两端的身份进行认证，生成临时的会话密钥，以便加密信道。 <code>SSL</code> 握手是一个相对比较复杂的过程，更多关于 <code>SSL</code> 握手的过程细节可以参考 <code>TLS/SSL</code> 握手过程 </p>
</li>
<li><p><code>SSL/TSL</code> 的常见开源实现是 <code>OpenSSL</code>，<code>OpenSSL</code> 是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。 更多源于 <code>OpenSSL</code> 的技术细节可以参考 <code>OpenSSL</code>。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Http1-1-和-Http1-0-及-2-0-的区别？"><a href="#Http1-1-和-Http1-0-及-2-0-的区别？" class="headerlink" title="Http1.1 和 Http1.0 及 2.0 的区别？"></a><code>Http1.1</code> 和 <code>Http1.0</code> 及 2.0 的区别？</h2><h3 id="HTTP1-0-和-HTTP1-1-的一些区别"><a href="#HTTP1-0-和-HTTP1-1-的一些区别" class="headerlink" title="HTTP1.0 和 HTTP1.1 的一些区别"></a><code>HTTP1.0</code> 和 <code>HTTP1.1</code> 的一些区别</h3><p><code>HTTP1.0</code> 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 <code>HTTP1.1</code> 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时<code>HTTP1.1</code> 也是当前使用最为广泛的 <code>HTTP</code> 协议。 主要区别主要体现在： </p>
<ol>
<li><p><strong>缓存处理</strong>，在 <code>HTTP1.0</code> 中主要使用 <code>header</code> 里的 <code>If-Modified-Since</code>,<code>Expires</code> 来做为缓存判断的标准，<code>HTTP1.1</code> 则引入了更多的缓存控制策略例如 <code>Entity tag</code>， <code>If-Unmodified-Since</code>, <code>If-Match</code>, <code>If-None-Match</code> 等更多可供选择的缓存头来控制缓存策略。 </p>
</li>
<li><p>带宽优化及网络连接的使用，<code>HTTP1.0</code> 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持<strong>断点续传</strong>功能，<code>HTTP1.1</code> 则在请求头引入了 <code>range</code> 头域，它允许只请求资源的某个部分，即返回码是 <code>206（Partial Content）</code>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。 </p>
</li>
<li><p>错误通知的管理，在 <code>HTTP1.1</code> 中新增了 24 个错误状态响应码，如 <code>409（Conflict）</code>表示请求的资源与资源的当前状态发生冲突；<code>410（Gone）</code>表示服务器上的某个资源被永久性的删除。 </p>
</li>
<li><p><code>Host</code> 头处理，在 <code>HTTP1.0</code> 中认为每台服务器都绑定一个唯一的 <code>IP</code> 地址，因此，请求消息中的 <code>URL</code> 并没有传递主机名（<code>hostname</code>）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（<code>Multi-homed Web Servers</code>），并且它们共享一个 <code>IP</code> 地址。<code>HTTP1.1</code> 的请求消息和响应消息都应支持 <code>Host</code> 头域，且请求消息中如果没有 <strong><code>Host</code> 头域</strong>会报告一个错误（<code>400 Bad Request</code>）。 </p>
</li>
<li><p><strong>长连接</strong>，<code>HTTP 1.1</code> 支持长连接（<code>PersistentConnection</code>）和请求的流水线（<code>Pipelining</code>）处理，在一个 <code>TCP</code> 连接上可以传送多个 <code>HTTP</code> 请求和响应，减少了建立和关闭连接的消耗和延迟，在 <code>HTTP1.1</code> 中默认开启 <code>Connection： keep-alive</code>，一定程度上弥补了 <code>HTTP1.0</code> 每次请求都要创建连接的缺点。</p>
</li>
</ol>
<h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><p>在讲 <code>Http1.1</code> 和 <code>Http2.0</code> 的区别之前，还需要说下 <code>SPDY</code>，它是 <code>HTTP1.x</code> 的优化方案： </p>
<p>2012 年 google 如一声惊雷提出了 <code>SPDY</code> 的方案，<strong>优化了 <code>HTTP1.X</code> 的请求延迟，解决了<code>HTTP1.X</code> 的安全性</strong>，具体如下： </p>
<ol>
<li><p>降低延迟，针对<strong>HTTP高延迟</strong>的问题，<code>SPDY</code>优雅的采取了多路复用（<code>multiplexing</code>）。 多路复用通过多个请求 <code>stream</code> 共享一个 <code>tcp</code> 连接的方式，解决了 <code>HOL blocking</code> 的问题，降低了延迟同时提高了带宽的利用率。 </p>
</li>
<li><p>请求优先级（<code>request prioritization</code>）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。<code>SPDY</code> 允许给每个 <code>request</code> 设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 <code>html</code> 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 </p>
</li>
<li><p><code>header</code> 压缩。前面提到 <code>HTTP1.x</code> 的 <code>header</code> 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。 </p>
</li>
<li><p>基于 <code>HTTPS</code> 的加密协议传输，大大提高了传输数据的可靠性。 </p>
</li>
<li><p>服务端推送（<code>server push</code>），采用了 <code>SPDY</code> 的网页，例如我的网页有一个 <code>sytle.css</code> 的请求，在客户端收到 <code>sytle.css</code> 数据的同时，服务端会将 <code>sytle.js</code> 的文件推送给客户端，当客户端再次尝试获取 <code>sytle.js</code> 时就可以直接从缓存中获取到，不用再发请求了。</p>
</li>
</ol>
<p><code>SPDY</code> 构成图：<img src="/posts/e3042463/SPDY%E6%9E%84%E6%88%90%E5%9B%BE.png" alt="网络/SPDY构成图"></p>
<p><code>SPDY</code> 位于 <code>HTTP</code> 之下，<code>TCP</code> 和 <code>SSL</code> 之上，这样可以轻松兼容老版本的 <code>HTTP</code> 协议(将 <code>HTTP1.x</code> 的内容封装成一种新的 <code>frame</code> 格式)，同时可以使用已有的 <code>SSL</code> 功能。</p>
<h3 id="HTTP2-0-和-HTTP1-X-相比的新特性"><a href="#HTTP2-0-和-HTTP1-X-相比的新特性" class="headerlink" title="HTTP2.0 和 HTTP1.X 相比的新特性"></a><code>HTTP2.0</code> 和 <code>HTTP1.X</code> 相比的新特性</h3><ul>
<li><p>新的二进制格式（<code>Binary Format</code>），<code>HTTP1.x</code> 的解析是基于<strong>文本</strong>。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 <code>HTTP2.0</code> 的协议解析决定采用<strong>二进制格式</strong>，实现方便且健壮。 </p>
</li>
<li><p>多路复用（<code>MultiPlexing</code>），即连接共享，即每一个 <code>request</code> 都是是用作连接共享机制的。一个 <code>request</code> 对应一个 <code>id</code>，这样一个连接上可以有多个 <code>request</code>，每个连接的 <code>request</code> 可以随机的混杂在一起，接收方可以根据 <code>request</code> 的 <code>id</code> 将 <code>request</code> 再归属到各自不同的服务端请求里面。 </p>
</li>
<li><p><code>header</code> 压缩，如上文中所言，对前面提到过 <code>HTTP1.x</code> 的 <code>header</code> 带有大量信息，而且每次都要重复发送，<code>HTTP2.0</code> 使用 <code>encoder</code> 来减少需要传输的 <code>header</code> 大小，通讯双方各自 <code>cache</code> 一份 <code>header fields</code> 表，既避免了重复 <code>header</code> 的传输，又减小了需要传输的大小。 </p>
</li>
<li><p>服务端推送（<code>server push</code>），同 <code>SPDY</code> 一样，<code>HTTP2.0</code> 也具有 <code>server push</code> 功能。</p>
</li>
</ul>
<h2 id="Https-请求慢的解决办法"><a href="#Https-请求慢的解决办法" class="headerlink" title="Https 请求慢的解决办法"></a><code>Https</code> 请求慢的解决办法</h2><h3 id="不通过-DNS-解析，直接访问-IP"><a href="#不通过-DNS-解析，直接访问-IP" class="headerlink" title="不通过 DNS 解析，直接访问 IP"></a>不通过 <code>DNS</code> 解析，直接访问 <code>IP</code></h3><h3 id="解决连接无法复用"><a href="#解决连接无法复用" class="headerlink" title="解决连接无法复用"></a>解决连接无法复用</h3><p><code>http/1.0</code> 协议头里可以设置 <code>Connection:Keep-Alive</code> 或者 <code>Connection:Close</code>，选择是否允许在一定时间内复用连接（时间可由服务器控制）。但是这对 <code>App</code> 端的请求成效不大，因为 <code>App</code> 端的请求比较分散且时间跨度相对较大。 </p>
<ul>
<li><p>方案 1. 基于 <code>tcp 的长连接 (主要）</code> 移动端建立一条自己的长链接通道，通道的实现是基于 <code>tcp</code> 协议。基于 <code>tcp</code> 的 <code>socket</code> 编程技术难度相对复杂很多，而且需要自己定制协议。但信息的上报和推送变得更及时，请求量爆发的时间点还能减轻服务器压力（避免频繁创建和销毁连接） </p>
</li>
<li><p>方案 2. <code>http long-polling</code> 客户端在初始状态发送一个 <code>polling</code> 请求到服务器，服务器并不会马上返回业务数据，而是等待有新的业务数据产生的时候再返回，所以链接会一直被保持。一但结束当前连接，马上又会发送一个新的 <code>polling</code> 请求，如此反复，保证一个连接被保持。 </p>
<p>存在问题： </p>
<ol>
<li>增加了服务器的压力</li>
<li>网络环境复杂场景下，需要考虑怎么重建健康的连接通道</li>
<li><code>polling</code>的方式稳定性不好</li>
<li><code>polling</code>的<code>response</code>可能被中间代理<code>cache</code>住 ……</li>
</ol>
</li>
<li><p>方案 3. <code>http streaming</code> 和 <code>long-polling</code> 不同的是，<code>streaming</code> 方式通过在 <code>server response</code> 的头部增加“<code>Transfer Encoding:chuncked</code>”来告诉客户端后续还有新的数据到来</p>
<p>存在问题： </p>
<ol>
<li>有些代理服务器会等待服务器的 <code>response</code> 结束之后才将结果推送给请求客户端。<code>streaming</code> 不会结束 <code>response</code> </li>
<li>业务数据无法按照请求分割 ……</li>
</ol>
</li>
<li><p>方案 4. <code>web socket</code> 和传统的 <code>tcp socket</code> 相似，基于 <code>tcp</code> 协议，提供双向的数据通道。它的优势是提供了 <code>message</code> 的概念，比基于字节流的 <code>tcp socket</code> 使用更简单。技术较新，不是所有浏览器都提供了支持。</p>
</li>
</ul>
<h3 id="解决-head-of-line-blocking"><a href="#解决-head-of-line-blocking" class="headerlink" title="解决 head of line blocking"></a>解决 <code>head of line blocking</code></h3><p>它的原因是队列的第一个数据包（队头）受阻而导致整列数据包受阻使用 <strong>http pipelining</strong>，确保几乎在同一时间把 <code>request</code> 发向了服务器 </p>
<h3 id="Http-的-request-和-response-的协议组成"><a href="#Http-的-request-和-response-的协议组成" class="headerlink" title="Http 的 request 和 response 的协议组成"></a><code>Http</code> 的 <code>request</code> 和 <code>response</code> 的协议组成</h3><h4 id="Request-组成"><a href="#Request-组成" class="headerlink" title="Request 组成"></a><code>Request</code> 组成</h4><p>客户端发送一个 <code>HTTP</code> 请求到服务器的请求消息包括以下格式： </p>
<p>请求行（<code>request line</code>）、请求头部（<code>header</code>）、空行和请求数据四个部分组成。</p>
<p><img src="/posts/e3042463/Request%E7%BB%84%E6%88%90.png" alt="网络/Request组成"></p>
<p>请求行以一个方法符号开头，以空格分开，后面跟着请求的 <code>URI</code> 和协议的版本。</p>
<p><strong>Get 请求例子</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GET</span> /<span class="number">562</span>f25980001b1b106000338.jpg HTTP/<span class="number">1</span>.<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">Host</span> img.mukewang.com </span><br><span class="line"></span><br><span class="line"><span class="attribute">User</span>-Agent Mozilla/<span class="number">5</span>.<span class="number">0</span> (Windows NT <span class="number">10</span>.<span class="number">0</span>; WOW64) AppleWebKit/<span class="number">537</span>.<span class="number">36</span> (KHTML, like Gecko) Chrome/<span class="number">51</span>.<span class="number">0</span>.<span class="number">2704</span>.<span class="number">106</span> Safari/<span class="number">537</span>.<span class="number">36</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">Accept</span> image/webp,image/*,*/*;q=<span class="number">0</span>.<span class="number">8</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">Referer</span> http://www.imooc.com/ </span><br><span class="line"></span><br><span class="line"><span class="attribute">Accept</span>-Encoding gzip, deflate, sdch </span><br><span class="line"></span><br><span class="line"><span class="attribute">Accept</span>-Language zh-CN,zh;q=<span class="number">0</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的 <code>HTTP</code> 版本. <code>GET</code> 说明请求类型为 GET,[&#x2F;562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明 使用的是 <code>HTTP1.1</code> 版本。 </p>
<p>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息 从第二行起为请求头部，<code>HOST</code> 将指出请求的目的地.<code>User-Agent</code>,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 </p>
<p>第三部分：空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 </p>
<p>第四部分：请求数据也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。</p>
</blockquote>
<p><strong>POST 请求例子</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">POST</span> / HTTP1.<span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">Host</span>:www.wrox.com</span><br><span class="line"></span><br><span class="line"><span class="attribute">User</span>-Agent:Mozilla/<span class="number">4</span>.<span class="number">0</span> (compatible; MSIE <span class="number">6</span>.<span class="number">0</span>; Windows NT <span class="number">5</span>.<span class="number">1</span>; SV1; .NET CLR <span class="number">2</span>.<span class="number">0</span>.<span class="number">50727</span>; .NET CLR <span class="number">3</span>.<span class="number">0</span>.<span class="number">04506</span>.<span class="number">648</span>; .NET CLR <span class="number">3</span>.<span class="number">5</span>.<span class="number">21022</span>)</span><br><span class="line"></span><br><span class="line"><span class="attribute">Content</span>-Type:application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line"><span class="attribute">Content</span>-Length:<span class="number">40</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">name</span>=Professional%<span class="number">20</span>Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一部分：请求行，第一行明了是 <code>post</code> 请求，以及 <code>http1.1</code> 版本。 </p>
<p>第二部分：请求头部，第二行至第六行。 </p>
<p>第三部分：空行，第七行的空行。 </p>
<p>第四部分：请求数据，第八行。</p>
</blockquote>
<h4 id="Response-组成"><a href="#Response-组成" class="headerlink" title="Response 组成"></a><code>Response</code> 组成</h4><p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个 <code>HTTP</code> 的响应消息。<code>HTTP</code> 响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<p><img src="/posts/e3042463/Response%E7%BB%84%E6%88%90.png" alt="网络/Response组成"></p>
<ul>
<li>第一部分：状态行，由 <code>HTTP</code> 协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（<code>HTTP/1.1</code>）表明 <code>HTTP</code> 版本为 1.1 版本，状态码为 200，状态消息为（ok） </li>
<li>第二部分：消息报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头， <code>Date</code>:生成响应的日期和时间；<code>Content-Type</code>:指定了 MIME 类型的 <code>HTML(text/html)</code>,编码类型是 <code>UTF-8</code> </li>
<li>第三部分：空行，消息报头后面的空行是必须的</li>
<li>第四部分：响应正文，服务器返回给客户端的文本信息。 空行后面的 <code>html</code> 部分为响应正文。</li>
</ul>
<h3 id="谈谈对-http-缓存的了解"><a href="#谈谈对-http-缓存的了解" class="headerlink" title="谈谈对 http 缓存的了解"></a>谈谈对 <code>http</code> 缓存的了解</h3><p><code>HTTP</code> 的缓存机制也是依赖于请求和响应 <code>header</code> 里的参数类实现的，最终响应式从缓存中去，还是从服务端重新拉取，<code>HTTP</code> 的缓存机制的流程如下所示：<img src="/posts/e3042463/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="网络/HTTP缓存机制的流程"></p>
<h4 id="HTTP-的缓存可以分为两种："><a href="#HTTP-的缓存可以分为两种：" class="headerlink" title="HTTP 的缓存可以分为两种："></a><code>HTTP</code> 的缓存可以分为两种：</h4><h5 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h5><p>需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据是，服务端返回了缓存的过期时间（<code>Expires</code> 与 <code>Cache-Control</code>），没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。 </p>
<p>强制缓存使用的的两个标识： </p>
<ul>
<li><p><code>Expires</code>：<code>Expires</code> 的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。到期时间是服务端生成的，客户端和服务端的时间可能有误差。 </p>
</li>
<li><p><code>Cache-Control</code>：<code>Expires</code> 有个时间校验的问题，所有 <code>HTTP1.1</code> 采用 <code>Cache-Control</code> 替代 <code>Expires</code>。 <code>Cache-Control</code> 的取值有以下几种：</p>
<ul>
<li><code>private</code>: 客户端可以缓存。 </li>
<li><code>public</code>: 客户端和代理服务器都可缓存。 </li>
<li><code>max-age=xxx</code>: 缓存的内容将在 xxx 秒后失效 </li>
<li><code>no-cache</code>: 需要使用对比缓存来验证缓存数据。 </li>
<li><code>no-store</code>: 所有内容都不会缓存，强制缓存，对比缓存都不会触发。</li>
</ul>
</li>
</ul>
<h5 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h5><p>需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端会将缓存标识（<code>Last-Modified/If-Modified-Since</code> 与 <code>Etag/If-None-Match</code>）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存标识发送给服务端，服务端根据缓存标识进行判断，如果返回 <code>304</code>，则表示通知客户端可以继续使用缓存。 <strong>强制缓存优先于对比缓存</strong>。 </p>
<p>对比缓存的两个标识：</p>
<ul>
<li><p><code>Last-Modified/If-Modified-Since</code> (时间戳标记资源是否修改)</p>
<p><code>Last-Modified</code> 表示资源上次修改的时间。</p>
<p>当客户端发送第一次请求时，服务端返回资源上次修改的时间： </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last</span>-Modified: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</span><br></pre></td></tr></table></figure>

<p>客户端再次发送，会在 <code>header</code> 里携带 <code>If-Modified-Since</code>。将上次服务端返回的资源时间上传给服务端。 </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If</span>-Modified-Since: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</span><br></pre></td></tr></table></figure>

<p>服务端接收到客户端发来的资源修改时间，与自己当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改， 则返回 200 表示需要重新请求资源，否则返回 304 表示资源没有被修改，可以继续使用缓存。</p>
</li>
<li><p><code>Etag/If-None-Match</code>(资源标识码 <code>ETag</code> 的方式来标记是否修改)</p>
<p><strong><code>ETag</code> 优先级高于 <code>Last-Modified</code></strong></p>
<p><code>ETag</code> 是资源文件的一种标识码，当客户端发送第一次请求时，服务端会返回当前资源的标识码： </p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ETag:</span> <span class="string">&quot;5694c7ef-24dc&quot;</span> </span><br></pre></td></tr></table></figure>

<p>客户端再次发送，会在 <code>header</code> 里携带上次服务端返回的资源标识码： </p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">If</span><span class="operator">-</span><span class="built_in">None</span><span class="operator">-</span><span class="variable">Match</span><span class="operator">:</span><span class="string">&quot;5694c7ef-24dc&quot;</span></span><br></pre></td></tr></table></figure>

<p>服务端接收到客户端发来的资源标识码，则会与自己当前的资源吗进行比较，如果不同，则说明资源已经被修改，则返回 200，如果相同则说明资源没有被修改，返回 304，客户端可以继续使用缓存。</p>
</li>
</ul>
<h3 id="Http-长连接。"><a href="#Http-长连接。" class="headerlink" title="Http 长连接。"></a><code>Http</code> 长连接。</h3><p><code>Http1.0</code> 是短连接，<code>HTTP1.1</code> <strong>默认是长连接</strong>，也就是默认 <code>Connection</code> 的值就是 <code>keep-alive</code>。 但是长连接实质是指的 <code>TCP</code> 连接，而不是 <code>HTTP</code> 连接。<code>TCP</code> 连接是一个<strong>双向的通道</strong>，它是可以保持一段时间不关闭的，因此 <code>TCP</code> 连接才有真正的长连接和短连接这一说。</p>
<h4 id="Http1-1-为什么要用使用-tcp-长连接？"><a href="#Http1-1-为什么要用使用-tcp-长连接？" class="headerlink" title="Http1.1 为什么要用使用 tcp 长连接？"></a><code>Http1.1</code> 为什么要用使用 <code>tcp</code> 长连接？</h4><p>长连接是指的 <code>TCP</code> 连接，也就是说复用的是 <code>TCP</code> 连接。即长连接情况下，多个 <code>HTTP</code> 请求可以复用同一个 <code>TCP</code> 连接，这就节省了很多 <code>TCP</code> 连接建立和断开的消耗。此外，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在 <code>header</code> 当中进行设置的，也就是所谓的<code>超时时间</code>），这个连接没有 <code>HTTP</code> 请求发出的话，那么这个长连接就会被断掉。 </p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3fc3646fad80">需要更深的理解请点击这里</a> </p>
<h2 id="Https-加密原理"><a href="#Https-加密原理" class="headerlink" title="Https 加密原理"></a>Https 加密原理</h2><p>加密算法的类型基本上分为了两种： </p>
<ul>
<li>对称加密，加密用的密钥和解密用的密钥是同一个，比较有代表性的就是 <code>AES</code> 加密算法； </li>
<li>非对称加密，加密用的密钥称为公钥，解密用的密钥称为私钥，经常使用到的 <code>RSA</code> 加密算法就是非对称加密的；</li>
</ul>
<p>此外，还有 <code>Hash</code> 加密算法 </p>
<p><code>HASH</code> 算法：<code>MD5</code>, <code>SHA1</code>, <code>SHA256</code> </p>
<p>相比较对称加密而言，非对称加密安全性更高，但是加解密耗费的时间更长，速度慢。 </p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903638117122056">了解更多加密算法请点击这里</a></p>
<p><code>HTTPS = HTTP + SSL</code>，<code>HTTPS</code> 的加密就是在 <code>SSL</code> 中完成的。 </p>
<p>这就要从 <code>CA</code> 证书讲起了。<code>CA</code> 证书其实就是数字证书，是由 <code>CA</code> 机构颁发的。至于 <code>CA</code> 机构的权威性，那么是毋庸置疑的，所有人都是信任它的。<code>CA</code> 证书内一般会包含以下内容： </p>
<ul>
<li>证书的颁发机构、版本 </li>
<li>证书的使用者 </li>
<li>证书的公钥 </li>
<li>证书的有效时间 </li>
<li>证书的数字签名 <code>Hash</code> 值和签名 <code>Hash</code> 算法 </li>
<li>…</li>
</ul>
<h3 id="客户端如何校验-CA-证书？"><a href="#客户端如何校验-CA-证书？" class="headerlink" title="客户端如何校验 CA 证书？"></a>客户端如何校验 CA 证书？</h3><p><code>CA</code> 证书中的 <code>Hash</code> 值，其实是用证书的私钥进行加密后的值（证书的私钥不在 <code>CA</code> 证书中）。然后客户端得到证书后，利用证书中的公钥去解密该 <code>Hash</code> 值，得到 <code>Hash-a</code> ；然后再利用证书内的签名 <code>Hash</code> 算法去生成一个 <code>Hash-b</code> 。最后比较 <code>Hash-a</code> 和 <code>Hash-b</code> 这两个的值。如果相等，那么证明了该证书是对的，服务端是可以被信任的；如果不相等，那么就说明该证书是错误的，可能被篡改了，浏览器会给出相关提示，无法建立起 <code>HTTPS</code> 连接。除此之外，还会校验 <code>CA</code> 证书的<strong>有效时间</strong>和<strong>域名匹配</strong>等。</p>
<h3 id="HTTPS-中的-SSL-握手建立过程"><a href="#HTTPS-中的-SSL-握手建立过程" class="headerlink" title="HTTPS 中的 SSL 握手建立过程"></a><code>HTTPS</code> 中的 <code>SSL</code> 握手建立过程</h3><p>假设现在有客户端 A 和服务器 B ： </p>
<ol>
<li>首 先 ， 客 户 端 A 访 问 服 务 器 B ， 比 如 我 们 用 浏 览 器 打 开 一 个 网 页 <code>www.baidu.com</code> ，这时，浏览器就是客户端 A ，百度的服务器就是服务器 B 了。这时候客户端 A 会生成一个随机数 1，把随机数 1 、自己支持的 <code>SSL</code> 版本号以及加密算法等这些信息告诉服务器 B 。 </li>
<li>服务器 B 知道这些信息后，然后确认一下双方的加密算法，然后服务端也生成一个随机数 B ，并将随机数 B 和 <code>CA</code> 颁发给自己的证书一同返回给客户端 A 。 </li>
<li>客户端 A 得到 <code>CA</code> 证书后，会去校验该 <code>CA</code> 证书的有效性，校验方法在上面已经说过了。校验通过后，客户端生成一个随机数 3 ，然后用证书中的公钥加密随机数 3 并传输给服务端 B 。 </li>
<li>服务端 B 得到加密后的随机数 3，然后利用私钥进行解密，得到真正的随机数 3。 </li>
<li>最后，客户端 A 和服务端 B 都有随机数 1、随机数 2、随机数 3，然后双方利用这三个随机数生成一个对话密钥。之后传输内容就是利用对话密钥来进行加解密了。这时就是利用了对称加密，一般用的都是 <code>AES</code> 算法。 </li>
<li>客户端 A 通知服务端 B ，指明后面的通讯用对话密钥来完成，同时通知服务器 B 客户端 A 的握手过程结束。 </li>
<li>服务端 B 通知客户端 A，指明后面的通讯用对话密钥来完成，同时通知客户端 A 服务器 B 的握手过程结束。 </li>
<li><code>SSL</code> 的握手部分结束，<code>SSL</code> 安全通道的数据通讯开始，客户端 A 和服务器 B 开始使用相同的对话密钥进行数据通讯。</li>
</ol>
<p>简化如下： </p>
<ol>
<li>客户端和服务端建立 <code>SSL</code> 握手，客户端通过 <code>CA</code> 证书来确认服务端的身份； </li>
<li>互相传递三个随机数，之后通过这随机数来生成一个密钥； </li>
<li>互相确认密钥，然后握手结束； </li>
<li>数据通讯开始，都使用同一个对话密钥来加解密；</li>
</ol>
<p>可以发现，在 <code>HTTPS</code> 加密原理的过程中把对称加密和非对称加密都利用了起来。即利用了非对称加密安全性高的特点，又利用了对称加密速度快，效率高的好处。<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903569343119367">了解更深请点击这里</a></p>
<h3 id="HTTPS-如何防范中间人攻击？"><a href="#HTTPS-如何防范中间人攻击？" class="headerlink" title="HTTPS 如何防范中间人攻击？"></a>HTTPS 如何防范中间人攻击？</h3><h4 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h4><p>当数据传输发生在一个设备（PC&#x2F;手机）和网络服务器之间时，攻击者使用其技能和工具将自己置于两个端点之间并截获数据；尽管交谈的两方认为他们是在与对方交谈，但是实际上他们是在与干坏事的人交流，这便是中间人攻击。</p>
<h4 id="有几种攻击方式？"><a href="#有几种攻击方式？" class="headerlink" title="有几种攻击方式？"></a>有几种攻击方式？</h4><ol>
<li>嗅探：嗅探或数据包嗅探是一种用于捕获流进和流出系统&#x2F;网络的数据包的技术。网络中的数据包嗅探就好像电话中的监听。 </li>
<li>数据包注入： 在这种技术中，攻击者会将恶意数据包注入常规数据中。这样用户便不会注意到文件&#x2F;恶意软件，因为它们是合法通讯流的一部分。 </li>
<li>会话劫持： 在你登录进你的银行账户和退出登录这一段期间便称为一个会话。这些会话通常都是黑客的攻击目标，因为它们包含潜在的重要信息。在大多数案例中，黑客会潜伏在会话中，并最终控制它。 </li>
<li><code>SSL</code> 剥离： 在 <code>SSL</code> 剥离攻击中，攻击者使 <code>SSL/TLS</code> 连接剥落，随之协议便从安全的 <code>HTTPS</code> 变成了不安全的 <code>HTTP</code>。</li>
</ol>
<h4 id="HTTPS-如何防范中间人攻击："><a href="#HTTPS-如何防范中间人攻击：" class="headerlink" title="HTTPS 如何防范中间人攻击："></a>HTTPS 如何防范中间人攻击：</h4><p>请见 <code>https</code> 加密原理。</p>
<h3 id="有哪些响应码，分别都代表什么意思？"><a href="#有哪些响应码，分别都代表什么意思？" class="headerlink" title="有哪些响应码，分别都代表什么意思？"></a>有哪些响应码，分别都代表什么意思？</h3><ul>
<li>1** 信息，服务器收到请求，需要请求者继续执行操作 </li>
<li>2** 成功，操作被成功接收并处理 </li>
<li>3** 重定向，需要进一步的操作以完成请求 </li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求 </li>
<li>5** 服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
<h1 id="TCP-UDP（⭐⭐⭐）"><a href="#TCP-UDP（⭐⭐⭐）" class="headerlink" title="TCP/UDP（⭐⭐⭐）"></a><code>TCP/UDP</code>（⭐⭐⭐）</h1><h2 id="为什么-tcp-要经过三次握手，四次挥手？"><a href="#为什么-tcp-要经过三次握手，四次挥手？" class="headerlink" title="为什么 tcp 要经过三次握手，四次挥手？"></a>为什么 tcp 要经过三次握手，四次挥手？</h2><h3 id="重要标志位"><a href="#重要标志位" class="headerlink" title="重要标志位"></a>重要标志位</h3><ul>
<li><p><code>ACK</code> </p>
<p><code>TCP</code> 协议规定，只有 <code>ACK=1</code> 时有效，也规定连接建立后所有发送的报文的 <code>ACK</code> 必须为 1</p>
</li>
<li><p><code>SYN</code>(<code>SYNchronization</code>) </p>
<p>在连接建立时用来同步序号。当 <code>SYN=1</code> 而 <code>ACK=0</code> 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使<code>SYN=1</code>和<code>ACK=1</code>. 因此, <code>SYN</code> 置 1 就表示这是一个连接请求或连接接受报文。 </p>
</li>
<li><p><code>FIN</code> （<code>finish</code>）</p>
<p>即完，终结的意思， 用来释放一个连接。当 <code>FIN = 1</code> 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p>
</li>
</ul>
<h3 id="三次握手、四次挥手过程"><a href="#三次握手、四次挥手过程" class="headerlink" title="三次握手、四次挥手过程"></a>三次握手、四次挥手过程</h3><p><img src="/posts/e3042463/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B.png" alt="网络/TCP三次握手过程"></p>
<blockquote>
<ul>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认； </li>
<li>第二次握手：服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时，自己自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态； </li>
<li>第三次握手：客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。</li>
</ul>
</blockquote>
<p><img src="/posts/e3042463/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="网络/TCP四次挥手"></p>
<blockquote>
<ul>
<li><p>第一次分手：主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了； </p>
</li>
<li><p>第二次分手：主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段， Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我“同意”你的关闭请求； </p>
</li>
<li><p>第三次分手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态； </p>
</li>
<li><p>第四次分手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。主要目的防止 <code>server</code> 端一直等待，浪费资源。换句话说，即是为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。 </p>
</li>
<li><p>“四次挥手”原因是因为 <code>tcp</code> 是全双工模式，接收到 <code>FIN</code> 时意味将没有数据再发来，但是还是可以继续发送数据。</p>
</li>
</ul>
<h2 id="TCP-可靠传输原理实现（滑动窗口）"><a href="#TCP-可靠传输原理实现（滑动窗口）" class="headerlink" title="TCP 可靠传输原理实现（滑动窗口）"></a><code>TCP</code> 可靠传输原理实现（滑动窗口）</h2><ul>
<li><p>确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。 </p>
</li>
<li><p>数据校验。 </p>
<p>数据合理分片与排序，TCP 会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。 </p>
</li>
<li><p>流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。</p>
</li>
<li><p>拥塞控制：当网络发生拥塞时，减少数据的发送。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-26275986-id-4109679.html">关于滑动窗口、流量控制、拥塞控制实现原理请点击这里</a> </p>
<h2 id="Tcp-和-Udp-的区别？"><a href="#Tcp-和-Udp-的区别？" class="headerlink" title="Tcp 和 Udp 的区别？"></a><code>Tcp</code> 和 <code>Udp</code> 的区别？</h2><ol>
<li>基于连接与无连接； </li>
<li>对系统资源的要求（<code>TCP</code> 较多，<code>UDP</code> 少）； </li>
<li><code>UDP</code> 程序结构较简单； </li>
<li>流模式与数据报模式 ； </li>
<li><code>TCP</code> 保证数据正确性，<code>UDP</code> 可能丢包； </li>
<li><code>TCP</code> 保证数据顺序，<code>UDP</code> 不保证。</li>
</ol>
<h2 id="如何设计在-UDP-上层保证-UDP-的可靠性传输？"><a href="#如何设计在-UDP-上层保证-UDP-的可靠性传输？" class="headerlink" title="如何设计在 UDP 上层保证 UDP 的可靠性传输？"></a>如何设计在 <code>UDP</code> 上层保证 <code>UDP</code> 的可靠性传输？</h2><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照 <code>tcp</code> 可靠性传输的方式。如不考虑拥塞处理，可靠 <code>UDP</code> 的简单设计如下： </p>
<ol>
<li>添加 <code>seq/ack</code> 机制，确保数据发送到对端 </li>
<li>添加发送和接收缓冲区，主要是用户超时重传。 </li>
<li>添加超时重传机制。</li>
</ol>
<p>具体过程即是：</p>
<ol>
<li>送端发送数据时，生成一个随机 <code>seq=x</code>，然后每一片按照数据大小分配 <code>seq</code>。</li>
<li>数据到达接收端后接收端放入缓存，并发送一个 <code>ack=x</code> 的包，表示对方已经收到了数据。 </li>
<li>发送端收到了 <code>ack</code> 包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</li>
</ol>
<p>目前有如下开源程序利用 <code>udp</code> 实现了可靠的数据传输。分别为 <code>RUDP</code>、<code>RTP</code>、<code>UDT</code>: </p>
<ol>
<li><p><code>RUDP</code>（<code>Reliable User Datagram Protocol</code>） </p>
<p><code>RUDP</code> 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等。</p>
</li>
<li><p><code>RTP</code>（<code>Real Time Protocol</code>） </p>
<p><code>RTP</code> 为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。 </p>
</li>
<li><p><code>UDT</code>（<code>UDP-based Data Transfer Protocol</code>） </p>
<p><code>UDT</code> 的主要目的是支持高速广域网上的海量数据传输。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6c73a4585eba">关于 RUDP、RTP、UDT 的更多介绍请查看此处</a></p>
<h1 id="其它重要网络概念（⭐⭐）"><a href="#其它重要网络概念（⭐⭐）" class="headerlink" title="其它重要网络概念（⭐⭐）"></a>其它重要网络概念（⭐⭐）</h1><h2 id="socket-断线重连怎么实现，心跳机制又是怎样实现？"><a href="#socket-断线重连怎么实现，心跳机制又是怎样实现？" class="headerlink" title="socket 断线重连怎么实现，心跳机制又是怎样实现？"></a>socket 断线重连怎么实现，心跳机制又是怎样实现？</h2><h3 id="socket-概念"><a href="#socket-概念" class="headerlink" title="socket 概念"></a>socket 概念</h3><p>套接字（<code>socket</code>）是通信的基石，是支持 <code>TCP/IP</code> 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 <code>IP</code> 地址，本地进程的协议端口，远地主机的 <code>IP</code> 地址，远地进程的协议端口。 </p>
<p>为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 <code>TCP／IP</code> 协议交互提供了套接字(<code>Socket</code>)接口。应用层可以和传输层通过 <code>Socket</code> 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<h3 id="建立-socket-连接"><a href="#建立-socket-连接" class="headerlink" title="建立 socket 连接"></a>建立 socket 连接</h3><p>建立 <code>Socket</code> 连接至少需要<strong>一对套接字</strong>，其中一个运行于客户端，称为 <code>ClientSocket</code> ，另一个运行于服务器端，称为 <code>ServerSocket</code> 。 </p>
<p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 </p>
<ol>
<li><p>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 </p>
</li>
<li><p>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。 </p>
<p>为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端–套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
</li>
</ol>
<h3 id="SOCKET-连接与-TCP-连接"><a href="#SOCKET-连接与-TCP-连接" class="headerlink" title="SOCKET 连接与 TCP 连接"></a>SOCKET 连接与 TCP 连接</h3><p>创建 <code>Socket</code> 连接时，可以指定使用的传输层协议，<code>Socket</code> 可以支持不同的传输层协议（<code>TCP</code> 或 <code>UDP</code>），当使用 <code>TCP</code> 协议进行连接时，该 <code>Socket</code> 连接就是一个 <code>TCP</code> 连接。 </p>
<h3 id="Socket-连接与-HTTP-连接"><a href="#Socket-连接与-HTTP-连接" class="headerlink" title="Socket 连接与 HTTP 连接"></a>Socket 连接与 HTTP 连接</h3><p>由于通常情况下 <code>Socket</code> 连接就是 <code>TCP</code> 连接，因此 <code>Socket</code> 连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 <code>Socket</code> 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。 </p>
<p>而 <code>HTTP</code> 连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。 </p>
<p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是 <code>Socket</code> 连接，服务器就可以直接将数据传送给客户端；若双方建立的是 <code>HTTP</code> 连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。<code>TCP</code>(<code>Transmission Control Protocol</code>) 传输控制协议</p>
<h3 id="socket-断线重连实现"><a href="#socket-断线重连实现" class="headerlink" title="socket 断线重连实现"></a>socket 断线重连实现</h3><p>正常连接断开客户端会给服务端发送一个 <code>fin</code> 包，服务端收到 <code>fin</code> 包后才会知道连接断开。而断网断电时客户端无法发送 <code>fin</code> 包给服务端，所以服务端没办法检测到客户端已经断线。为了缓解这个问题，服务端需要有个心跳逻辑，就是服务端检测到某个客户端多久没发送任何数据过来就认为客户端已经断开，这需要客户端定时向服务端发送心跳数据维持连接。</p>
<h3 id="心跳机制实现"><a href="#心跳机制实现" class="headerlink" title="心跳机制实现"></a>心跳机制实现</h3><p>长连接的实现：心跳机制，应用层协议大多都有 <code>HeartBeat</code> 机制，通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线。并传输一些可能必要的数据。使用心跳包的典型协议是 <code>IM</code>，比如 <code>QQ/MSN/飞信</code>等协议 </p>
<ol>
<li><p>在 <code>TCP</code> 的机制里面，本身是存在有心跳包的机制的，也就是 <code>TCP</code> 的选项：<code>SO_KEEPALIVE</code>。系统默认是设置的 2 小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。 而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。通过使用 <code>TCP</code> 的 <code>KeepAlive</code> 机制（修改那个 <code>time</code> 参数），可以让连接每隔一小段时间就产生一些 <code>ack</code> 包，以降低被踢掉的风险，当然，这样的代价是额外的网络和 <code>CPU</code> 负担。 </p>
</li>
<li><p>应用层心跳机制实现。</p>
</li>
</ol>
<h2 id="Cookie-与-Session-的作用和原理"><a href="#Cookie-与-Session-的作用和原理" class="headerlink" title="Cookie 与 Session 的作用和原理"></a>Cookie 与 Session 的作用和原理</h2><ul>
<li><code>Session</code> 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 </li>
<li><code>Cookie</code> 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 <code>Session</code> 的一种方式。</li>
</ul>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>由于 <code>HTTP</code> 协议是<strong>无状态</strong>的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是 <code>Session</code>.典型的场景比如购物车，当你点击下单按钮时，由于 <code>HTTP</code> 协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的 Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个 <code>Session</code> 是保存在<strong>服务端</strong>的，有一个唯一标识。在服务端保存 <code>Session</code> 的方法很多，内存、数据库、文件都有。集群的时候也要考虑 <code>Session</code> 的转移，在大型的网站，一般会有专门的 <code>Session</code> 服务器集群，用来保存用户会话，这个时候 <code>Session</code> 信息都是放在内存的。具体到 <code>Web</code> 中的 <code>Session</code> 指的就是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。因此从上述的定义中我们可以看到，<code>Session</code> 实际上是一个特定的时间概念。当客户端访问服务器时，服务器根据需求设置 <code>Session</code>，将会话信息保存在服务器上，同时将标示 <code>Session</code> 的 <code>SessionId</code> 传递给客户端浏览器，浏览器将这个 <code>SessionId</code> 保存在<strong>内存</strong>中，我们称之为无过期时间的 <code>Cookie</code>。浏览器关闭后，这个 <code>Cookie</code> 就会被清掉，它不会存在于用户的 <code>Cookie</code> 临时文件。以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个 <code>SessionId</code>，就能取得客户端的数据信息。 </p>
<p>如果客户端浏览器意外关闭，服务器保存的 <code>Session</code> 数据不是立即释放，此时数据还会存在，只要我们知道那个 <code>SessionId</code>,就可以继续通过请求获得此 <code>Session</code> 的信息，因为此时后台的 <code>Session</code> 还存在，当然我们可以设置一个 <code>Session</code> <strong>超时时间</strong>，一旦超过规定时间没有客户端请求时，服务器就会清除对应<code>SessionId</code> 的 <code>Session</code> 信息。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><code>Cookie</code> 是由<strong>服务器端</strong>生成，发送给 <code>User-Agent</code>（一般是 <code>web</code> 浏览器），浏览器会将 <code>Cookie</code> 的 <code>key/value</code> 保存到某个目录下的文本文件内，下次请求同一网站时就发送该 <code>Cookie</code> 给服务器（前提是浏览器设置为启用 <code>Cookie</code>）。<code>Cookie</code> 名称和值可以由服务器端开发自己定义，对于 <code>JSP</code> 而言也可以直接写入 <code>Sessionid</code>，这样服务器可以知道该用户是否合法用户以及是否需要重新登录等。</p>
<h2 id="IP-报文中的内容"><a href="#IP-报文中的内容" class="headerlink" title="IP 报文中的内容"></a>IP 报文中的内容</h2><p><img src="/posts/e3042463/IP%E6%8A%A5%E6%96%87%E5%86%85%E5%AE%B9.png" alt="网络/IP报文内容"></p>
<blockquote>
<ul>
<li><p>版本：IP 协议的版本，目前的 IP 协议版本号为 4，下一代 IP 协议版本号为 6。</p>
</li>
<li><p>首部长度：IP 报头的长度。固定部分的长度（20 字节）和可变部分的长度之和。共占 4 位。 最大为 1111，即 10 进制的 15，代表 IP 报头的最大长度可以为 15 个 32bits（4 字节），也就是最长可为 15*4&#x3D;60 字节，除去固定部分的长度 20 字节，可变部分的长度最大为 40 字节。</p>
</li>
<li><p>服务类型：Type Of Service。 </p>
</li>
<li><p>总长度：IP 报文的总长度。报头的长度和数据部分的长度之和。 </p>
</li>
<li><p>标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当 IP 报文长度超过传输网络的 MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。 </p>
</li>
<li><p>标志：共 3 位。R、DF、MF 三位。目前只有后两位有效，DF 位：为 1 表示不分片，为 0 表示分片。MF：为 1 表示“更多的片”，为 0 表示这是最后一片。 </p>
</li>
<li><p>片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以 8） </p>
</li>
<li><p>生存时间：IP 报文所允许通过的路由器的最大数量。每经过一个路由器，TTL 减 1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit 字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。</p>
</li>
<li><p>协议：指出 IP 报文携带的数据使用的是那种协议，以便目的主机的 IP 层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP 的协议号为 6，UDP 的协议号为 17。ICMP 的协议号为 1，IGMP 的协议号为 2. </p>
</li>
<li><p>首部校验和：计算 IP 头部的校验和，检查 IP 报头的完整性。 </p>
</li>
<li><p>源 IP 地址：标识 IP 数据报的源端设备。 </p>
</li>
<li><p>目的 IP 地址：标识 IP 数据报的目的地址。 </p>
</li>
<li><p>最后就是可变部分和数据部分。</p>
</li>
</ul>
</blockquote>
<h1 id="常见网络流程机制-（⭐⭐）"><a href="#常见网络流程机制-（⭐⭐）" class="headerlink" title="常见网络流程机制 （⭐⭐）"></a>常见网络流程机制 （⭐⭐）</h1><h2 id="浏览器输入地址到返回结果发生了什么？"><a href="#浏览器输入地址到返回结果发生了什么？" class="headerlink" title="浏览器输入地址到返回结果发生了什么？"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006879700">浏览器输入地址到返回结果发生了什么？</a></h2><p>总体来说分为以下几个过程: </p>
<ol>
<li>DNS 解析，此外还有 DNSy 优化（DNS 缓存、DNS 负载均衡） </li>
<li>TCP 连接 </li>
<li>发送 HTTP 请求 </li>
<li>服务器处理请求并返回 HTTP 报文 </li>
<li>浏览器解析渲染页面 </li>
<li>连接结束</li>
</ol>
<h2 id="Web-前端的本质"><a href="#Web-前端的本质" class="headerlink" title="Web 前端的本质"></a>Web 前端的本质</h2><p>将信息快速并友好的展示给用户并能够与用户进行交互。 </p>
<h2 id="如何尽快的加载资源（网络优化）？"><a href="#如何尽快的加载资源（网络优化）？" class="headerlink" title="如何尽快的加载资源（网络优化）？"></a>如何尽快的加载资源（网络优化）？</h2><p>答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即 <code>DNS</code> 优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。 </p>
<!-- flag of hidden posts -->
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/private/" rel="tag"># private</a>
          
            <a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">292</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:shenbh@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/ptwenzi?spm=1010.2135.3001.5113" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-clone"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OSI%E3%80%81TCP-x2F-IP"><span class="nav-text">OSI、TCP&#x2F;IP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-text">运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E4%B8%8E-UDP-%E7%9A%84%E5%AF%B9%E2%BD%90%E2%BB%85%E9%97%AE%E9%A2%98%E4%B8%89%E3%80%82"><span class="nav-text">TCP 与 UDP 的对⽐⻅问题三。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%BD%B9%E7%BB%9C%E5%B1%82"><span class="nav-text">⽹络层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-text">数据链路层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-text">物理层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E2%BC%80%E4%B8%8B"><span class="nav-text">总结⼀下</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-x2F-HTTPS%EF%BC%88%E2%AD%90%E2%AD%90%E2%AD%90%EF%BC%89"><span class="nav-text">HTTP&#x2F;HTTPS（⭐⭐⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E4%B8%8EHTTPS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-text">HTTP与HTTPS有什么区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTPPS-%E5%92%8C-HTTP-%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="nav-text">HTPPS 和 HTTP 的概念：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Http1-1-%E5%92%8C-Http1-0-%E5%8F%8A-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">Http1.1 和 Http1.0 及 2.0 的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP1-0-%E5%92%8C-HTTP1-1-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="nav-text">HTTP1.0 和 HTTP1.1 的一些区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPDY"><span class="nav-text">SPDY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP2-0-%E5%92%8C-HTTP1-X-%E7%9B%B8%E6%AF%94%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">HTTP2.0 和 HTTP1.X 相比的新特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Https-%E8%AF%B7%E6%B1%82%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-text">Https 请求慢的解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E9%80%9A%E8%BF%87-DNS-%E8%A7%A3%E6%9E%90%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE-IP"><span class="nav-text">不通过 DNS 解析，直接访问 IP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E8%BF%9E%E6%8E%A5%E6%97%A0%E6%B3%95%E5%A4%8D%E7%94%A8"><span class="nav-text">解决连接无法复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3-head-of-line-blocking"><span class="nav-text">解决 head of line blocking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http-%E7%9A%84-request-%E5%92%8C-response-%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%BB%84%E6%88%90"><span class="nav-text">Http 的 request 和 response 的协议组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Request-%E7%BB%84%E6%88%90"><span class="nav-text">Request 组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Response-%E7%BB%84%E6%88%90"><span class="nav-text">Response 组成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9-http-%E7%BC%93%E5%AD%98%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-text">谈谈对 http 缓存的了解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E7%9A%84%E7%BC%93%E5%AD%98%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E4%B8%A4%E7%A7%8D%EF%BC%9A"><span class="nav-text">HTTP 的缓存可以分为两种：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="nav-text">强制缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E7%BC%93%E5%AD%98"><span class="nav-text">对比缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http-%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%82"><span class="nav-text">Http 长连接。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Http1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E4%BD%BF%E7%94%A8-tcp-%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-text">Http1.1 为什么要用使用 tcp 长连接？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Https-%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86"><span class="nav-text">Https 加密原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C-CA-%E8%AF%81%E4%B9%A6%EF%BC%9F"><span class="nav-text">客户端如何校验 CA 证书？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS-%E4%B8%AD%E7%9A%84-SSL-%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B"><span class="nav-text">HTTPS 中的 SSL 握手建立过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS-%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-text">HTTPS 如何防范中间人攻击？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-text">什么是中间人攻击？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%87%A0%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">有几种攻击方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9A"><span class="nav-text">HTTPS 如何防范中间人攻击：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%93%8D%E5%BA%94%E7%A0%81%EF%BC%8C%E5%88%86%E5%88%AB%E9%83%BD%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="nav-text">有哪些响应码，分别都代表什么意思？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-UDP%EF%BC%88%E2%AD%90%E2%AD%90%E2%AD%90%EF%BC%89"><span class="nav-text">TCP&#x2F;UDP（⭐⭐⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-tcp-%E8%A6%81%E7%BB%8F%E8%BF%87%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-text">为什么 tcp 要经过三次握手，四次挥手？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-text">重要标志位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-text">三次握手、四次挥手过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="nav-text">TCP 可靠传输原理实现（滑动窗口）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tcp-%E5%92%8C-Udp-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">Tcp 和 Udp 的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%9C%A8-UDP-%E4%B8%8A%E5%B1%82%E4%BF%9D%E8%AF%81-UDP-%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="nav-text">如何设计在 UDP 上层保证 UDP 的可靠性传输？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E9%87%8D%E8%A6%81%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%EF%BC%88%E2%AD%90%E2%AD%90%EF%BC%89"><span class="nav-text">其它重要网络概念（⭐⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#socket-%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E5%8F%88%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">socket 断线重连怎么实现，心跳机制又是怎样实现？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-%E6%A6%82%E5%BF%B5"><span class="nav-text">socket 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B-socket-%E8%BF%9E%E6%8E%A5"><span class="nav-text">建立 socket 连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SOCKET-%E8%BF%9E%E6%8E%A5%E4%B8%8E-TCP-%E8%BF%9E%E6%8E%A5"><span class="nav-text">SOCKET 连接与 TCP 连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket-%E8%BF%9E%E6%8E%A5%E4%B8%8E-HTTP-%E8%BF%9E%E6%8E%A5"><span class="nav-text">Socket 连接与 HTTP 连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E%E5%AE%9E%E7%8E%B0"><span class="nav-text">socket 断线重连实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0"><span class="nav-text">心跳机制实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie-%E4%B8%8E-Session-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-text">Cookie 与 Session 的作用和原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Session"><span class="nav-text">Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie"><span class="nav-text">Cookie</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP-%E6%8A%A5%E6%96%87%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-text">IP 报文中的内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%B5%81%E7%A8%8B%E6%9C%BA%E5%88%B6-%EF%BC%88%E2%AD%90%E2%AD%90%EF%BC%89"><span class="nav-text">常见网络流程机制 （⭐⭐）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%88%B0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">浏览器输入地址到返回结果发生了什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web-%E5%89%8D%E7%AB%AF%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-text">Web 前端的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%BD%E5%BF%AB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90%EF%BC%88%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%EF%BC%89%EF%BC%9F"><span class="nav-text">如何尽快的加载资源（网络优化）？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿炳</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('Copied')
          else $(this).text('Copy failed')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>